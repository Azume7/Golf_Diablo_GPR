<!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Gestion Tournois Golf - Scores DÃƒÂ©taillÃƒÂ©s</title>
    <!-- Firebase SDKs -->
	<script src="https://www.gstatic.com/firebasejs/9.22.0/firebase-app-compat.js"></script>
	<script src="https://www.gstatic.com/firebasejs/9.22.0/firebase-database-compat.js"></script>
	<!-- EmailJS SDK pour les notifications -->
	<script src="https://cdn.jsdelivr.net/npm/@emailjs/browser@3/dist/email.min.js"></script>
	<script>
    	// Initialiser EmailJS avec vos paramÃƒÂ¨tres
    	(function() {
        	emailjs.init("Lcpl3KzU2V4_mqe9A");
    	})();
	</script>
	<style>
        body {
            font-family: Arial, sans-serif;
            background: #f0f0f0;
            margin: 0;
            padding: 20px;
        }
        .container {
            max-width: 1400px;
            margin: 0 auto;
            background: white;
            border-radius: 10px;
            padding: 30px;
            box-shadow: 0 4px 8px rgba(0,0,0,0.1);
        }
        h1 { color: #2c5530; text-align: center; margin-bottom: 30px; }
        .nav { text-align: center; margin-bottom: 30px; }
		.nav-row {
    		display: flex;
    		justify-content: center;
    		gap: 10px;
    		margin-bottom: 10px;
    		flex-wrap: wrap;
		}
		.nav-save {
    		display: flex;
    		justify-content: center;
    		margin-top: 15px;
		}
		.nav button {
    		color: white; border: none;
    		padding: 10px 20px; margin: 5px; border-radius: 5px; cursor: pointer;
    		font-size: 14px;
    		transition: all 0.3s ease;
		}
		.nav button:hover { 
    		transform: translateY(-2px);
    		box-shadow: 0 4px 8px rgba(0,0,0,0.2);
		}
		.nav button.active { 
    		box-shadow: 0 0 15px rgba(255,255,255,0.5);
    		font-weight: bold;
		}

		/* Couleurs des boutons */
		.nav-yellow { background: #f39c12; }
		.nav-yellow:hover { background: #e67e22; }
		.nav-purple { background: #9b59b6; }
		.nav-purple:hover { background: #8e44ad; }
		.nav-green { background: #27ae60; }
		.nav-green:hover { background: #229954; }
		.nav-blue { background: #3498db; }
		.nav-blue:hover { background: #2980b9; }
		.nav-save-btn { 
    		background: #e74c3c; 
    		font-weight: bold;
    		padding: 12px 30px;
    		font-size: 16px;
		}
		.nav-save-btn:hover { background: #c0392b; }
        .section { display: none; }
        .section.active { display: block; }
        .btn {
            background: #4a7c59; color: white; border: none;
            padding: 10px 15px; border-radius: 5px; cursor: pointer; margin: 5px;
        }
        .btn:hover { background: #2c5530; }
        .btn-secondary {
            background: #6c757d; color: white; border: none;
            padding: 10px 15px; border-radius: 5px; cursor: pointer; margin: 5px;
        }
        .btn-danger {
            background: #dc3545; color: white; border: none;
            padding: 8px 12px; border-radius: 5px; cursor: pointer; margin: 5px;
        }
        .card {
            background: #f9f9f9; padding: 20px; margin: 15px 0;
            border-radius: 8px; border-left: 4px solid #4a7c59;
        }
        .table {
            width: 100%; border-collapse: collapse; margin: 20px 0;
        }
        .table th, .table td {
            border: 1px solid #ddd; padding: 8px; text-align: left;
        }
        .table th { background: #4a7c59; color: white; }
        .table tr:nth-child(even) { background: #f2f2f2; }
        .alert-success {
            background: #d4edda; color: #155724; border: 1px solid #c3e6cb;
            padding: 15px; margin: 15px 0; border-radius: 5px;
        }
        .alert-danger {
            background: #f8d7da; color: #721c24; border: 1px solid #f5c6cb;
            padding: 15px; margin: 15px 0; border-radius: 5px;
        }
        .form-row {
            margin: 10px 0;
        }
        .form-row label {
            display: inline-block;
            width: 150px;
            font-weight: bold;
        }
        .form-row input, .form-row select {
            padding: 8px;
            border: 1px solid #ddd;
            border-radius: 4px;
        }
        .player-card {
            background: #fff;
            border: 2px solid #4a7c59;
            border-radius: 10px;
            padding: 20px;
            margin: 15px 0;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }
        .player-stats {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 15px;
            margin-top: 15px;
        }
        .stat-box {
            background: #f8f9fa;
            padding: 15px;
            border-radius: 8px;
            text-align: center;
            border: 1px solid #e9ecef;
        }
        .stat-value {
            font-size: 24px;
            font-weight: bold;
            color: #2c5530;
        }
        .stat-label {
            font-size: 14px;
            color: #666;
            margin-top: 5px;
        }
        .score-history {
            max-height: 400px;
            overflow-y: auto;
            margin-top: 20px;
        }
        .score-row {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 10px;
            border-bottom: 1px solid #eee;
        }
        .score-row:nth-child(even) {
            background: #f8f9fa;
        }
        .best-score {
            color: #28a745;
            font-weight: bold;
        }
        .worst-score {
            color: #dc3545;
            font-weight: bold;
        }
        .tournament-badge {
            padding: 3px 8px;
            border-radius: 12px;
            font-size: 12px;
            font-weight: bold;
        }
        .badge-diablo {
            background: #ff6b6b;
            color: white;
        }
        .badge-gpr {
            background: #4ecdc4;
            color: white;
        }
        .course-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(350px, 1fr));
            gap: 20px;
            margin-top: 20px;
        }
        .course-card {
            background: white;
            border: 1px solid #ddd;
            border-radius: 8px;
            padding: 15px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }
        .course-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 10px;
        }
        .course-name {
            font-weight: bold;
            color: #2c5530;
            font-size: 16px;
        }
        .tee-info {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 8px;
            margin: 5px 0;
            background: #f8f9fa;
            border-radius: 5px;
            border-left: 4px solid #4a7c59;
        }
        .tee-color {
            font-weight: bold;
            padding: 2px 8px;
            border-radius: 10px;
            color: white;
            font-size: 12px;
        }
        .tee-blanc { background: #666; }
        .tee-bleu { background: #007bff; }
        .tee-vert { background: #28a745; }
        .tee-jaune { background: #ffc107; color: black; }
        .tee-noir { background: #000; }
        .add-course-form {
            background: #f8f9fa;
            padding: 20px;
            border-radius: 8px;
            border: 2px dashed #4a7c59;
            margin-top: 20px;
        }
        .tee-form-row {
            display: grid;
            grid-template-columns: 1fr 1fr 1fr 1fr auto;
            gap: 10px;
            align-items: center;
            margin: 10px 0;
        }
        .handicap-info {
            background: #e7f3ff;
            padding: 10px;
            border-radius: 5px;
            margin: 10px 0;
            font-size: 14px;
        }
		#calendar {
    		display: none;
    		width: 100% !important;
    		position: relative;
    		z-index: 1;
		}

		#calendar.active {
    		display: block !important;
    		position: relative;
    		z-index: 1;
		}

		.calendar-container {
    		background: white;
    		padding: 20px;
    		border-radius: 8px;
    		box-shadow: 0 2px 4px rgba(0,0,0,0.1);
		}

		.calendar-grid {
    		display: grid !important;
    		grid-template-columns: repeat(7, 1fr) !important;
    		gap: 1px !important;
    		background: #ddd !important;
    		border: 2px solid #333 !important;
    		padding: 1px !important;
    		margin: 20px 0 !important;
		}

		.calendar-header {
    		background: #2c5530 !important;
    		color: white !important;
    		padding: 15px 5px !important;
    		text-align: center !important;
    		font-weight: bold !important;
    		font-size: 14px !important;
		}

		.calendar-day {
    		background: white !important;
    		min-height: 100px !important;
    		padding: 8px !important;
    		cursor: pointer !important;
    		position: relative !important;
    		border: 1px solid #eee !important;
    		transition: all 0.2s ease !important;
		}

		.calendar-day:hover {
    		background: #f0f8ff !important;
    		border-color: #4a7c59 !important;
		}

		.calendar-day-number {
    		font-weight: bold !important;
    		font-size: 16px !important;
    		color: #333 !important;
    		margin-bottom: 5px !important;
		}

		.today {
    		background: #e8f5e8 !important;
    		border: 2px solid #4a7c59 !important;
		}

		.other-month {
    		background: #f9f9f9 !important;
		}

		.other-month .calendar-day-number {
   			color: #999 !important;
		}

		.calendar-event {
    		background: #4a7c59 !important;
    		color: white !important;
    		padding: 2px 5px !important;
    		margin: 2px 0 !important;
    		border-radius: 3px !important;
    		font-size: 11px !important;
    		cursor: pointer !important;
    		overflow: hidden !important;
    		text-overflow: ellipsis !important;
    		white-space: nowrap !important;
		}

		.calendar-event:hover {
    		background: #2c5530 !important;
		}

		/* Styles pour le formulaire d'ÃƒÂ©vÃƒÂ©nements */
		.tee-time-item {
    		display: flex;
    		align-items: center;
    		margin: 10px 0;
    		padding: 10px;
    		background: #f8f9fa;
    		border-radius: 5px;
		}

		.foursome-slot {
    		display: grid;
    		grid-template-columns: repeat(4, 1fr);
    		gap: 10px;
    		margin: 10px 0;
    		padding: 10px;
    		background: #e8f5e8;
    		border-radius: 5px;
		}

		.player-slot {
    		padding: 6px;
    		border: 1px solid #ddd;
    		border-radius: 4px;
    		width: 100%;
		}

		/* Popup dÃƒÂ©tails ÃƒÂ©vÃƒÂ©nement */
		.event-detail-overlay {
    		position: fixed;
    		top: 0;
    		left: 0;
    		width: 100%;
    		height: 100%;
    		background: rgba(0,0,0,0.5);
    		z-index: 999;
		}

		.event-detail-popup {
    		position: fixed;
    		top: 50%;
    		left: 50%;
    		transform: translate(-50%, -50%);
    		background: white;
    		padding: 30px;
    		border-radius: 10px;
    		box-shadow: 0 4px 20px rgba(0,0,0,0.3);
    		max-width: 600px;
    		width: 90%;
    		max-height: 80vh;
    		overflow-y: auto;
    		z-index: 1000;
		}

        .nav-controls {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 20px;
            padding: 15px;
            background: #f8f9fa;
            border-radius: 8px;
        }

        .month-nav {
            display: flex;
            align-items: center;
            gap: 20px;
        }

        .month-nav button {
            background: #4a7c59;
            color: white;
            border: none;
            padding: 8px 15px;
            border-radius: 5px;
            cursor: pointer;
            font-size: 16px;
        }

        .month-nav button:hover {
            background: #2c5530;
        }

        .month-title {
            font-size: 24px;
            font-weight: bold;
            color: #2c5530;
            min-width: 200px;
            text-align: center;
        }

        .view-buttons {
            display: flex;
            gap: 10px;
        }

        .btn {
            background: #4a7c59;
            color: white;
            border: none;
            padding: 8px 15px;
            border-radius: 5px;
            cursor: pointer;
        }

        .btn:hover {
            background: #2c5530;
        }

        .btn-secondary {
            background: #6c757d;
        }

        .btn-secondary:hover {
            background: #5a6268;
        }

        .card {
            background: white;
            padding: 20px;
            margin: 15px 0;
            border-radius: 8px;
            border: 1px solid #ddd;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }

        .today {
            background: #e8f5e8 !important;
            border: 2px solid #4a7c59;
        }

        .other-month {
            background: #f9f9f9;
            color: #999;
        }

		/* NOUVEAU MENU DÃƒâ€°ROULANT */
		.nav { 
    		text-align: center; 
    		margin-bottom: 30px; 
    		display: flex;
    		justify-content: center;
    		gap: 15px;
    		flex-wrap: wrap;
		}

		.dropdown {
    		position: relative;
    		display: inline-block;
		}

		.dropdown-btn {
    		color: white; 
    		border: none;
    		padding: 12px 20px; 
    		border-radius: 5px; 
    		cursor: pointer;
    		font-size: 14px;
    		transition: all 0.3s ease;
    		display: flex;
    		align-items: center;
    		gap: 8px;
		}

		.dropdown-btn:hover { 
    		transform: translateY(-2px);
    		box-shadow: 0 4px 8px rgba(0,0,0,0.2);
		}

		.dropdown-content {
    		display: none;
    		position: absolute;
    		background-color: #f9f9f9;
    		min-width: 200px;
    		box-shadow: 0px 8px 16px 0px rgba(0,0,0,0.2);
    		z-index: 1000;
    		border-radius: 8px;
    		top: 100%;
    		left: 0;
    		border: 1px solid #ddd;
		}

		.dropdown-content a {
    		color: #333;
    		padding: 12px 16px;
    		text-decoration: none;
    		display: block;
    		transition: background-color 0.3s;
    		border-radius: 4px;
    		margin: 2px;
		}

		.dropdown-content a:hover {
    		background-color: #f1f1f1;
    		background: linear-gradient(45deg, #e3f2fd, #f8f9fa);
		}

		.dropdown:hover .dropdown-content {
    		display: block;
		}

		/* Couleurs des boutons du menu */
		.nav-parties { background: #f39c12; }
		.nav-parties:hover { background: #e67e22; }

		.nav-competitions { background: #9b59b6; }
		.nav-competitions:hover { background: #8e44ad; }

		.nav-statistiques { background: #27ae60; }
		.nav-statistiques:hover { background: #229954; }

		.nav-gestion { background: #3498db; }
		.nav-gestion:hover { background: #2980b9; }

		.nav-save { background: #e74c3c; font-weight: bold; }
		.nav-save:hover { background: #c0392b; }

		/* STYLES POUR LES NOTIFICATIONS - SIMPLIFIÃƒâ€°S */
		.notification-stats-grid {
    		display: grid;
    		grid-template-columns: repeat(auto-fit, minmax(150px, 1fr));
    		gap: 15px;
    		margin: 20px 0;
		}

		.notification-stat-box {
		    background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
    		color: white;
    		padding: 20px;
    		border-radius: 12px;
    		text-align: center;
    		box-shadow: 0 4px 15px rgba(0,0,0,0.1);
    		transition: transform 0.3s ease;
		}

		.notification-stat-box:hover {
    		transform: translateY(-5px);
		}

		.notification-stat-value {
    		font-size: 28px;
    		font-weight: bold;
    		margin-bottom: 8px;
		}

		.notification-stat-label {
    		font-size: 14px;
    		opacity: 0.9;
		}

		/* ===== CONFIRMATION DIALOG ===== */
		.confirm-overlay {
			position: fixed;
			top: 0;
			left: 0;
			width: 100%;
			height: 100%;
			background: rgba(0, 0, 0, 0.6);
			display: flex;
			justify-content: center;
			align-items: center;
			z-index: 10000;
		}
		.confirm-dialog {
			background: white;
			border-radius: 16px;
			padding: 30px;
			max-width: 450px;
			width: 90%;
			box-shadow: 0 20px 60px rgba(0, 0, 0, 0.3);
		}
		.confirm-dialog h3 { margin: 0 0 15px 0; color: #2d5016; }
		.confirm-dialog p { margin: 0 0 25px 0; color: #555; line-height: 1.6; }
		.confirm-buttons { display: flex; gap: 15px; justify-content: flex-end; }
		.confirm-btn { padding: 12px 28px; border: none; border-radius: 8px; cursor: pointer; }
		.confirm-btn-cancel { background: #e0e0e0; color: #333; }
		.confirm-btn-confirm { background: linear-gradient(135deg, #2d5016, #4a7c23); color: white; }

		/* ===== TOAST NOTIFICATIONS ===== */
		.toast-container {
			position: fixed;
			bottom: 30px;
			right: 30px;
			z-index: 9999;
		}
		.toast {
			background: #333;
			color: white;
			padding: 16px 24px;
			border-radius: 10px;
			margin-top: 10px;
			box-shadow: 0 8px 25px rgba(0, 0, 0, 0.3);
		}
		.toast.success { background: linear-gradient(135deg, #28a745, #20c997); }
		.toast.error { background: linear-gradient(135deg, #dc3545, #c82333); }

		/* ===== INDICATEUR TEMPS REEL ===== */
		.live-indicator {
			display: inline-block;
			width: 10px;
			height: 10px;
			background: #28a745;
			border-radius: 50%;
			margin-right: 8px;
			animation: pulse 2s infinite;
		}
		@keyframes pulse {
			0%, 100% { opacity: 1; }
			50% { opacity: 0.5; }
		}

		/* ===== DIABLO 2026+ CHAMPIONS ===== */
		.champions-grid {
			display: grid;
			grid-template-columns: 1fr 1fr;
			gap: 20px;
			margin-top: 20px;
		}
		.champion-card {
			border: 3px solid #ffd700;
			border-radius: 16px;
			padding: 25px;
			text-align: center;
		}
		.champion-card.brut { border-color: #c0c0c0; background: #f8f8f8; }
		.champion-card.net { border-color: #ffd700; background: #fff9e6; }
		.champion-card.double { grid-column: 1 / -1; background: linear-gradient(135deg, #fff9e6, #ffe066); }
		.champion-title { font-size: 14px; color: #666; text-transform: uppercase; }
		.champion-name { font-size: 24px; font-weight: bold; color: #2d5016; margin: 10px 0; }
		.champion-score { font-size: 32px; font-weight: bold; color: #4a7c23; }
    </style>
</head>
<body>
    <!-- Toast Container -->
    <div id="toastContainer" class="toast-container"></div>
    <div class="container">
        <h1>Ã°Å¸ÂÅ’Ã¯Â¸Â GOLF DIABLO et GPR - Scores DÃƒÂ©taillÃƒÂ©s Ã°Å¸ÂÅ’Ã¯Â¸Â</h1>
        
        <div class="nav">
    		<!-- Menu Parties -->
    		<div class="dropdown">
        		<button class="dropdown-btn nav-parties">
            		Ã¢â€ºÂ³ Parties <span>Ã¢â€“Â¼</span>
        		</button>
        		<div class="dropdown-content">
            		<a href="#" onclick="showAddRound()">Ã¢Å¾â€¢ Nouvelle Partie</a>
            		<a href="#" onclick="showDetails()">ğŸ“‹ DÃ©tails par Partie</a>
            		<a href="#" onclick="showPlayerScores()">Ã°Å¸â€˜Â¥ Scores par Joueur</a>
            		<a href="#" onclick="showCalendar()">ğŸ“… Calendrier</a>
        		</div>
    		</div>

    		<!-- Menu CompÃƒÂ©titions -->
    		<div class="dropdown">
        		<button class="dropdown-btn nav-competitions">
            		Ã°Å¸Ââ€  CompÃƒÂ©titions <span>Ã¢â€“Â¼</span>
        		</button>
        		<div class="dropdown-content">
            		<a href="#" onclick="showDiablo()">Ã°Å¸Ââ€  Coupe Diablo</a>
            		<a href="#" onclick="showGPR()">Ã°Å¸Å½Â¯ Coupe GPR</a>
            		<a href="#" onclick="showProgress()">Ã°Å¸â€œÅ  Progression</a>
        		</div>
    		</div>

    		<!-- Menu Statistiques -->
    		<div class="dropdown">
        		<button class="dropdown-btn nav-statistiques">
            		Ã°Å¸â€œË† Statistiques <span>Ã¢â€“Â¼</span>
        		</button>
        		<div class="dropdown-content">
            		<a href="#" onclick="showOverview()">ğŸ“Š Vue d'ensemble</a>
            		<a href="#" onclick="showHandicapEvolution()">ğŸ“ˆ Ã‰volution Handicaps</a>
        		</div>
    		</div>

    		<!-- Menu Gestion -->
    		<div class="dropdown">
        		<button class="dropdown-btn nav-gestion">
            		Ã¢Å¡â„¢Ã¯Â¸Â Gestion <span>Ã¢â€“Â¼</span>
        		</button>
        		<div class="dropdown-content">
            		<a href="#" onclick="showCourses()">Ã°Å¸ÂÅ’Ã¯Â¸Â Terrains</a>
            		<a href="#" onclick="showPlayerManagement()">Ã°Å¸â€˜Â¥ Joueurs</a>
            		<a href="#" onclick="showNotifications()">Ã°Å¸â€œÂ§ Notifications</a>
        		</div>
    		</div>

		</div>

        <!-- Section Vue d'ensemble -->
        <div id="overview" class="section active">
            <div class="card">
                <h2>Ã°Å¸â€œÅ  Statistiques GÃƒÂ©nÃƒÂ©rales</h2>
                <div id="overviewStats"></div>
            </div>
        </div>

        <!-- Section Scores par Joueur -->
        <div id="playerScores" class="section">
            <div class="card">
                <h2>Ã°Å¸â€˜Â¥ SÃƒÂ©lectionner un Joueur</h2>
                <select id="playerSelect" style="width: 300px; padding: 10px;" onchange="showPlayerDetail()">
                    <option value="">-- Choisir un joueur --</option>
                </select>
            </div>
            <div id="playerDetail"></div>
        </div>

        <!-- Section Terrains -->
        <div id="courses" class="section">
            <div class="card">
                <h2>Ã°Å¸ÂÅ’Ã¯Â¸Â Gestion des Terrains</h2>
                <p>Base de donnÃƒÂ©es complÃƒÂ¨te avec ratings et slopes pour le calcul des handicaps</p>
                <div class="handicap-info">
                    <strong>Ã¢â€Â¹Ã¯Â¸Â Calcul des Handicaps:</strong> Les handicaps de parcours sont calculÃƒÂ©s avec la formule officielle complÃƒÂ¨te : 
                    <em>(Handicap Index Ãƒâ€” Slope Rating) ÃƒÂ· 113 + (Course Rating - Par)</em>. 
                    <br>Rating = difficultÃƒÂ© pour un scratch, Slope = difficultÃƒÂ© relative, Par = nombre de coups de rÃƒÂ©fÃƒÂ©rence.
                </div>
                <button class="btn" onclick="toggleAddCourseForm()">Ã¢Å¾â€¢ Ajouter un Terrain</button>
                <button class="btn-secondary" onclick="exportCourses()">Ã°Å¸â€œÂ Exporter Terrains</button>
            </div>
            
            <div id="addCourseForm" class="add-course-form" style="display: none;">
                <h3>Ã¢Å¾â€¢ Ajouter un Nouveau Terrain</h3>
                <div class="form-row">
                    <label>Nom du terrain:</label>
                    <input type="text" id="newCourseName" placeholder="Ex: Club de Golf Exemple" style="width: 300px;">
                </div>
                
                <h4>DÃƒÂ©parts disponibles:</h4>
                <div id="teeInputs">
                    <div class="tee-form-row">
                        <select>
                            <option value="blanc">Blanc</option>
                            <option value="bleu">Bleu</option>
                            <option value="vert">Vert</option>
                            <option value="jaune">Jaune</option>
                            <option value="noir">Noir</option>
                        </select>
                        <input type="number" placeholder="Rating (ex: 69.5)" step="0.1" min="60" max="80">
                        <input type="number" placeholder="Slope (ex: 123)" min="85" max="155">
                        <button type="button" class="btn-danger" onclick="removeTeeInput(this)">Ã¢ÂÅ’</button>
                    </div>
                </div>
                
                <button class="btn-secondary" onclick="addTeeInput()">Ã¢Å¾â€¢ Ajouter un DÃƒÂ©part</button>
                <br><br>
                <button class="btn" onclick="saveCourse()">Ã°Å¸â€™Â¾ Sauvegarder le Terrain</button>
                <button class="btn-secondary" onclick="cancelAddCourse()">Ã¢ÂÅ’ Annuler</button>
            </div>
            
            <div id="coursesList"></div>
        </div>

        <!-- Section Diablo -->
        <div id="diablo" class="section">
            <h2>Ã°Å¸Ââ€  Coupe Diablo </h2>
            <div class="card">
                <label><strong>SÃƒÂ©lectionner l'annÃƒÂ©e:</strong></label>
                <select id="diabloYearSelect" style="width: 150px; padding: 8px; margin: 0 10px;" onchange="loadDiablo()">
                    <option value="">-- Toutes les annÃƒÂ©es --</option>
                </select>
                <span id="diabloStatus" style="margin-left: 20px; padding: 5px 10px; border-radius: 15px;"></span>
            </div>
            <div id="diabloContent"></div>
        </div>

        <!-- Section GPR -->
        <div id="gpr" class="section">
            <h2>Ã°Å¸Å½Â¯ Coupe GPR (Mai ÃƒÂ  Juillet)</h2>
            <div class="card">
                <label><strong>SÃƒÂ©lectionner l'annÃƒÂ©e:</strong></label>
                <select id="gprYearSelect" style="width: 150px; padding: 8px; margin: 0 10px;" onchange="loadGPR()">
                    <option value="">-- Toutes les annÃƒÂ©es --</option>
                </select>
                <span id="gprStatus" style="margin-left: 20px; padding: 5px 10px; border-radius: 15px;"></span>
            </div>
            <div id="gprContent"></div>
        </div>

        <!-- Section Progression -->
        <div id="progress" class="section">
            <h2>Ã°Å¸â€œË† Progression des Coupes En Cours</h2>
            <div id="progressContent"></div>
        </div>

        <!-- Section DÃƒÂ©tails -->
        <div id="details" class="section">
            <h2>Ã°Å¸â€œÅ  DÃƒÂ©tails par Partie</h2>
            <div class="card">
                <select id="roundSelect" style="width: 100%; padding: 8px;" onchange="showRoundDetail()">
                    <button class="btn" onclick="generateTestRound()" style="margin-left: 10px;">Ã°Å¸Å½Â² GÃƒÂ©nÃƒÂ©rer Partie Test</button>
					<option value="">-- SÃƒÂ©lectionner une partie --</option>
                </select>
            </div>
            <div id="detailsContent"></div>
        </div>
	
	<!-- Section Ãƒâ€°volution Handicaps -->
	<div id="handicapEvolution" class="section">
    	    <div class="card">
        	<h2>Ã°Å¸â€œË† Ãƒâ€°volution des Handicaps</h2>
        	<p>Suivez la progression des handicaps de chaque joueur au fil des parties</p>
        
        	<div style="margin: 20px 0;">
            	    <label><strong>SÃƒÂ©lectionner les joueurs ÃƒÂ  comparer:</strong></label>
            	    <div id="playerCheckboxes" style="display: grid; grid-template-columns: repeat(auto-fit, minmax(200px, 1fr)); gap: 10px; margin: 15px 0;"></div>
            	    <button class="btn" onclick="updateHandicapChart()">Ã°Å¸â€â€ Mettre ÃƒÂ  jour le graphique</button>
            	    <button class="btn-secondary" onclick="selectAllPlayers()">Ã¢Å“â€¦ Tous</button>
            	    <button class="btn-secondary" onclick="clearAllPlayers()">Ã¢ÂÅ’ Aucun</button>
            	    <button class="btn-secondary" onclick="exportHandicapData()">Ã°Å¸â€œÅ  Exporter DonnÃƒÂ©es</button>
        	</div>
        
        	<div style="background: #f8f9fa; padding: 15px; border-radius: 8px; margin: 15px 0;">
            	    <strong>LÃƒÂ©gende:</strong>
            	    <span style="color: #28a745;">Ã°Å¸Å¸Â¢ AmÃƒÂ©lioration</span> |
            	    <span style="color: #dc3545;">Ã°Å¸â€Â´ DÃƒÂ©gradation</span> |
            	    <span style="color: #6c757d;">Ã¢Å¡Âª Stable</span>
        	</div>
    	    </div>
    
    	    <div id="handicapChart" class="card">
        	<canvas id="handicapCanvas" width="1000" height="500" style="max-width: 100%; border: 1px solid #ddd; border-radius: 8px;"></canvas>
    	    </div>
    
    	    <div id="handicapStats" class="card"></div>
	</div>

	<!-- Section Gestion des Joueurs -->
	<div id="playerManagement" class="section">
    	    <div class="card">
        	<h2>Ã°Å¸â€˜Â¥ Gestion des Joueurs</h2>
        	<p>Ajouter, modifier et gÃƒÂ©rer les informations des joueurs</p>
        
        	<div style="margin: 20px 0;">
            	    <button class="btn" onclick="showAddPlayerForm()">Ã¢Å¾â€¢ Ajouter un Joueur</button>
            	    <button class="btn-secondary" onclick="exportPlayersData()">Ã°Å¸â€œÂ Exporter Liste</button>
            	    <button class="btn-secondary" onclick="importPlayersData()">Ã°Å¸â€œÂ¥ Importer Liste</button>
            	    <input type="file" id="importFile" accept=".json,.csv" style="display: none;" onchange="handleFileImport(event)">
        	</div>
        
        	<div id="addPlayerForm" class="add-course-form" style="display: none;">
            	    <h3>Ã¢Å¾â€¢ Ajouter un Nouveau Joueur</h3>
            	    <div class="form-row">
                	<label>PrÃƒÂ©nom:</label>
                	<input type="text" id="newPlayerFirstName" placeholder="Ex: Jean" style="width: 200px;">
            	    </div>
            	    <div class="form-row">
                	<label>Nom:</label>
                	<input type="text" id="newPlayerLastName" placeholder="Ex: Dupont" style="width: 200px;">
            	    </div>
            	    <div class="form-row">
                	<label>TÃƒÂ©lÃƒÂ©phone:</label>
                	<input type="tel" id="newPlayerPhone" placeholder="Ex: 514-555-1234" style="width: 200px;">
            	    </div>
            	    <div class="form-row">
                	<label>Courriel:</label>
                	<input type="email" id="newPlayerEmail" placeholder="Ex: jean.dupont@example.com" style="width: 300px;">
            	    </div>
            	    <div class="form-row">
                	<label>Handicap Initial:</label>
                	<input type="number" id="newPlayerHandicap" placeholder="Ex: 15.5" step="0.1" min="0" max="36.4" style="width: 100px;">
            	    </div>
            	    <div class="form-row">
                	<label>Date d'adhÃƒÂ©sion:</label>
                	<input type="date" id="newPlayerDateJoined" style="width: 200px;">
            	    </div>
            	    <br>
            	    <button class="btn" onclick="saveNewPlayer()">Ã°Å¸â€™Â¾ Sauvegarder</button>
            	    <button class="btn-secondary" onclick="cancelAddPlayer()">Ã¢ÂÅ’ Annuler</button>
        	</div>
    	    </div>
    
    	    <div id="playersGrid" class="course-grid"></div>
	</div>

	<!-- Section Ajouter une Partie -->
	<div id="addRound" class="section">
    	<div class="card">
        	<h2>Ã¢Å¾â€¢ Ajouter une Nouvelle Partie</h2>
        	<p>Enregistrer les scores d'une nouvelle partie de golf</p>
        
        	<!-- Informations de base de la partie -->
        	<div class="card" style="background: #f8f9fa;">
            	<h3>Ã°Å¸â€œâ€¦ Informations de la Partie</h3>
            
            	<div class="form-row">
                	<label>Date de la partie:</label>
                	<input type="date" id="newRoundDate" style="width: 200px;">
            	</div>
            
            	<div class="form-row">
                	<label>Terrain:</label>
                	<select id="newRoundCourse" style="width: 300px;" onchange="updateAvailableTees()">
                	    <option value="">-- SÃƒÂ©lectionner un terrain --</option>
                	</select>
            	</div>
            
            	<div class="form-row">
                	<label>DÃƒÂ©part par dÃƒÂ©faut:</label>
                	<select id="newRoundDefaultTee" style="width: 150px;">
                    	<option value="">-- Choisir --</option>
                	</select>
                	<small style="margin-left: 10px; color: #666;">Les joueurs peuvent avoir des dÃƒÂ©parts individuels</small>
            	</div>
            
            	<div class="form-row">
                	<label>Type de partie:</label>
                	<select id="newRoundType" style="width: 200px;" onchange="updateGPROptions()">
                    	<option value="gpr">Ã°Å¸Å½Â¯ GPR (Mai-Juillet)</option>
                    	<option value="diablo">Ã°Å¸Ââ€  Diablo (Septembre)</option>
                    	<option value="amicale">Ã¢â€ºÂ³ Partie Amicale</option>
                	</select>
            	</div>

            	<!-- Nouvelles options GPR -->
            	<div id="gprOptions" style="display: block; margin-top: 15px; padding: 15px; background: #e7f3ff; border-radius: 8px;">
                	<h4 style="margin-top: 0; color: #2c5530;">Ã¢Å¡â„¢Ã¯Â¸Â Configuration GPR</h4>
                
                	<div class="form-row">
                    	<label>Phase GPR:</label>
                    	<select id="gprPhase" style="width: 200px;" onchange="updateFinaleOptions()">
                        	<option value="exhibition">Ã°Å¸â€œÅ  Partie d'Exhibition</option>
                        	<option value="finale">Ã°Å¸Ââ€  Partie de Finale</option>
                    	</select>
                	</div>
                
                	<div id="finaleOptions" style="display: none; margin-top: 10px;">
                    	<div class="form-row">
                        	<label>Format finale:</label>
                        	<select id="finaleFormat" style="width: 200px;">
                            	<option value="2days">Ã°Å¸â€œâ€¦ Finale 2 jours (points rÃƒÂ©partis)</option>
                            	<option value="1day">Ã¢Å¡Â¡ Finale 1 jour (tous les points)</option>
                        	</select>
                    	</div>
                	</div>
                
                	<div style="margin-top: 15px; padding: 10px; background: #fff3cd; border-radius: 5px;">
                    	<strong>Ã¢â€Â¹Ã¯Â¸Â Rappel :</strong> Si votre handicap est de 12 et moins, vous partez des bleus
                	</div>
            	</div>
        	</div>

        	<!-- SÃƒÂ©lection des joueurs et scores -->
        	<div class="card">
            	<h3>Ã°Å¸â€˜Â¥ Joueurs et Scores</h3>
            	<p>SÃƒÂ©lectionnez les joueurs prÃƒÂ©sents et saisissez leurs scores</p>
            
            	<div style="margin: 15px 0;">
                	<button class="btn-secondary" onclick="selectAllPlayersForRound()">Ã¢Å“â€¦ Tous les joueurs</button>
                	<button class="btn-secondary" onclick="clearAllPlayersForRound()">Ã¢ÂÅ’ Aucun joueur</button>
                	<button class="btn-secondary" onclick="selectFrequentPlayers()">Ã¢Â­Â Joueurs frÃƒÂ©quents</button>
            	</div>
            
            	<div id="playersScoreGrid" style="display: grid; grid-template-columns: repeat(auto-fit, minmax(350px, 1fr)); gap: 15px; margin-top: 20px;"></div>
        	</div>
        
        	<!-- Boutons d'action -->
        	<div class="card" style="text-align: center;">
            	<button class="btn" onclick="saveNewRound()">Ã°Å¸â€™Â¾ Enregistrer la Partie</button>
            	<button class="btn-secondary" onclick="previewNewRound()">Ã°Å¸â€˜ÂÃ¯Â¸Â AperÃƒÂ§u</button>
            	<button class="btn-secondary" onclick="resetNewRoundForm()">Ã°Å¸â€â€ RÃƒÂ©initialiser</button>
        	</div>
        
        	<!-- AperÃƒÂ§u de la partie -->
        	<div id="newRoundPreview" class="card" style="display: none;">
            	<h3>Ã°Å¸â€˜ÂÃ¯Â¸Â AperÃƒÂ§u de la Partie</h3>
            	<div id="previewContent"></div>
        	</div>
    	</div>
	</div>

	<!-- Section Calendrier -->
	<div id="calendar" class="section">
    	<div class="card">
        	<h2>Ã°Å¸â€œâ€¦ Calendrier des Parties</h2>
        	<p>Planifiez vos parties de golf et consultez les prochains ÃƒÂ©vÃƒÂ©nements</p>
        
        	<!-- Navigation et contrÃƒÂ´les -->
        	<div class="nav-controls">
            	<div class="view-buttons">
                	<button class="btn" onclick="showAddEvent()">Ã¢Å¾â€¢ Planifier une Partie</button>
                	<button class="btn-secondary" onclick="showListView()">Ã°Å¸â€œâ€¹ Vue Liste</button>
                	<button class="btn-secondary" onclick="showMonthView()">Ã°Å¸â€œâ€¦ Vue Calendrier</button>
            	</div>
            
            	<!-- Navigation mensuelle -->
            	<div class="month-nav">
                	<button onclick="changeMonth(-1)">Ã¢â€”â‚¬ PrÃƒÂ©cÃƒÂ©dent</button>
                	<div id="monthTitle" class="month-title">DÃƒÂ©cembre 2024</div>
                	<button onclick="changeMonth(1)">Suivant Ã¢â€“Â¶</button>
            	</div>
        	</div>

        	<!-- Formulaire d'ajout d'ÃƒÂ©vÃƒÂ©nement -->
        	<div id="addEventForm" class="add-course-form" style="display: none;">
            	<h3>Ã¢Å¾â€¢ Planifier une Nouvelle Partie</h3>
            
            	<div style="display: grid; grid-template-columns: 1fr 1fr; gap: 20px;">
                	<div>
                    	<div class="form-row">
                        	<label>Date de la partie:</label>
                        	<input type="date" id="eventDate" style="width: 100%; padding: 8px;">
                    	</div>
                    
                    	<div class="form-row">
                        	<label>Terrain:</label>
                        	<select id="eventCourse" style="width: 100%; padding: 8px;">
                        	    <option value="">-- SÃƒÂ©lectionner un terrain --</option>
                        	</select>
                    	</div>
                    
                    	<div class="form-row">
                        	<label>Type de partie:</label>
                        	<select id="eventType" style="width: 100%; padding: 8px;">
                            	<option value="amicale">Ã¢â€ºÂ³ Partie Amicale</option>
                            	<option value="gpr">Ã°Å¸Å½Â¯ Coupe GPR</option>
                            	<option value="diablo">Ã°Å¸Ââ€  Coupe Diablo</option>
                            	<option value="felton">Ã°Å¸Ââ€  Coupe FelTon</option>
                            	<option value="doubled">Ã°Å¸Å½Â¯ Double D's Cup</option>
                        	</select>
                    	</div>
                    
                    	<div class="form-row">
                        	<label>Organisateur:</label>
                        	<select id="eventOrganizer" style="width: 100%; padding: 8px;">
                            	<option value="">-- SÃƒÂ©lectionner --</option>
                        	</select>
                    	</div>
                	</div>
                
                	<div>
                    	<div class="form-row">
                        	<label>Heures de dÃƒÂ©part:</label>
                        	<div id="teeTimesList" style="max-height: 200px; overflow-y: auto; border: 1px solid #ddd; padding: 10px; border-radius: 5px; background: white;">
                            	<!-- Les heures de dÃƒÂ©part seront ajoutÃƒÂ©es ici -->
                        	</div>
                        	<button class="btn-secondary" onclick="addTeeTime()" style="margin-top: 10px;">Ã¢Å¾â€¢ Ajouter une heure</button>
                    	</div>
                    
                    	<div class="form-row">
                    	    <label>Commentaires/Notes:</label>
                        	<textarea id="eventComments" rows="4" style="width: 100%; padding: 8px;" 
                            	placeholder="Ex: Apportez vos balles, terrain difficile, souper aprÃƒÂ¨s la partie..."></textarea>
                    	</div>
                	</div>
            	</div>
            
            	<div style="text-align: center; margin-top: 20px;">
                	<button class="btn" onclick="saveEvent()">Ã°Å¸â€™Â¾ Enregistrer</button>
                	<button class="btn-secondary" onclick="cancelAddEvent()">Ã¢ÂÅ’ Annuler</button>
                	<button class="btn" onclick="saveEvent()" style="background: #e74c3c;">Ã°Å¸â€œÂ¢ Enregistrer et Notifier</button>
            	</div>
        	</div>
        
        	<!-- Vue du calendrier -->
        	<div id="calendarView" class="card">
            	<!-- Vide - sera rempli par JavaScript -->
        	</div>
        
        	<!-- Vue liste -->
        	<div id="listView" class="card" style="display: none;">
            	<div style="text-align: center; padding: 50px; color: #666;">
                	<h3>Ã°Å¸â€œâ€¹ Vue Liste</h3>
                	<p>La liste des ÃƒÂ©vÃƒÂ©nements va s'afficher ici</p>
            	</div>
        	</div>
    	</div>
	</div>

	<!-- Section Notifications -->
	<div id="notifications" class="section">
    	<div class="card">
        	<h2>Ã°Å¸â€œÂ§ Notifications Email</h2>
        	<p>SystÃƒÂ¨me de notifications automatiques pour les joueurs</p>
        
        	<!-- Statistiques d'envoi uniquement -->
        	<div class="notification-stats-grid">
            	<div class="notification-stat-box">
                	<div class="notification-stat-value" id="totalEmailsSent">0</div>
                	<div class="notification-stat-label">Emails EnvoyÃƒÂ©s</div>
            	</div>
            	<div class="notification-stat-box">
            	    <div class="notification-stat-value" id="totalSuccessful">0</div>
                	<div class="notification-stat-label">SuccÃƒÂ¨s</div>
            	</div>
            	<div class="notification-stat-box">
                	<div class="notification-stat-value" id="totalErrors">0</div>
                	<div class="notification-stat-label">Erreurs</div>
            	</div>
            	<div class="notification-stat-box">
                	<div class="notification-stat-value" id="lastSent">Jamais</div>
                	<div class="notification-stat-label">Dernier Envoi</div>
            	</div>
        	</div>

        	<div style="margin-top: 20px; padding: 15px; background: #e3f2fd; border-radius: 8px;">
        	    <h4 style="margin: 0 0 10px 0; color: #1976d2;">Ã¢â€Â¹Ã¯Â¸Â Comment ÃƒÂ§a fonctionne</h4>
            	<ul style="margin: 0; padding-left: 20px;">
                	<li>Ã°Å¸â€œÂ§ Les notifications sont envoyÃƒÂ©es automatiquement lors de la planification de parties</li>
                	<li>Ã°Å¸â€œÅ  Les rÃƒÂ©sultats sont notifiÃƒÂ©s aprÃƒÂ¨s l'enregistrement des scores</li>
                	<li>Ã¢Å¡Â Ã¯Â¸Â Seuls les joueurs avec une adresse email configurÃƒÂ©e recevront les notifications</li>
                	<li>Ã°Å¸â€Â§ Configurez les emails des joueurs dans la section "Gestion > Joueurs"</li>
            	</ul>
        	</div>

        	<div style="text-align: center; margin-top: 20px;">
            	<button class="btn" onclick="testEmailjsService()">Ã°Å¸Â§Âª Tester le Service Email</button>
            	<button class="btn-secondary" onclick="showPlayerManagement()">Ã°Å¸â€˜Â¥ Configurer Emails Joueurs</button>
        	</div>
    	</div>
	</div>

    <script>
		// Configuration Firebase
		const firebaseConfig = {
    		apiKey: "AIzaSyCHh6Fb-m18O-_1Ei6sTEdfnJMyNrSl590",
    		authDomain: "golf-scores-app-bba13.firebaseapp.com",
    		databaseURL: "https://golf-scores-app-bba13-default-rtdb.firebaseio.com",
    		projectId: "golf-scores-app-bba13",
    		storageBucket: "golf-scores-app-bba13.firebasestorage.app",
    		messagingSenderId: "170312505084",
    		appId: "1:170312505084:web:074ae5e6d9d74c70efa979"
		};

		// Initialiser Firebase
		firebase.initializeApp(firebaseConfig);
		const database = firebase.database();

		// Ãƒâ€°tat de chargement
		var isDataLoaded = false;
		var loadingElement = null;

		// Fonction pour afficher le statut de chargement

		// =====================================================
		// FONCTIONS TOAST & CONFIRMATION
		// =====================================================

		function showToast(message, isError) {
			var container = document.getElementById('toastContainer');
			if (!container) {
				container = document.createElement('div');
				container.id = 'toastContainer';
				container.className = 'toast-container';
				document.body.appendChild(container);
			}
			var toast = document.createElement('div');
			toast.className = 'toast ' + (isError ? 'error' : 'success');
			toast.textContent = message;
			container.appendChild(toast);
			setTimeout(function() {
				if (toast.parentNode) toast.parentNode.removeChild(toast);
			}, 4000);
		}

		function showConfirmDialog(title, message, onConfirm, onCancel) {
			var overlay = document.createElement('div');
			overlay.className = 'confirm-overlay';
			overlay.innerHTML = 
				'<div class="confirm-dialog">' +
					'<h3>' + title + '</h3>' +
					'<p>' + message + '</p>' +
					'<div class="confirm-buttons">' +
						'<button class="confirm-btn confirm-btn-cancel">Annuler</button>' +
						'<button class="confirm-btn confirm-btn-confirm">Confirmer</button>' +
					'</div>' +
				'</div>';
			document.body.appendChild(overlay);
			overlay.querySelector('.confirm-btn-cancel').onclick = function() {
				document.body.removeChild(overlay);
				if (onCancel) onCancel();
			};
			overlay.querySelector('.confirm-btn-confirm').onclick = function() {
				document.body.removeChild(overlay);
				if (onConfirm) onConfirm();
			};
			overlay.onclick = function(e) {
				if (e.target === overlay) {
					document.body.removeChild(overlay);
					if (onCancel) onCancel();
				}
			};
		}

		function saveWithConfirmation(type, data, recipients) {
			return new Promise(function(resolve) {
				var title, message;
				switch(type) {
					case 'round':
						var playerCount = data.scores ? data.scores.length : 0;
						title = 'ğŸ’¾ Enregistrer la partie?';
						message = 'Date: ' + data.date + '<br>Terrain: ' + data.course + '<br>Joueurs: ' + playerCount;
						if (recipients && recipients.length > 0) {
							message += '<br><br>ğŸ“§ ' + recipients.length + ' notification(s) sera(ont) envoyÃ©e(s).';
						}
						break;
					case 'player':
						title = 'ğŸ‘¤ Ajouter ce joueur?';
						message = 'Nom: ' + data.name;
						if (data.email) message += '<br>ğŸ“§ Un email de bienvenue sera envoyÃ©.';
						break;
					case 'event':
						title = 'ğŸ“… CrÃ©er cet Ã©vÃ©nement?';
						message = 'Date: ' + data.date + '<br>Terrain: ' + data.course;
						if (recipients && recipients.length > 0) {
							message += '<br><br>ğŸ“§ ' + recipients.length + ' joueur(s) sera(ont) notifiÃ©(s).';
						}
						break;
					default:
						title = 'ğŸ’¾ Confirmer?';
						message = 'Voulez-vous continuer?';
				}
				showConfirmDialog(title, message, function() { resolve(true); }, function() { resolve(false); });
			});
		}

		function showLoading(message) {
    		if (!loadingElement) {
        		loadingElement = document.createElement('div');
        		loadingElement.style.cssText = 'position: fixed; top: 50%; left: 50%; transform: translate(-50%, -50%); background: rgba(0,0,0,0.8); color: white; padding: 20px; border-radius: 10px; z-index: 9999;';
        		document.body.appendChild(loadingElement);
    		}
    		loadingElement.innerHTML = '<div style="text-align: center;"><div style="margin-bottom: 10px;">Ã°Å¸â€â€</div>' + message + '</div>';
    		loadingElement.style.display = 'block';
		}

		function hideLoading() {
    		if (loadingElement) {
        		loadingElement.style.display = 'none';
    		}
		}

        // Base de donnÃƒÂ©es des terrains avec ratings, slopes et pars
        var coursesDatabase = {
            "Parcours de l'ÃƒÂ®le": [
                {tee: "blanc", rating: 68.6, slope: 122, par: 70},
                {tee: "bleu", rating: 70.9, slope: 127, par: 70}
            ],
            "Parcours de l'Irlande": [
                {tee: "blanc", rating: 69.4, slope: 126, par: 71},
                {tee: "bleu", rating: 72.2, slope: 131, par: 71}
            ],
            "Parcours Atlantide": [
                {tee: "blanc", rating: 68.6, slope: 126, par: 72},
                {tee: "bleu", rating: 70.2, slope: 132, par: 72}
            ],
            "Parcours Don Quichotte": [
                {tee: "blanc", rating: 65.9, slope: 113, par: 71},
                {tee: "bleu", rating: 68.4, slope: 117, par: 71}
            ],
            "Triangle D'Or": [
                {tee: "blanc", rating: 69.8, slope: 123, par: 72},
                {tee: "bleu", rating: 70.8, slope: 127, par: 72}
            ],
            "Hemmingford Parcours FrontiÃƒÂ¨re": [
                {tee: "blanc", rating: 70.3, slope: 123, par: 71},
                {tee: "bleu", rating: 71.1, slope: 125, par: 71}
            ],
            "VallÃƒÂ©e des Forts": [
                {tee: "blanc", rating: 70.2, slope: 127, par: 72},
                {tee: "bleu", rating: 71.9, slope: 135, par: 72}
            ],
            "St-Zotique": [
                {tee: "blanc", rating: 68, slope: 114, par: 72},
                {tee: "bleu", rating: 70.1, slope: 118, par: 72}
            ],
            "Parcours Le PrÃƒÂ©sidentiel": [
                {tee: "blanc", rating: 69.7, slope: 118, par: 72},
                {tee: "bleu", rating: 71.5, slope: 123, par: 72}
            ],
            "Parcours Le Doral": [
                {tee: "blanc", rating: 70, slope: 124, par: 72},
                {tee: "bleu", rating: 71.7, slope: 128, par: 72}
            ],
            "Parcours Woodlands": [
                {tee: "blanc", rating: 68.7, slope: 116, par: 72},
                {tee: "bleu", rating: 70.1, slope: 119, par: 72}
            ],
            "Parcours Bellevue": [
                {tee: "blanc", rating: 69, slope: 115, par: 72},
                {tee: "bleu", rating: 70.3, slope: 118, par: 72}
            ],
            "RiviÃƒÂ¨re-Rouge": [
                {tee: "blanc", rating: 68.8, slope: 123, par: 71},
                {tee: "bleu", rating: 70.5, slope: 124, par: 71}
            ],
            "Les LÃƒÂ©gendes": [
                {tee: "blanc", rating: 70.8, slope: 118, par: 72},
                {tee: "bleu", rating: 72.3, slope: 126, par: 72}
            ],
            "La Seigneurie": [
                {tee: "blanc", rating: 68.5, slope: 123, par: 70},
                {tee: "bleu", rating: 69.5, slope: 126, par: 70}
            ],
            "Napierville": [
                {tee: "blanc", rating: 68.2, slope: 125, par: 72},
                {tee: "bleu", rating: 70.7, slope: 129, par: 72}
            ],
            "St-Polycarpe": [
                {tee: "blanc", rating: 66.8, slope: 118, par: 72},
                {tee: "bleu", rating: 71, slope: 125, par: 72}
            ],
            "Rive-Sud": [
                {tee: "blanc", rating: 71.2, slope: 124, par: 72},
                {tee: "bleu", rating: 72.4, slope: 127, par: 72}
            ],
            "RiviÃƒÂ¨re-Beaudette": [
                {tee: "blanc", rating: 69.2, slope: 117, par: 72},
                {tee: "bleu", rating: 70.6, slope: 120, par: 72}
            ],
            "Vaudreuil": [
                {tee: "blanc", rating: 66.5, slope: 108, par: 70},
                {tee: "bleu", rating: 68.2, slope: 112, par: 70}
            ],
            "Brocart": [
                {tee: "blanc", rating: 68, slope: 115, par: 72},
                {tee: "vert", rating: 69.4, slope: 118, par: 72},
                {tee: "jaune", rating: 69.4, slope: 118, par: 72}
            ],
            "Faon": [
                {tee: "vert", rating: 70.7, slope: 122, par: 71},
                {tee: "jaune", rating: 69.2, slope: 123, par: 71}
            ],
            "Beloeil": [
                {tee: "blanc", rating: 67.2, slope: 123, par: 71},
                {tee: "bleu", rating: 70, slope: 132, par: 71}
            ],
            "GolfdesÃƒÅ½les": [
                {tee: "blanc", rating: 66.5, slope: 110, par: 70},
                {tee: "bleu", rating: 68.5, slope: 115, par: 70}
            ],
            "St-CÃƒÂ©saire": [
                {tee: "blanc", rating: 70, slope: 122, par: 72},
                {tee: "bleu", rating: 70, slope: 122, par: 72}
            ],
            "Golf Cowansville": [
                {tee: "blanc", rating: 69.6, slope: 118, par: 72},
                {tee: "bleu", rating: 71, slope: 123, par: 72}
            ],
            "ChÃƒÂ¢teau Bromont": [
                {tee: "blanc", rating: 69.3, slope: 123, par: 72},
                {tee: "bleu", rating: 69.8, slope: 116, par: 72}
            ],
            "Golf Coaticook": [
                {tee: "blanc", rating: 66.4, slope: 114, par: 71},
                {tee: "bleu", rating: 68, slope: 119, par: 71}
            ],
            "Golf Farnham": [
                {tee: "blanc", rating: 67.8, slope: 121, par: 71},
                {tee: "bleu", rating: 69.4, slope: 124, par: 71}
            ],
            "Milby": [
                {tee: "blanc", rating: 69.5, slope: 123, par: 73},
                {tee: "bleu", rating: 71.1, slope: 131, par: 73}
            ],
            "Manoir des Sables": [
                {tee: "blanc", rating: 69, slope: 118, par: 71},
                {tee: "bleu", rating: 69, slope: 123, par: 71}
            ],
            "Mont Orford": [
                {tee: "blanc", rating: 69, slope: 118, par: 72},
                {tee: "bleu", rating: 69, slope: 126, par: 72}
            ],
            "Royal Bromont": [
                {tee: "blanc", rating: 67, slope: 114, par: 72},
                {tee: "bleu", rating: 69.3, slope: 120, par: 72}
            ],
            "Parcours du Vieux Village": [
                {tee: "blanc", rating: 68.2, slope: 114, par: 72},
                {tee: "bleu", rating: 70.3, slope: 124, par: 72}
            ],
            "Royal Laurentien": [
                {tee: "blanc", rating: 66.2, slope: 115, par: 71},
                {tee: "bleu", rating: 68.6, slope: 121, par: 71}
            ],
            "Le Diable": [
                {tee: "blanc", rating: 69.9, slope: 126, par: 70},
                {tee: "bleu", rating: 72, slope: 131, par: 70}
            ],
            "Le GÃƒÂ©ant": [
                {tee: "vert", rating: 68, slope: 123, par: 72},
                {tee: "noir", rating: 70.4, slope: 125, par: 72}
            ],
            "Arundel": [
                {tee: "blanc", rating: 69.7, slope: 126, par: 72},
                {tee: "bleu", rating: 70.7, slope: 128, par: 72}
            ],
            "La Belle": [
                {tee: "blanc", rating: 68, slope: 121, par: 73},
                {tee: "bleu", rating: 69, slope: 124, par: 73}
            ],
            "Le MaÃƒÂ®tre": [
                {tee: "blanc", rating: 68.7, slope: 121, par: 72},
                {tee: "bleu", rating: 70.2, slope: 125, par: 72}
            ],
            "La BÃƒÂªte": [
                {tee: "blanc", rating: 68.7, slope: 124, par: 72},
                {tee: "bleu", rating: 71.4, slope: 128, par: 72}
            ],
            "Lorraine": [
                {tee: "blanc", rating: 69.5, slope: 123, par: 72},
                {tee: "bleu", rating: 70.4, slope: 124, par: 72}
            ],
            "St-Jean limitÃƒÂ©": [
                {tee: "blanc", rating: 69.3, slope: 120, par: 72},
                {tee: "bleu", rating: 71.4, slope: 123, par: 72}
            ]
        };

        // 1. MODIFIER LE TABLEAU PLAYERS pour ajouter la propriÃƒÂ©tÃƒÂ© 'name' (REMPLACER VOTRE TABLEAU ACTUEL)
		var rounds = [];
		
		var players = [];

        // DonnÃƒÂ©es des parties avec dÃƒÂ©parts spÃƒÂ©cifiques
        var dates = [
            '2023-06-03', '2023-06-10', '2023-07-01', '2023-07-02', '2023-09-01', '2023-09-02', '2023-09-03',
            '2024-05-04', '2024-05-18', '2024-05-25', '2024-06-08', '2024-06-15', '2024-06-29', '2024-06-30',
            '2024-09-06', '2024-09-07', '2024-09-08', '2025-05-03', '2025-05-17', '2025-06-07', '2025-06-14', '2025-06-21'
        ];

        var courses = [
            'RiviÃƒÂ¨re-Rouge', 'Hemmingford Parcours FrontiÃƒÂ¨re', 'Parcours Don Quichotte', 'Parcours Don Quichotte',
            'Le Diable', 'Le GÃƒÂ©ant', 'Le GÃƒÂ©ant', 'Vaudreuil', 'Hemmingford Parcours FrontiÃƒÂ¨re', 'VallÃƒÂ©e des Forts',
            'Parcours Bellevue', 'RiviÃƒÂ¨re-Rouge', 'Parcours Don Quichotte', 'Parcours Don Quichotte',
            'Manoir des Sables', 'Manoir des Sables', 'Manoir des Sables', 'Vaudreuil', 'Hemmingford Parcours FrontiÃƒÂ¨re',
            'Lorraine', 'Parcours Bellevue', 'St-Jean limitÃƒÂ©'
        ];

        // DÃƒÂ©parts utilisÃƒÂ©s pour chaque partie (Antonio = bleu pour certaines parties, sinon blanc pour tous)
        var teeUsed = [
            'blanc', 'blanc', 'blanc', 'bleu', 'blanc', 'blanc', 'blanc', 'bleu', 'bleu', 'bleu', 'bleu', 'bleu', 'bleu', 'bleu',
            'blanc', 'blanc', 'bleu', 'bleu', 'bleu', 'bleu', 'blanc', 'bleu'
        ];

        // Fonction pour calculer le handicap de parcours avec la formule complÃƒÂ¨te
        function calculateCourseHandicap(playerHandicapIndex, courseName, teeColor) {
            if (!coursesDatabase[courseName]) {
                console.warn('Terrain non trouvÃƒÂ©:', courseName);
                return playerHandicapIndex; // Fallback vers handicap fixe
            }
            
            var courseData = coursesDatabase[courseName];
            var teeData = courseData.find(t => t.tee === teeColor);
            
            if (!teeData) {
                // Si le dÃƒÂ©part spÃƒÂ©cifique n'existe pas, prendre le premier disponible
                teeData = courseData[0];
                console.warn('DÃƒÂ©part', teeColor, 'non trouvÃƒÂ© pour', courseName, ', utilisation de', teeData.tee);
            }
            
            // Formule complÃƒÂ¨te: (Handicap Index Ãƒâ€” Slope Rating) ÃƒÂ· 113 + (Course Rating - Par)
            var slopeAdjustment = (playerHandicapIndex * teeData.slope) / 113;
            var ratingAdjustment = teeData.rating - teeData.par;
            var courseHandicap = slopeAdjustment + ratingAdjustment;
            
            return Math.round(courseHandicap * 10) / 10; // Arrondir ÃƒÂ  1 dÃƒÂ©cimale
        }

	// Cache pour ÃƒÂ©viter les recalculs rÃƒÂ©pÃƒÂ©tÃƒÂ©s
	var handicapCache = {};

    // Fonctions Firebase
    function savePlayersToFirebase() {
        return database.ref('players').set(players);
    }

    function saveScoresToFirebase() {
        return database.ref('allScores').set(allScores);
    }

    function saveCoursesToFirebase() {
        return database.ref('coursesDatabase').set(coursesDatabase);
    }

    function saveDatesToFirebase() {
        return database.ref('gameData').set({
            dates: dates,
            courses: courses,
            teeUsed: teeUsed
	    });
    }

	function saveRoundsToFirebase() {
    	// Nettoyer les propriÃƒÂ©tÃƒÂ©s undefined avant de sauvegarder
    	var cleanedRounds = rounds.map(function(round) {
        	var cleanRound = {
            	id: round.id,
            	date: round.date,
            	course: round.course,
            	tee: round.tee,
            	type: round.type,
            	year: round.year,
            	month: round.month
        	};
        
        	// Ajouter les propriÃƒÂ©tÃƒÂ©s GPR seulement si elles existent
        	if (round.gprPhase) {
            	cleanRound.gprPhase = round.gprPhase;
        	}
        	if (round.gprFinaleFormat) {
            	cleanRound.gprFinaleFormat = round.gprFinaleFormat;
        	}
        
        	return cleanRound;
   		});
    
    	return database.ref('rounds').set(cleanedRounds);
	}

    function loadDataFromFirebase() {
    	showLoading('Chargement des donnÃƒÂ©es...');

    	return Promise.all([
        	database.ref('players').once('value'),
        	database.ref('allScores').once('value'),
        	database.ref('coursesDatabase').once('value'),
        	database.ref('gameData').once('value'),
			database.ref('calendarEvents').once('value')
    	]).then(function(snapshots) {
        	// Charger les joueurs
        	if (snapshots[0].exists()) {
            	players = snapshots[0].val();
        	}
    
        	// Charger les scores
        	if (snapshots[1].exists()) {
            	allScores = snapshots[1].val();
        	}
    
        	// Charger les terrains
        	if (snapshots[2].exists()) {
            	coursesDatabase = snapshots[2].val();
        	}
    
        	// Charger les donnÃƒÂ©es de parties
        	if (snapshots[3].exists()) {
            	var gameData = snapshots[3].val();
            	if (gameData.dates) dates = gameData.dates;
            	if (gameData.courses) courses = gameData.courses;
            	if (gameData.teeUsed) teeUsed = gameData.teeUsed;
        	}
        
			// Charger les ÃƒÂ©vÃƒÂ©nements calendrier
			if (snapshots[4].exists()) {
    			calendarEvents = snapshots[4].val() || [];
    			console.log('Ãƒâ€°vÃƒÂ©nements calendrier chargÃƒÂ©s:', calendarEvents.length);
			} else {
    			calendarEvents = [];
    			console.log('Aucun ÃƒÂ©vÃƒÂ©nement calendrier trouvÃƒÂ©');
			}

        	// Charger les rounds
        	return database.ref('rounds').once('value');
        
    		}).then(function(snapshot) {
        		if (snapshot.exists()) {
            		rounds = snapshot.val();
            		console.log('Rounds chargÃƒÂ©s:', rounds.length);
            
            		// VÃƒÂ©rifier les mÃƒÂ©tadonnÃƒÂ©es GPR
            		var gprRounds = rounds.filter(r => r.type === 'gpr');
            		console.log('Parties GPR trouvÃƒÂ©es:', gprRounds.length);
            		var finaleRounds = gprRounds.filter(r => r.gprPhase === 'finale');
            		console.log('Parties finale trouvÃƒÂ©es:', finaleRounds.length);
        		}

        		console.log('DonnÃƒÂ©es chargÃƒÂ©es:', players.length, 'joueurs,', dates.length, 'parties');
        		isDataLoaded = true;
        		hideLoading();
    
        		// Initialiser l'interface aprÃƒÂ¨s chargement
        		fixAllPlayerNames();
        		initializeData();
        		loadOverview();
        
    	}).catch(function(error) {
        	console.error('Erreur de chargement:', error);
        	hideLoading();
        	alert('Erreur de chargement des donnÃƒÂ©es: ' + error.message);
    	});
	}

	// =====================================================
	// LISTENERS TEMPS RÃ‰EL FIREBASE
	// =====================================================
	
	function setupRealtimeListeners() {
		console.log('ğŸ”´ Configuration des listeners temps rÃ©el...');
		
		// Listener sur les scores
		database.ref('scores').on('value', function(snapshot) {
			if (snapshot.exists() && isDataLoaded) {
				var newScores = snapshot.val();
				if (JSON.stringify(newScores) !== JSON.stringify(scores)) {
					scores = newScores;
					console.log('ğŸ”´ Scores mis Ã  jour en temps rÃ©el');
					updateAllHandicaps();
					
					// RafraÃ®chir la vue active si nÃ©cessaire
					var activeSection = document.querySelector('.section.active');
					if (activeSection) {
						var sectionId = activeSection.id;
						if (sectionId === 'overview') loadOverview();
						else if (sectionId === 'handicapEvolution') loadHandicapEvolution();
						else if (sectionId === 'details') showRoundDetail();
					}
				}
			}
		});
		
		// Listener sur les joueurs
		database.ref('players').on('value', function(snapshot) {
			if (snapshot.exists() && isDataLoaded) {
				var newPlayers = snapshot.val();
				if (JSON.stringify(newPlayers) !== JSON.stringify(players)) {
					players = newPlayers;
					console.log('ğŸ”´ Joueurs mis Ã  jour en temps rÃ©el');
					
					// RafraÃ®chir la liste des joueurs si visible
					var activeSection = document.querySelector('.section.active');
					if (activeSection && activeSection.id === 'playerManagement') {
						loadPlayerManagement();
					}
				}
			}
		});
		
		// Listener sur les Ã©vÃ©nements calendrier
		database.ref('calendar').on('value', function(snapshot) {
			if (snapshot.exists() && isDataLoaded) {
				calendarEvents = snapshot.val();
				console.log('ğŸ”´ Calendrier mis Ã  jour en temps rÃ©el');
				
				var activeSection = document.querySelector('.section.active');
				if (activeSection && activeSection.id === 'calendar') {
					loadCalendarView();
				}
			}
		});
		
		console.log('âœ… Listeners temps rÃ©el configurÃ©s');
	}
	
	// Fonction pour mettre Ã  jour tous les handicaps
	function updateAllHandicaps() {
		if (!players || !scores) return;
		
		for (var i = 0; i < players.length; i++) {
			var player = players[i];
			var playerScores = scores.filter(function(s) {
				return s.playerId === player.id;
			});
			
			if (playerScores.length >= 3) {
				// Calculer le nouveau handicap basÃ© sur les 3 meilleurs scores
				var sortedScores = playerScores.map(function(s) {
					return calculateScoreDifferentialReal(s.score, s.courseName || '', s.tee || 'blanc');
				}).filter(function(d) { return d !== null; }).sort(function(a, b) { return a - b; });
				
				if (sortedScores.length >= 3) {
					var best3 = sortedScores.slice(0, 3);
					var avgDiff = (best3[0] + best3[1] + best3[2]) / 3;
					var newHandicap = Math.round(avgDiff * 0.96 * 10) / 10;
					
					if (newHandicap !== player.handicap) {
						console.log('Handicap mis Ã  jour pour', player.name, ':', player.handicap, '->', newHandicap);
					}
				}
			}
		}
	}


	// Fonction pour calculer le diffÃƒÂ©rentiel de score
	function calculateScoreDifferentialReal(grossScore, courseName, teeColor) {
    	    if (grossScore <= 0) {
    			return null;
			}
			if (!coursesDatabase[courseName]) {
        	console.warn('Terrain non trouvÃƒÂ©:', courseName);
        	return null;
    	    }
    
    	    var courseData = coursesDatabase[courseName];
    	    var teeData = courseData.find(t => t.tee === teeColor);
    
    	    if (!teeData) {
        	teeData = courseData[0];
        	console.warn('DÃƒÂ©part', teeColor, 'non trouvÃƒÂ© pour', courseName, ', utilisation de', teeData.tee);
    	    }
    
    	    // Score Differential = (Gross Score - Course Rating) Ãƒâ€” 113 / Slope Rating
    	    var differential = (grossScore - teeData.rating) * 113 / teeData.slope;
    	    return Math.round(differential * 10) / 10;
	}

	// 3. FONCTION POUR CALCULER LE NOUVEAU HANDICAP BASÃƒâ€° SUR LES DIFFÃƒâ€°RENTIELS
	function calculateNewHandicapFromDifferentials(differentials, initialHandicap) {
    	    if (differentials.length < 5) {
        	// Pas assez de scores, garder le handicap initial
        	return initialHandicap;
    	    }
    
    	    // Trier les diffÃƒÂ©rentiels (meilleurs en premier)
    	    var sortedDifferentials = [...differentials].sort((a, b) => a - b);
    
    	    // DÃƒÂ©terminer combien de scores utiliser
    	    var scoresToUse = 1;
    	    if (differentials.length >= 20) {
        	scoresToUse = 8;
    	    } else if (differentials.length >= 15) {
        	scoresToUse = 5;
    	    } else if (differentials.length >= 10) {
        	scoresToUse = 3;
    	    } else if (differentials.length >= 7) {
        	scoresToUse = 2;
    	    }
    
    	    // Prendre les meilleurs diffÃƒÂ©rentiels
    	    var bestDifferentials = sortedDifferentials.slice(0, scoresToUse);
    
    	    // Calculer la moyenne
    	    var average = bestDifferentials.reduce((sum, d) => sum + d, 0) / scoresToUse;
    
    	    // Appliquer le facteur 0.96 et arrondir
    	    var newHandicap = average * 0.96;
    
    	    // Limiter entre 0 et 36.4
    	    newHandicap = Math.max(0, Math.min(36.4, newHandicap));
    
    	    return Math.round(newHandicap * 10) / 10;
	}

	// 4. FONCTION POUR FORCER LA MISE Ãƒâ‚¬ JOUR COMPLÃƒË†TE
	function forceHandicapEvolutionUpdate() {
    	    console.log("Ã°Å¸Å¡â‚¬ FORCE MISE Ãƒâ‚¬ JOUR Ãƒâ€°VOLUTION HANDICAPS");
    	    console.log("=========================================");
    
    	    // Recalculer toutes les donnÃƒÂ©es
    	    prepareHandicapEvolutionData();
    
    	    // Mettre ÃƒÂ  jour l'affichage immÃƒÂ©diatement
    	    if (typeof displayHandicapStats === 'function') {
        	displayHandicapStats();
    	    }
    
    	    // Mettre ÃƒÂ  jour le graphique si des joueurs sont sÃƒÂ©lectionnÃƒÂ©s
    	    if (typeof selectedPlayers !== 'undefined' && selectedPlayers.length > 0) {
        	if (typeof drawHandicapChart === 'function') {
            	    drawHandicapChart();
        	}
    	    }
    
    	    // Afficher un rÃƒÂ©sumÃƒÂ© des changements
    	    console.log("\nÃ°Å¸â€œÅ  RÃƒâ€°SUMÃƒâ€° DES Ãƒâ€°VOLUTIONS:");
    	    console.log("========================");
    
    	    for (var playerId in handicapEvolutionData) {
        	var playerData = handicapEvolutionData[playerId];
        	var evolution = playerData.evolution;
        
        	if (evolution.length >= 2) {
            	    var initial = evolution[0].handicap;
            	    var final = evolution[evolution.length - 1].handicap;
            	    var change = final - initial;
            	    var totalGames = evolution.length - 1;
            
            	    var status = '';
            	    if (change < -1) status = 'Ã°Å¸â€œË† AMÃƒâ€°LIORATION';
            	    else if (change > 1) status = 'Ã°Å¸â€œâ€° DÃƒâ€°GRADATION';
            	    else status = 'Ã¢Å¾Â¡Ã¯Â¸Â STABLE';
            
            	    console.log(`${playerData.playerName}:`);
            	    console.log(`  ${initial.toFixed(1)} Ã¢â€ â€™ ${final.toFixed(1)} (${change > 0 ? '+' : ''}${change.toFixed(1)}) ${status}`);
            	    console.log(`  ${totalGames} parties jouÃƒÂ©es`);
        	}
    	    }
    
    	    console.log("\nÃ¢Å“â€¦ MISE Ãƒâ‚¬ JOUR TERMINÃƒâ€°E - VÃƒÂ©rifiez le tableau des statistiques!");
	}

	// Fonction pour recalculer le handicap d'un joueur basÃƒÂ© sur ses scores jusqu'ÃƒÂ  une date donnÃƒÂ©e
	function calculateHandicapAtDate(playerId, upToDate) {
    	    var player = players.find(p => p.id === playerId);
    	    if (!player) return null;
    
    	    var playerIndex = players.findIndex(p => p.id === playerId);
    	    if (playerIndex === -1) return player.handicap;
    
    	    var playerScores = [];
    
    	    // Collecter tous les scores du joueur jusqu'ÃƒÂ  la date spÃƒÂ©cifiÃƒÂ©e
    	    for (var i = 0; i < dates.length; i++) {
        	if (new Date(dates[i]) <= new Date(upToDate)) {
            	    var grossScore = allScores[playerIndex][i];
            
            	    if (grossScore > 0) {
                	var courseName = courses[i];
                	var teeForPlayer = (playerId === 1) ? teeUsed[i] : 'blanc';
                	var differential = calculateScoreDifferential(grossScore, courseName, teeForPlayer);
                
                	if (differential > 0) {
                    	    playerScores.push({
                        	date: dates[i],
                        	differential: differential
                    	    });
                	}
            	    }
        	}
    	    }
    
    	    // Calculer le handicap selon les rÃƒÂ¨gles officielles
    	    if (playerScores.length < 5) {
        	// Pas assez de scores, garder le handicap initial
        	return player.handicap;
    	    }
    
    	    var differentials = playerScores.map(s => s.differential);
    	    differentials.sort((a, b) => a - b);
    
    	    var scoresToUse = 1;
    	    if (playerScores.length >= 20) scoresToUse = 8;
    	    else if (playerScores.length >= 15) scoresToUse = 5;
    	    else if (playerScores.length >= 10) scoresToUse = 3;
    	    else if (playerScores.length >= 7) scoresToUse = 2;
    
    	    var bestDifferentials = differentials.slice(0, scoresToUse);
    	    var average = bestDifferentials.reduce((sum, d) => sum + d, 0) / scoresToUse;
    
    	    return Math.round(average * 0.96 * 10) / 10;
	}

	// Fonction pour obtenir le handicap d'un joueur ÃƒÂ  une date donnÃƒÂ©e
	function getPlayerHandicapAtDate(playerId, gameDate) {
    	    // Chercher dans le cache first
    	    var cacheKey = playerId + '_' + gameDate;
    	    if (handicapCache[cacheKey]) {
        	return handicapCache[cacheKey];
    	    }
    
    	    // Calculer et mettre en cache
    	    var handicap = calculateHandicapAtDate(playerId, gameDate);
    	    handicapCache[cacheKey] = handicap;
    
    	    return handicap;
	}

	// Fonction pour forcer la recalculation de l'ÃƒÂ©volution des handicaps
	function fixHandicapEvolution() {
    	    console.log("Ã°Å¸â€â€ Correction de l'ÃƒÂ©volution des handicaps...");
    
    	    // Vider le cache
    	    handicapCache = {};
    
    	    // Recalculer les donnÃƒÂ©es d'ÃƒÂ©volution avec les vrais handicaps
    	    handicapEvolutionData = {};
    
    	    for (var i = 0; i < players.length; i++) {
        	var player = players[i];
        	var evolution = [];
        	var playerName = player.name || (player.firstName + ' ' + player.lastName);
        
        	// Handicap initial (avant toute partie)
        	var initialHandicap = player.handicap;
        
        	evolution.push({
            	    date: dates[0] || '2023-01-01',
            	    handicap: initialHandicap,
            	    gameNumber: 0,
            	    change: 0
        	});
        
        	// Calculer l'ÃƒÂ©volution aprÃƒÂ¨s chaque partie
        	for (var j = 0; j < dates.length; j++) {
            	    if (allScores[i][j] > 0) {
                	// Calculer le handicap ÃƒÂ  cette date
                	var newHandicap = getPlayerHandicapAtDate(player.id, dates[j]);
                	var previousHandicap = j === 0 ? initialHandicap : evolution[evolution.length - 1].handicap;
                	var change = newHandicap - previousHandicap;
                
                	evolution.push({
                    	    date: dates[j],
                    	    handicap: newHandicap,
                    	    gameNumber: j + 1,
                    	    change: change,
                    	    score: allScores[i][j],
                    	    course: courses[j]
                	});
            	    }
        	}
        
        	handicapEvolutionData[player.id] = {
            	    player: player,
            	    playerName: playerName,
            	    evolution: evolution
        	};
    	    }
    
    	    console.log("Ã¢Å“â€¦ Ãƒâ€°volution des handicaps corrigÃƒÂ©e!");
    
    	    // VÃƒÂ©rifier les rÃƒÂ©sultats
    	    console.log("Ã°Å¸â€œÅ  Nouveaux rÃƒÂ©sultats:");
    	    for (var playerId in handicapEvolutionData) {
        	var playerData = handicapEvolutionData[playerId];
        	var evolution = playerData.evolution;
        
        	if (evolution.length >= 2) {
            	    var initial = evolution[0].handicap;
            	    var final = evolution[evolution.length - 1].handicap;
            	    var change = final - initial;
            
            	    console.log(playerData.playerName + ": " + initial.toFixed(1) + " Ã¢â€ â€™ " + final.toFixed(1) + " (" + (change > 0 ? "+" : "") + change.toFixed(1) + ")");
        	}
    	    }
    
    	    // Recharger l'affichage
    	    displayHandicapStats();
    	    if (selectedPlayers && selectedPlayers.length > 0) {
        	drawHandicapChart();
    	    }
	}

        // Scores rÃƒÂ©els pour chaque joueur
        var allScores = [];
           
        var rounds = [];
        var scores = [];
		var gprRoundsData = [];
		var handicapCache = {};
		// SystÃƒÂ¨me GPR : tracking des finales
		var gprFinaleData = {};
		var GPR_TOTAL_PLAYERS = 12; // Base de calcul pour les absences
		var gprBest4Data = {}; // Stockage des 4 meilleures parties par joueur
		// Variables globales pour le calcul GPR
		var playerPoints = {};
		var playerBest4Points = {};
		var roundDetails = [];
		// Nouvelles constantes pour le systÃƒÂ¨me GPR
		var GPR_TOTAL_PLAYERS = 12; // Base de calcul pour les absences
		var GPR_FINALE_TOTAL_POINTS = 400; // Points fixes pour la finale

		// Fonction pour calculer les points d'absence (derniÃƒÂ¨re place)
		function calculateAbsenteePoints(presentPlayers, isNet, isFinale, finaleFormat) {
		    var totalPlayers = GPR_TOTAL_PLAYERS;
		    var absentees = totalPlayers - presentPlayers;
		    
		    if (absentees <= 0) return 0;
		    
		    // Points selon le type de partie
		    var pointsScale = isFinale ? 
    			(isNet ? [225, 190, 165, 140, 125, 110, 90, 75, 60, 45, 35, 25] : 
            			 [175, 140, 120, 100, 85, 70, 60, 50, 40, 30, 20, 10]) :
    			(isNet ? [120, 105, 90, 78, 70, 62, 54, 46, 38, 30, 22, 15] : 
            			 [80, 68, 60, 52, 45, 40, 35, 30, 25, 20, 15, 10]);

			// Calculer la moyenne des points des derniÃƒÂ¨res places
			var totalAbsenteePoints = 0;
			for (var i = 0; i < absentees; i++) {
    			var position = presentPlayers + i + 1;
    			totalAbsenteePoints += pointsScale[Math.min(position - 1, pointsScale.length - 1)];
			}

			return Math.round(totalAbsenteePoints / absentees);
		}

		// Fonction pour identifier les parties finale
		function isFinaleRound(round) {
    		return round.type === 'gpr' && round.gprPhase === 'finale';
		}

		// Fonction pour calculer les points d'absence (rÃƒÂ¨gle des 12 joueurs)
		function calculateAbsenteePoints(presentPlayers, isNet, isFinale) {
    		var absentees = GPR_TOTAL_PLAYERS - presentPlayers;
    		if (absentees <= 0) return 0;
    
    		var pointsScale = isFinale ? 
        		(isNet ? [225, 190, 165, 140, 125, 110, 90, 75, 60, 45, 35, 25] : 
                		 [175, 140, 120, 100, 85, 70, 60, 50, 40, 30, 20, 10]) :
        		(isNet ? [120, 105, 90, 78, 70, 62, 54, 46, 38, 30, 22, 15] : 
                		 [80, 68, 60, 52, 45, 40, 35, 30, 25, 20, 15, 10]);
    
    		// Calculer la moyenne des points des derniÃƒÂ¨res places
    		var totalAbsenteePoints = 0;
    		for (var i = 0; i < absentees; i++) {
        		var position = presentPlayers + i + 1;
        		totalAbsenteePoints += pointsScale[Math.min(position - 1, pointsScale.length - 1)];
    		}
    
    		return Math.round(totalAbsenteePoints / absentees);
		}
		
		// Fonction pour calculer les 4 meilleures parties d'exhibition
		function calculateBest4Exhibition(playerId, year) {
		    console.log('=== calculateBest4Exhibition ===');
    		console.log('Joueur ID:', playerId, 'AnnÃƒÂ©e:', year);
			
			// Obtenir toutes les parties exhibition de l'annÃƒÂ©e (pas les finales)
			var exhibitionRounds = rounds.filter(r => 
		        r.type === 'gpr' && 
		        r.year === year && 
		        (!r.gprPhase || r.gprPhase === 'exhibition')
		    );

			console.log('Rounds exhibition de l\'annÃƒÂ©e:', exhibitionRounds.length);
		    
		    // Calculer les points pour chaque partie (mÃƒÂªme si le joueur ÃƒÂ©tait absent)
		    var partiesWithPoints = [];
		    
		    for (var i = 0; i < exhibitionRounds.length; i++) {
		        var round = exhibitionRounds[i];
		        var roundScores = scores.filter(s => s.roundId === round.id && s.playerId !== 13);
		        
		        // VÃƒÂ©rifier si le joueur a participÃƒÂ©
		        var playerScore = roundScores.find(s => s.playerId === playerId);
		        
		        var brutPos, netPos, brutPoints, netPoints;
		        
		        if (playerScore) {
		            // Joueur prÃƒÂ©sent - calculer sa position rÃƒÂ©elle
		            var brutRanking = [...roundScores].sort((a, b) => a.score - b.score);
		            var netRanking = [...roundScores].sort((a, b) => a.net - b.net);
		            
		            brutPos = brutRanking.findIndex(s => s.playerId === playerId) + 1;
		            netPos = netRanking.findIndex(s => s.playerId === playerId) + 1;
		            
		            brutPoints = [80, 68, 60, 52, 45, 40, 35, 30, 25, 20, 15, 10][Math.min(brutPos - 1, 11)];
		            netPoints = [120, 105, 90, 78, 70, 62, 54, 46, 38, 30, 22, 15][Math.min(netPos - 1, 11)];
		        } else {
		            // Joueur absent - calculer les points d'absence
		            var presentPlayers = roundScores.length;
		            brutPoints = calculateAbsenteePoints(presentPlayers, false, false);
		            netPoints = calculateAbsenteePoints(presentPlayers, true, false);
		            brutPos = presentPlayers + 1;
		            netPos = presentPlayers + 1;
		            
		            // CrÃƒÂ©er un score fictif pour l'absent
		            playerScore = {
		                playerId: playerId,
		                score: 999,
		                net: 999,
		                absent: true
		            };
		        }
		        
		        partiesWithPoints.push({
		            roundId: round.id,
		            date: round.date,
		            course: round.course,
		            totalPoints: brutPoints + netPoints,
		            brutPoints: brutPoints,
		            netPoints: netPoints,
		            brutPos: brutPos,
		            netPos: netPos,
		            score: playerScore,
		            absent: !roundScores.find(s => s.playerId === playerId)
		        });
		    }
		    
		    console.log('Parties avec points calculÃƒÂ©es:', partiesWithPoints.length);
		    
		    // Trier par points dÃƒÂ©croissants et prendre les 4 meilleures (ou toutes si moins de 5)
		    partiesWithPoints.sort((a, b) => b.totalPoints - a.totalPoints);
		    var result = partiesWithPoints.length >= 5 ? partiesWithPoints.slice(0, 4) : partiesWithPoints;
		    
		    console.log('Best 4 pour joueur', playerId, ':', result.length, 'parties sÃƒÂ©lectionnÃƒÂ©es');
		    return result;
		}

		// Fonction pour cumuler les scores de finale
		function calculateFinaleScores(year) {
    		console.log('=== calculateFinaleScores appelÃƒÂ©e pour annÃƒÂ©e:', year);
    		var finaleRounds = rounds.filter(r => {
    			var yearMatch = !year || r.year == year;
    			return yearMatch && r.type === 'gpr' && r.gprPhase === 'finale';
			});

    		console.log('Rounds finale trouvÃƒÂ©s:', finaleRounds);
    		if (finaleRounds.length > 0) {
        		console.log('Format finale:', finaleRounds[0].gprFinaleFormat);
    		}
    
    		var finaleResults = {};
    
    		if (finaleRounds.length === 0) {
        		console.log('Aucune finale trouvÃƒÂ©e');
        		return {};
    		}
    
    		// Identifier les joueurs participants (exclure Ãƒâ€°ric Gosselin ID 12)
    		for (var i = 0; i < finaleRounds.length; i++) {
        		var round = finaleRounds[i];
        		var roundScores = scores.filter(s => s.roundId === round.id && s.playerId !== 13);
        
        		for (var j = 0; j < roundScores.length; j++) {
            		var score = roundScores[j];
            
            		if (!finaleResults[score.playerId]) {
                		finaleResults[score.playerId] = {
                    		player: players.find(p => p.id === score.playerId),
                    		totalBrut: 0,
                    		totalNet: 0,
                    		daysPlayed: 0
                		};
            		}
            
            		finaleResults[score.playerId].totalBrut += score.score;
            		finaleResults[score.playerId].totalNet += score.net;
            		finaleResults[score.playerId].daysPlayed++;
        		}
    		}
    
			// === AJOUT DES ABSENTS ===
			console.log('=== AJOUT ABSENTS FINALE ' + year + ' ===');

			// Obtenir tous les joueurs GPR de l'annÃƒÂ©e
			var allGPRScores = scores.filter(s => 
    			s.year == year && 
    			s.type === 'gpr' && 
    			s.playerId !== 13
			);

			var gprPlayerIds = [];
			for (var i = 0; i < allGPRScores.length; i++) {
    			if (gprPlayerIds.indexOf(allGPRScores[i].playerId) === -1) {
        			gprPlayerIds.push(allGPRScores[i].playerId);
    			}
			}

			console.log('Joueurs GPR trouvÃƒÂ©s:', gprPlayerIds.length, 'joueurs');
			console.log('IDs:', gprPlayerIds);

			// Ajouter ceux qui manquent
			for (var i = 0; i < gprPlayerIds.length; i++) {
    			var playerId = gprPlayerIds[i];
    			if (!finaleResults[playerId]) {
        			var player = players.find(p => p.id === playerId);
        			finaleResults[playerId] = {
            			player: player,
            			totalBrut: 999,
            			totalNet: 999,
            			daysPlayed: 0,
            			absent: true
        			};
        			console.log('AJOUT ABSENT:', player.name || (player.firstName + ' ' + player.lastName));
    			}
			}

    		// Distribuer les 400 points fixes de finale
    		var playersArray = [];
    		for (var playerId in finaleResults) {
        		playersArray.push({
            		playerId: parseInt(playerId),
            		data: finaleResults[playerId]
        		});
    		}

    		// Classement finale par score brut cumulÃƒÂ©
    		playersArray.sort((a, b) => {
        		if (a.data.daysPlayed === 0 && b.data.daysPlayed === 0) return 0;
        		if (a.data.daysPlayed === 0) return 1;
        		if (b.data.daysPlayed === 0) return -1;
        		return a.data.totalBrut - b.data.totalBrut;
    		});

    		// VÃƒÂ©rifier si c'est une finale 1 jour ou 2 jours
    		var isFinale1Day = false;
    		if (finaleRounds.length > 0 && finaleRounds[0].gprFinaleFormat === '1day') {
        		isFinale1Day = true;
    		}

    		// Points finale FIXES - toujours 400 points au total
			var finaleBrutPoints = [175, 140, 120, 100, 85, 70, 60, 50, 40, 30, 20, 10];
			var finaleNetPoints = [225, 190, 165, 140, 125, 110, 90, 75, 60, 45, 35, 25];

			console.log('Format finale:', isFinale1Day ? '1 jour' : '2 jours');
			console.log('Nombre de jours de finale:', finaleRounds.length);
			console.log('Points brut ÃƒÂ  distribuer:', finaleBrutPoints.reduce((a,b) => a+b, 0));
			console.log('Points net ÃƒÂ  distribuer:', finaleNetPoints.reduce((a,b) => a+b, 0));

			// Distribution des points brut
			for (var i = 0; i < playersArray.length; i++) {
    			var pointsBrut = finaleBrutPoints[Math.min(i, finaleBrutPoints.length - 1)];
    			playersArray[i].data.pointsBrut = pointsBrut;
    			playersArray[i].data.positionBrut = i + 1;
			}

			// Classement finale par score net cumulÃƒÂ©
			playersArray.sort((a, b) => {
    			if (a.data.daysPlayed === 0 && b.data.daysPlayed === 0) return 0;
    			if (a.data.daysPlayed === 0) return 1;
    			if (b.data.daysPlayed === 0) return -1;
    			return a.data.totalNet - b.data.totalNet;
			});

			// Distribution des points net
			for (var i = 0; i < playersArray.length; i++) {
    			var pointsNet = finaleNetPoints[Math.min(i, finaleNetPoints.length - 1)];
    			playersArray[i].data.pointsNet = pointsNet;
    			playersArray[i].data.positionNet = i + 1;
    			playersArray[i].data.totalPointsFinale = playersArray[i].data.pointsBrut + pointsNet;
			}

    		// Debug - VÃƒÂ©rifier le total des points
    		var totalBrutDistribue = 0;
    		var totalNetDistribue = 0;
    		for (var i = 0; i < playersArray.length; i++) {
        		totalBrutDistribue += playersArray[i].data.pointsBrut || 0;
        		totalNetDistribue += playersArray[i].data.pointsNet || 0;
    		}
    		console.log('=== DEBUG FINALE ===');
    		console.log('Total points brut distribuÃƒÂ©s:', totalBrutDistribue);
    		console.log('Total points net distribuÃƒÂ©s:', totalNetDistribue);
    		console.log('TOTAL GÃƒâ€°NÃƒâ€°RAL:', totalBrutDistribue + totalNetDistribue);

    		// Remettre dans l'objet finaleResults
    		for (var i = 0; i < playersArray.length; i++) {
        		var playerId = playersArray[i].playerId;
        		finaleResults[playerId] = playersArray[i].data;
    		}

    		return finaleResults;
		}

	// Fonction pour recalculer le handicap d'un joueur basÃƒÂ© sur ses scores jusqu'ÃƒÂ  une date donnÃƒÂ©e
	function calculateHandicapAtDate(playerId, upToDate) {
    	    var playerScores = [];
    
    	    // Collecter tous les scores du joueur jusqu'ÃƒÂ  la date spÃƒÂ©cifiÃƒÂ©e
    	    for (var i = 0; i < dates.length; i++) {
        	if (new Date(dates[i]) <= new Date(upToDate)) {
            	    if (grossScore > 0) {
    					var courseName = courses[i];
    					var teeForPlayer = (playerId === 1) ? teeUsed[i] : 'blanc';
    					var differential = calculateScoreDifferential(grossScore, courseName, teeForPlayer);
    
    					if (differential !== null) {
        					playerScores.push({
            					date: dates[i],
            					differential: differential
        					});
    					}
					}
            
            	if (grossScore > 0) {
                    var courseName = courses[i];
                    var teeForPlayer = (playerId === 1) ? teeUsed[i] : 'blanc';
                    var differential = calculateScoreDifferential(grossScore, courseName, teeForPlayer);
                
                    if (differential > 0) {
                        playerScores.push({
                            date: dates[i],
                            differential: differential
                        });
                    }
                }
            }
        }
    
    	// Trier par date (plus rÃƒÂ©cent en premier)
    	playerScores.sort((a, b) => new Date(b.date) - new Date(a.date));
    
    	// Calculer le handicap selon les rÃƒÂ¨gles officielles
    	if (playerScores.length < 5) {
            // Pas assez de scores, garder le handicap initial
            var initialPlayer = players.find(p => p.id === playerId);
            return initialPlayer ? initialPlayer.handicap : null;
        }
    
    	var differentials = playerScores.map(s => s.differential);
    	differentials.sort((a, b) => a - b);
    
    	var scoresToUse = 1;
    	if (playerScores.length >= 20) scoresToUse = 8;
    	else if (playerScores.length >= 15) scoresToUse = 5;
    	else if (playerScores.length >= 10) scoresToUse = 3;
    	else if (playerScores.length >= 7) scoresToUse = 2;
    
    	var bestDifferentials = differentials.slice(0, scoresToUse);
    	var average = bestDifferentials.reduce((sum, d) => sum + d, 0) / scoresToUse;
    
    	return Math.round(average * 0.96 * 10) / 10;
    }

    // Fonction pour obtenir le handicap d'un joueur ÃƒÂ  une date donnÃƒÂ©e
    function getPlayerHandicapAtDate(playerId, gameDate) {
    	// Chercher dans le cache first
    	var cacheKey = playerId + '_' + gameDate;
    	if (handicapCache[cacheKey]) {
            return handicapCache[cacheKey];
    	}
    
    	// Calculer et mettre en cache
    	var handicap = calculateHandicapAtDate(playerId, gameDate);
    	handicapCache[cacheKey] = handicap;
    
    	return handicap;
    }

    function initializeData() {
    	// Si rounds n'existe pas, le crÃƒÂ©er
    	if (typeof rounds === 'undefined' || !rounds || rounds.length === 0) {
        	console.log('Pas de rounds chargÃƒÂ©s, crÃƒÂ©ation depuis dates/courses');
        	rounds = [];
        
        	// Construire rounds depuis les anciennes donnÃƒÂ©es
        	for (var i = 0; i < dates.length; i++) {
            	var courseName = courses[i];
            	var isDiablo = (courseName === 'Le Diable' || courseName === 'Le GÃƒÂ©ant' || courseName === 'Manoir des Sables');
            	var gameDate = new Date(dates[i]);
            	var year = gameDate.getFullYear();
            	var month = gameDate.getMonth() + 1;
            
            	rounds.push({
                	id: i + 1,
                	date: dates[i],
                	course: courseName,
                	tee: teeUsed[i],
                	type: isDiablo ? 'diablo' : 'gpr',
                	year: year,
                	month: month
            	});
        	}
    	} else {
        	console.log('Rounds dÃƒÂ©jÃƒÂ  chargÃƒÂ©s depuis Firebase, conservation complÃƒÂ¨te');
        	console.log('Nombre de rounds:', rounds.length);
        	var gprFinales = rounds.filter(r => r.gprPhase === 'finale');
        	console.log('Dont finales GPR:', gprFinales.length);
    	}
    
    	// Toujours reconstruire scores
    	scores = [];
    	handicapCache = {};
    
    	// Reconstruire les scores basÃƒÂ©s sur rounds existants
    	for (var i = 0; i < rounds.length; i++) {
        	var round = rounds[i];
        	var roundIndex = i; // L'index dans allScores correspond ÃƒÂ  l'ordre des rounds
        
        	// Ajouter les scores pour cette partie
        	for (var j = 0; j < players.length; j++) {
            	var grossScore = allScores[j][roundIndex];
            
            	if (grossScore > 0) {
                	var player = players[j];
                	var teeForPlayer = teeUsed[roundIndex];
                
                	// Antonio (id=1) joue des bleus pour certaines parties
                	if (player.id !== 1) {
                    	teeForPlayer = 'blanc';
                	}
                
                	var courseHandicap = calculateCourseHandicap(player.handicap, round.course, teeForPlayer);
                	var netScore = grossScore - courseHandicap;
                
                	scores.push({
                    	roundId: round.id,
                    	playerId: player.id,
                    	playerName: player.name || (player.firstName + ' ' + player.lastName),
                    	score: grossScore,
                    	courseHandicap: courseHandicap,
                    	net: netScore,
                    	tee: teeForPlayer,
                    	type: round.type,
                    	year: round.year,
                    	month: round.month
                	});
            	}
        	}
    	}
    
    	console.log('InitializeData terminÃƒÂ© - Scores reconstruits:', scores.length);
	}

	// Fonction pour calculer le diffÃƒÂ©rentiel de score (Score Differential)
	function calculateScoreDifferential(grossScore, courseName, teeColor) {
    	    if (!coursesDatabase[courseName]) {
        	console.warn('Terrain non trouvÃƒÂ©:', courseName);
        	return null;
    	    }
    
    	    var courseData = coursesDatabase[courseName];
    	    var teeData = courseData.find(t => t.tee === teeColor);
    
    	    if (!teeData) {
        	teeData = courseData[0];
        	console.warn('DÃƒÂ©part', teeColor, 'non trouvÃƒÂ© pour', courseName, ', utilisation de', teeData.tee);
    	    }
    
    	    // Score Differential = (Gross Score - Course Rating) Ãƒâ€” 113 / Slope Rating
    	    var differential = (grossScore - teeData.rating) * 113 / teeData.slope;
    	    return Math.round(differential * 10) / 10;
	}

        // Fonctions de navigation
        function showOverview() {
            hideAllSections();
            document.getElementById('overview').style.display = 'block';
            setActiveButton('showOverview');
            loadOverview();
        }

        function showPlayerScores() {
            hideAllSections();
            document.getElementById('playerScores').style.display = 'block';
            setActiveButton('showPlayerScores');
            loadPlayerSelector();
        }

        function showCourses() {
            hideAllSections();
            document.getElementById('courses').style.display = 'block';
            setActiveButton('showCourses');
            loadCoursesList();
        }

        function showDiablo() {
            hideAllSections();
            document.getElementById('diablo').style.display = 'block';
            setActiveButton('showDiablo');
            loadDiablo();
        }

        function showGPR() {
            hideAllSections();
            document.getElementById('gpr').style.display = 'block';
            setActiveButton('showGPR');
            loadGPR();
        }

        function showProgress() {
            hideAllSections();
            document.getElementById('progress').style.display = 'block';
            setActiveButton('showProgress');
            loadProgress();
        }

        function showDetails() {
            hideAllSections();
            document.getElementById('details').style.display = 'block';
            setActiveButton('showDetails');
            loadDetails();
        }

		function showHandicapEvolution() {
            hideAllSections();
            document.getElementById('handicapEvolution').style.display = 'block';
            setActiveButton('showHandicapEvolution');
            loadDetails();
        }

		function showPlayerManagement() {
            hideAllSections();
            document.getElementById('playerManagement').style.display = 'block';
            setActiveButton('showPlayerManagement');
            loadDetails();
        }

		function showAddRound() {
            hideAllSections();
            document.getElementById('addRound').style.display = 'block';
            setActiveButton('showAddRound');
            loadDetails();
        }

        function hideAllSections() {
    		console.log('Ã°Å¸â€â€ Masquage de toutes les sections...');
    
    		var sections = [
        		'overview', 
        		'playerScores', 
        		'courses', 
        		'diablo', 
        		'gpr', 
        		'progress', 
        		'details', 
        		'handicapEvolution', 
        		'playerManagement', 
        		'addRound'
    		];
    
    		// NE PAS masquer le calendrier ici, il sera gÃƒÂ©rÃƒÂ© sÃƒÂ©parÃƒÂ©ment
    
    		for (var i = 0; i < sections.length; i++) {
        		var element = document.getElementById(sections[i]);
        		if (element) {
            		element.style.display = 'none';
            		element.classList.remove('active');
        		}
    		}
		}

        function setActiveButton(buttonFunction) {
    		var buttons = document.querySelectorAll('.nav button:not(.nav-save-btn)');
    		for (var i = 0; i < buttons.length; i++) {
        		buttons[i].classList.remove('active');
    		}
    
    		// Ajouter active au bon bouton selon la fonction
    		var activeSelector = '';
    		switch(buttonFunction) {
        		case 'showAddRound': activeSelector = 'button[onclick="showAddRound()"]'; break;
        		case 'showProgress': activeSelector = 'button[onclick="showProgress()"]'; break;
        		case 'showDiablo': activeSelector = 'button[onclick="showDiablo()"]'; break;
        		case 'showGPR': activeSelector = 'button[onclick="showGPR()"]'; break;
        		case 'showOverview': activeSelector = 'button[onclick="showOverview()"]'; break;
        		case 'showHandicapEvolution': activeSelector = 'button[onclick="showHandicapEvolution()"]'; break;
        		case 'showPlayerScores': activeSelector = 'button[onclick="showPlayerScores()"]'; break;
        		case 'showDetails': activeSelector = 'button[onclick="showDetails()"]'; break;
        		case 'showCourses': activeSelector = 'button[onclick="showCourses()"]'; break;
        		case 'showPlayerManagement': activeSelector = 'button[onclick="showPlayerManagement()"]'; break;
				case 'showCalendar': activeSelector = 'button[onclick="showCalendar()"]'; break;
    		}
    
    		if (activeSelector) {
        		var activeButton = document.querySelector('.nav ' + activeSelector);
        		if (activeButton) {
            		activeButton.classList.add('active');
        		}
    		}
		}

        // FONCTION loadOverview() - TROUVEZ ET REMPLACEZ CETTE PARTIE :

	function loadOverview() {
    	var totalGames = rounds.length;
    	var totalScores = scores.length;
    	var activePlayers = getUniquePlayersCount(scores);
    	var totalCourses = Object.keys(coursesDatabase).length;

    	var diabloGames = rounds.filter(r => r.type === 'diablo').length;
    	var gprGames = rounds.filter(r => r.type === 'gpr').length;

    	var html = '<div class="player-stats">' +
        	       '<div class="stat-box">' +
            	   '<div class="stat-value">' + totalGames + '</div>' +
                   '<div class="stat-label">Parties Total</div>' +
            	   '</div>' +
            	   '<div class="stat-box">' +
            	   '<div class="stat-value">' + activePlayers + '</div>' +
            	   '<div class="stat-label">Joueurs Actifs</div>' +
            	   '</div>' +
            	   '<div class="stat-box">' +
            	   '<div class="stat-value">' + totalCourses + '</div>' +
            	   '<div class="stat-label">Terrains en Base</div>' +
            	   '</div>' +
            	   '<div class="stat-box">' +
            	   '<div class="stat-value">' + diabloGames + '</div>' +
            	   '<div class="stat-label">Parties Diablo</div>' +
            	   '</div>' +
            	   '<div class="stat-box">' +
            	   '<div class="stat-value">' + gprGames + '</div>' +
            	   '<div class="stat-label">Parties GPR</div>' +
            	   '</div>' +
            	   '</div>';

    	// CLASSEMENT COMPLET DE TOUS LES JOUEURS
    	var allPlayerStats = [];
    	for (var i = 0; i < players.length; i++) {
        	var player = players[i];
        	var playerScores = scores.filter(s => s.playerId === player.id);
        	if (playerScores.length > 0) {
            	var avgGross = playerScores.reduce((sum, s) => sum + s.score, 0) / playerScores.length;
            	var avgNet = playerScores.reduce((sum, s) => sum + s.net, 0) / playerScores.length;
            	var bestGross = Math.min(...playerScores.map(s => s.score));
            	var bestNet = Math.min(...playerScores.map(s => s.net));
            
            	allPlayerStats.push({
                	player: player,
                	playerName: player.name || (player.firstName + ' ' + player.lastName),
                	games: playerScores.length,
                	avgGross: avgGross,
                	avgNet: avgNet,
                	bestGross: bestGross,
                	bestNet: bestNet
            	});
        	}
    	}

    	allPlayerStats.sort((a, b) => a.avgNet - b.avgNet);

    	html += '<h3>Ã°Å¸Ââ€  CLASSEMENT COMPLET DE TOUS LES JOUEURS</h3>' +
        	    '<p style="background: #e7f3ff; padding: 10px; border-radius: 5px; margin: 10px 0;">ClassÃƒÂ© par score net moyen (plus bas = meilleur). Total: ' + allPlayerStats.length + ' joueurs avec au moins 1 partie.</p>' +
        	    '<table class="table">' +
        	    '<thead><tr><th>Ã°Å¸Ââ€  Rang</th><th>Ã°Å¸â€˜Â¤ Joueur</th><th>Ã°Å¸Å½Â® Parties</th><th>Ã°Å¸ÂÅ’Ã¯Â¸Â Handicap</th><th>Ã°Å¸â€œÅ  Moy. Brut</th><th>Ã¢Â­Â Moy. Net</th><th>Ã°Å¸Å½Â¯ Meilleur Net</th><th>Ã°Å¸â€™Âª Meilleur Brut</th></tr></thead>' +
        	    '<tbody>';

    	for (var i = 0; i < allPlayerStats.length; i++) {
        	var stat = allPlayerStats[i];
        	var rowStyle = '';
        	var rankIcon = '';
        
        	// Podium avec icÃƒÂ´nes
        	if (i === 0) {
            	rowStyle = ' style="background: linear-gradient(45deg, #FFD700, #FFF8DC); font-weight: bold;"';
            	rankIcon = 'Ã°Å¸Â¥â€¡';
        	} else if (i === 1) {
            	rowStyle = ' style="background: linear-gradient(45deg, #C0C0C0, #F5F5F5); font-weight: bold;"';
            	rankIcon = 'Ã°Å¸Â¥Ë†';
        	} else if (i === 2) {
            	rowStyle = ' style="background: linear-gradient(45deg, #CD7F32, #F4E4BC); font-weight: bold;"';
            	rankIcon = 'Ã°Å¸Â¥â€°';
        	} else if (i < 5) {
            	rowStyle = ' style="background: #e8f4fd; font-weight: 500;"';
            	rankIcon = 'Ã¢Â­Â';
        	} else if (i >= allPlayerStats.length - 3 && allPlayerStats.length > 5) {
            	rowStyle = ' style="background: #ffe8e8;"';
            	rankIcon = 'Ã°Å¸â€œË†';
        	}
        
        	html += '<tr' + rowStyle + '>' +
            	    '<td><strong>' + rankIcon + ' ' + (i + 1) + '</strong></td>' +
            	    '<td><strong>' + stat.playerName + '</strong></td>' +
            	    '<td>' + stat.games + '</td>' +
            	    '<td>' + stat.player.handicap.toFixed(1) + '</td>' +
            	    '<td>' + stat.avgGross.toFixed(1) + '</td>' +
            	    '<td><strong style="color: ' + (i < 3 ? '#28a745' : '#333') + ';">' + stat.avgNet.toFixed(1) + '</strong></td>' +
            	    '<td>' + stat.bestNet.toFixed(1) + '</td>' +
            	    '<td>' + stat.bestGross + '</td>' +
            	    '</tr>';
    	}

    	html += '</tbody></table>';

    	// ANALYSE STATISTIQUE DÃƒâ€°TAILLÃƒâ€°E
    	if (allPlayerStats.length > 0) {
        	html += '<div class="card" style="background: #f8f9fa; margin-top: 20px;">' +
            	    '<h4>Ã°Å¸â€œÅ  Analyse Statistique ComplÃƒÂ¨te</h4>' +
            	    '<div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(250px, 1fr)); gap: 15px;">';
        
        	var bestPlayer = allPlayerStats[0];
        	var worstPlayer = allPlayerStats[allPlayerStats.length - 1];
        	var avgNetAll = allPlayerStats.reduce((sum, stat) => sum + stat.avgNet, 0) / allPlayerStats.length;
        	var medianIndex = Math.floor(allPlayerStats.length / 2);
        	var medianNet = allPlayerStats[medianIndex].avgNet;
        	var spread = worstPlayer.avgNet - bestPlayer.avgNet;
        
        	html += '<div class="stat-box" style="background: #e8f5e8; border-left: 5px solid #28a745;">' +
            	    '<div class="stat-value" style="color: #28a745;">Ã°Å¸Â¥â€¡ ' + bestPlayer.avgNet.toFixed(1) + '</div>' +
            	    '<div class="stat-label">Champion<br><strong>' + bestPlayer.playerName + '</strong></div>' +
            	    '</div>' +
                
            	    '<div class="stat-box" style="background: #ffe8e8; border-left: 5px solid #dc3545;">' +
            	    '<div class="stat-value" style="color: #dc3545;">Ã°Å¸â€œË† ' + worstPlayer.avgNet.toFixed(1) + '</div>' +
            	    '<div class="stat-label">Ãƒâ‚¬ AmÃƒÂ©liorer<br><strong>' + worstPlayer.playerName + '</strong></div>' +
            	    '</div>' +
                
            	    '<div class="stat-box" style="background: #e3f2fd; border-left: 5px solid #2196f3;">' +
            	    '<div class="stat-value" style="color: #2196f3;">Ã°Å¸â€œÅ  ' + avgNetAll.toFixed(1) + '</div>' +
            	    '<div class="stat-label">Moyenne Groupe</div>' +
            	    '</div>' +
                
            	    '<div class="stat-box" style="background: #f3e5f5; border-left: 5px solid #9c27b0;">' +
            	    '<div class="stat-value" style="color: #9c27b0;">Ã°Å¸â€œÂ ' + medianNet.toFixed(1) + '</div>' +
            	    '<div class="stat-label">Score MÃƒÂ©dian</div>' +
            	    '</div>' +
                
            	    '<div class="stat-box" style="background: #fff3e0; border-left: 5px solid #ff9800;">' +
            	    '<div class="stat-value" style="color: #ff9800;">Ã°Å¸â€œÂ ' + spread.toFixed(1) + '</div>' +
            	    '<div class="stat-label">Ãƒâ€°cart Total</div>' +
            	    '</div>';
        
        	// Distribution par niveau
        	var excellent = allPlayerStats.filter(s => s.avgNet < avgNetAll - 2).length;
        	var good = allPlayerStats.filter(s => s.avgNet >= avgNetAll - 2 && s.avgNet < avgNetAll).length;
        	var average = allPlayerStats.filter(s => s.avgNet >= avgNetAll && s.avgNet < avgNetAll + 2).length;
        	var improving = allPlayerStats.filter(s => s.avgNet >= avgNetAll + 2).length;
        
        	html += '<div class="stat-box" style="background: #f0f0f0; border-left: 5px solid #666;">' +
            	    '<div class="stat-value" style="color: #666; font-size: 16px;">Ã°Å¸â€œË† Distribution</div>' +
                	'<div class="stat-label" style="font-size: 12px; line-height: 1.3;">' +
                	'Ã°Å¸Å’Å¸ Excellent: <strong>' + excellent + '</strong><br>' +
                	'Ã°Å¸â€˜Â Bon: <strong>' + good + '</strong><br>' +
                	'Ã°Å¸â€œÅ  Moyen: <strong>' + average + '</strong><br>' +
                	'Ã°Å¸â€â€ Ãƒâ‚¬ amÃƒÂ©liorer: <strong>' + improving + '</strong>' +
                	'</div>' +
                	'</div>';
        
        	html += '</div></div>';
    	}

    	document.getElementById('overviewStats').innerHTML = html;
	}

        // VOIR LES TERRAINS

	function loadCoursesList() {
    	    var html = '';
    	    console.log('=== CHARGEMENT DES TERRAINS ===');
			var courseNames = Object.keys(coursesDatabase).sort();
    
    	    // Afficher les statistiques
    	    var totalTees = 0;
    	    for (var courseName in coursesDatabase) {
        	totalTees += coursesDatabase[courseName].length;
    	    }
    
    	    html += '<div style="background: #f8f9fa; padding: 15px; border-radius: 8px; margin-bottom: 20px;">' +
            	    '<strong>Ã°Å¸â€œÅ  RÃƒÂ©sumÃƒÂ©:</strong> ' + courseNames.length + ' terrains avec ' + totalTees + ' dÃƒÂ©parts au total' +
            	    '</div>';
    
    	    html += '<div class="course-grid">';
    
    	    for (var i = 0; i < courseNames.length; i++) {
        	var courseName = courseNames[i];
        	var tees = coursesDatabase[courseName];
        
        	html += '<div class="course-card">' +
        			'<div class="course-header">' +
        			'<div class="course-name">Ã°Å¸ÂÅ’Ã¯Â¸Â ' + courseName + '</div>' +
        			'<div>' +
        			'<button class="btn-secondary" onclick="editCourse(\'' + courseName + '\')" style="margin-right: 5px;">Ã¢Å“ÂÃ¯Â¸Â Modifier</button>' +
        			'<button class="btn-danger" onclick="deleteCourse(\'' + courseName + '\')">Ã°Å¸â€”â€˜Ã¯Â¸Â Supprimer</button>' +
        			'</div>' +
        			'</div>';
        
        	// Afficher chaque dÃƒÂ©part avec ses dÃƒÂ©tails
        	for (var j = 0; j < tees.length; j++) {
            	    var tee = tees[j];
            
            	    // DÃƒÂ©terminer la couleur du dÃƒÂ©part
            	    var teeIcon = '';
            	    switch(tee.tee) {
                	case 'blanc': teeIcon = 'Ã¢Å¡Âª'; break;
                	case 'bleu': teeIcon = 'Ã°Å¸â€Âµ'; break;
                	case 'vert': teeIcon = 'Ã°Å¸Å¸Â¢'; break;
                	case 'jaune': teeIcon = 'Ã°Å¸Å¸Â¡'; break;
                	case 'noir': teeIcon = 'Ã¢Å¡Â«'; break;
                	default: teeIcon = 'Ã°Å¸ÂÅ’Ã¯Â¸Â'; break;
            	    }
            
            	    // Niveau de difficultÃƒÂ© basÃƒÂ© sur le slope
            	    var difficulty = '';
            	    var difficultyColor = '';
            	    if (tee.slope < 113) {
                	difficulty = 'Facile';
                	difficultyColor = '#28a745';
            	    } else if (tee.slope < 125) {
                	difficulty = 'Moyen';
                	difficultyColor = '#ffc107';
            	    } else if (tee.slope < 135) {
                	difficulty = 'Difficile';
                	difficultyColor = '#fd7e14';
            	    } else {
                	difficulty = 'TrÃƒÂ¨s difficile';
                	difficultyColor = '#dc3545';
            	    }
            
            	    html += '<div class="tee-info" style="border-left: 4px solid ' + difficultyColor + ';">' +
                    	    '<div style="display: flex; align-items: center; gap: 10px;">' +
                    	    '<span style="font-size: 18px;">' + teeIcon + '</span>' +
                    	    '<div>' +
                    	    '<span class="tee-color tee-' + tee.tee + '" style="padding: 3px 8px; border-radius: 12px; font-size: 11px; font-weight: bold;">' + 
                    	    tee.tee.toUpperCase() + '</span>' +
                    	    '<br><small style="color: ' + difficultyColor + '; font-weight: bold;">' + difficulty + '</small>' +
                    	    '</div>' +
                    	    '</div>' +
                    	    '<div style="text-align: right; font-family: monospace;">' +
                    	    '<div><strong>Rating:</strong> ' + tee.rating + '</div>' +
                    	    '<div><strong>Slope:</strong> ' + tee.slope + '</div>' +
                    	    '<div><strong>Par:</strong> ' + tee.par + '</div>' +
                    	    '</div>' +
                    	    '</div>';
        	}
        
        	html += '</div>';
    	    }
    
    	    html += '</div>';
    
			console.log('HTML gÃƒÂ©nÃƒÂ©rÃƒÂ©:', html.substring(0, 500));
    	    document.getElementById('coursesList').innerHTML = html;
	}

    function toggleAddCourseForm() {
        var form = document.getElementById('addCourseForm');
        if (form.style.display === 'none') {
            form.style.display = 'block';
            document.getElementById('newCourseName').value = '';
            // Reset form with one tee input
            document.getElementById('teeInputs').innerHTML = 
                '<div class="tee-form-row">' +
                '<select>' +
                '<option value="blanc">Blanc</option>' +
                '<option value="bleu">Bleu</option>' +
                '<option value="vert">Vert</option>' +
                '<option value="jaune">Jaune</option>' +
                '<option value="noir">Noir</option>' +
                '</select>' +
                '<input type="number" placeholder="Rating (ex: 69.5)" step="0.1" min="60" max="80">' +
                '<input type="number" placeholder="Slope (ex: 123)" min="85" max="155">' +
                '<input type="number" placeholder="Par (ex: 72)" min="68" max="76">' +
                '<button type="button" class="btn-danger" onclick="removeTeeInput(this)">Ã¢ÂÅ’</button>' +
                '</div>';
        } else {
            form.style.display = 'none';
        }
    }

    function addTeeInput() {
        var container = document.getElementById('teeInputs');
        var newRow = document.createElement('div');
        newRow.className = 'tee-form-row';
        newRow.innerHTML = 
            '<select>' +
            '<option value="blanc">Blanc</option>' +
            '<option value="bleu">Bleu</option>' +
            '<option value="vert">Vert</option>' +
            '<option value="jaune">Jaune</option>' +
            '<option value="noir">Noir</option>' +
            '</select>' +
            '<input type="number" placeholder="Rating (ex: 69.5)" step="0.1" min="60" max="80">' +
            '<input type="number" placeholder="Slope (ex: 123)" min="85" max="155">' +
            '<input type="number" placeholder="Par (ex: 72)" min="68" max="76">' +
            '<button type="button" class="btn-danger" onclick="removeTeeInput(this)">Ã¢ÂÅ’</button>';
        container.appendChild(newRow);
    }

    function removeTeeInput(button) {
        var container = document.getElementById('teeInputs');
        if (container.children.length > 1) {
            button.parentElement.remove();
        }
    }

    function saveCourse() {
        var courseName = document.getElementById('newCourseName').value.trim();
        if (!courseName) {
            alert('Veuillez saisir le nom du terrain.');
            return;
        }
            
        if (coursesDatabase[courseName]) {
            if (!confirm('Ce terrain existe dÃƒÂ©jÃƒÂ . Voulez-vous le remplacer?')) {
                return;
            }
        }
            
        var teeRows = document.querySelectorAll('#teeInputs .tee-form-row');
        var tees = [];
            
        for (var i = 0; i < teeRows.length; i++) {
            var row = teeRows[i];
            var select = row.querySelector('select');
            var ratingInput = row.querySelectorAll('input')[0];
            var slopeInput = row.querySelectorAll('input')[1];
            var parInput = row.querySelectorAll('input')[2];
                
            var teeColor = select.value;
            var rating = parseFloat(ratingInput.value);
            var slope = parseInt(slopeInput.value);
            var par = parseInt(parInput.value);
                
            if (!rating || !slope || !par || rating < 60 || rating > 80 || slope < 85 || slope > 155 || par < 68 || par > 76) {
                alert('Veuillez remplir tous les champs avec des valeurs valides (Rating: 60-80, Slope: 85-155, Par: 68-76).');
                return;
            }
                
            tees.push({
                tee: teeColor,
                rating: rating,
                slope: slope,
                par: par
            });
        }
            
        coursesDatabase[courseName] = tees;
        // Sauvegarder dans Firebase
        saveCoursesToFirebase().then(function() {
            console.log('Terrain sauvegardÃƒÂ© dans Firebase');
        }).catch(function(error) {
            console.error('Erreur de sauvegarde terrain:', error);
            showToast('Erreur de sauvegarde: ' + error.message, true);
        });
        saveCourseData();
        loadCoursesList();
        toggleAddCourseForm();
            
        document.getElementById('coursesList').insertAdjacentHTML('afterbegin',
            '<div class="alert-success">Ã¢Å“â€¦ Terrain "' + courseName + '" ajoutÃƒÂ© avec succÃƒÂ¨s!</div>'
        );
            
        setTimeout(function() {
            var alert = document.querySelector('#coursesList .alert-success');
            if (alert) alert.remove();
        }, 3000);
    }

    function cancelAddCourse() {
        toggleAddCourseForm();
    }

    function deleteCourse(courseName) {
    	if (confirm('ÃƒÅ tes-vous sÃƒÂ»r de vouloir supprimer le terrain "' + courseName + '"?')) {
        	delete coursesDatabase[courseName];
        
        	// Sauvegarder dans Firebase
        	saveCoursesToFirebase().then(function() {
            	console.log('Terrain supprimÃƒÂ© de Firebase');
        	}).catch(function(error) {
            	console.error('Erreur de suppression terrain:', error);
            	alert('Erreur de suppression: ' + error.message);
        	});
        
        	saveCourseData();
        	loadCoursesList();
        
        	document.getElementById('coursesList').insertAdjacentHTML('afterbegin',
            	'<div class="alert-danger">Ã°Å¸â€”â€˜Ã¯Â¸Â Terrain "' + courseName + '" supprimÃƒÂ©.</div>'
       		);
        
        	setTimeout(function() {
            	var alert = document.querySelector('#coursesList .alert-danger');
            	if (alert) alert.remove();
        	}, 3000);
    	}
	}

	// Nouvelle fonction pour ÃƒÂ©diter un terrain existant
	function editCourse(courseName) {
    	var courseData = coursesDatabase[courseName];
    	if (!courseData) {
        	alert('Terrain non trouvÃƒÂ©!');
        	return;
    	}

    	// CrÃƒÂ©er le formulaire d'ÃƒÂ©dition
    	var formHtml = 
    		'<div style="position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.5); z-index: 1000; overflow-y: auto;">' +
    		'<div style="background: white; padding: 30px; margin: 50px auto; border-radius: 10px; box-shadow: 0 4px 20px rgba(0,0,0,0.3); max-width: 700px; width: 90%;">' +
        	'<h3 style="margin-top: 0; color: #2c5530;">Ã¢Å“ÂÃ¯Â¸Â Modifier le Terrain</h3>' +
    
    		'<div style="margin: 15px 0;">' +
        	'<label style="display: block; font-weight: bold; margin-bottom: 5px;">Nom du terrain:</label>' +
        	'<input type="text" id="editCourseName" value="' + courseName.replace(/"/g, '&quot;') + '" style="width: 100%; padding: 8px; border: 1px solid #ddd; border-radius: 4px;">' +
    		'</div>' +
        
    		'<h4>DÃƒÂ©parts disponibles:</h4>' +
        	'<div id="editTeeInputs">';

    	// Ajouter les dÃƒÂ©parts existants
    	for (var i = 0; i < courseData.length; i++) {
        	var tee = courseData[i];
        	formHtml += '<div class="tee-form-row">' +
            	'<select>' +
            	'<option value="blanc"' + (tee.tee === 'blanc' ? ' selected' : '') + '>Blanc</option>' +
            	'<option value="bleu"' + (tee.tee === 'bleu' ? ' selected' : '') + '>Bleu</option>' +
        		'<option value="vert"' + (tee.tee === 'vert' ? ' selected' : '') + '>Vert</option>' +
        		'<option value="jaune"' + (tee.tee === 'jaune' ? ' selected' : '') + '>Jaune</option>' +
        		'<option value="noir"' + (tee.tee === 'noir' ? ' selected' : '') + '>Noir</option>' +
            	'</select>' +
            	'<input type="number" value="' + tee.rating + '" step="0.1" min="60" max="80" placeholder="Rating">' +
        		'<input type="number" value="' + tee.slope + '" min="85" max="155" placeholder="Slope">' +
        		'<input type="number" value="' + tee.par + '" min="68" max="76" placeholder="Par">' +
        		'<button type="button" class="btn-danger" onclick="removeEditTeeInput(this)">Ã¢ÂÅ’</button>' +
            	'</div>';
    	}

    	formHtml += '</div>' +
        	'<button class="btn-secondary" onclick="addEditTeeInput()">Ã¢Å¾â€¢ Ajouter un DÃƒÂ©part</button>' +
        	'<br><br>' +
    		'<div style="margin-top: 25px; text-align: center;">' +
    		'<button onclick="saveCourseEdit(\'' + courseName + '\')" style="background: #4a7c59; color: white; border: none; padding: 12px 24px; border-radius: 5px; margin: 5px; cursor: pointer; font-size: 16px;">Ã°Å¸â€™Â¾ Sauvegarder</button>' +
        	'<button onclick="cancelCourseEdit()" style="background: #6c757d; color: white; border: none; padding: 12px 24px; border-radius: 5px; margin: 5px; cursor: pointer; font-size: 16px;">Ã¢ÂÅ’ Annuler</button>' +
        	'</div>' +
    		'</div></div>';

    	// Ajouter la popup au body
    	var popup = document.createElement('div');
    	popup.id = 'editCoursePopup';
    	popup.innerHTML = formHtml;
    	document.body.appendChild(popup);
	}

	// Ajouter un nouveau dÃƒÂ©part dans l'ÃƒÂ©dition
	function addEditTeeInput() {
    	var container = document.getElementById('editTeeInputs');
   		var newRow = document.createElement('div');
    	newRow.className = 'tee-form-row';
    	newRow.innerHTML = 
        	'<select>' +
        	'<option value="blanc">Blanc</option>' +
    		'<option value="bleu">Bleu</option>' +
    		'<option value="vert">Vert</option>' +
        	'<option value="jaune">Jaune</option>' +
        	'<option value="noir">Noir</option>' +
    		'</select>' +
    		'<input type="number" placeholder="Rating (ex: 69.5)" step="0.1" min="60" max="80">' +
        	'<input type="number" placeholder="Slope (ex: 123)" min="85" max="155">' +
        	'<input type="number" placeholder="Par (ex: 72)" min="68" max="76">' +
    		'<button type="button" class="btn-danger" onclick="removeEditTeeInput(this)">Ã¢ÂÅ’</button>';
    	container.appendChild(newRow);
	}

	// Supprimer un dÃƒÂ©part dans l'ÃƒÂ©dition
	function removeEditTeeInput(button) {
    	var container = document.getElementById('editTeeInputs');
    	if (container.children.length > 1) {
        	button.parentElement.remove();
    	} else {
        	alert('Un terrain doit avoir au moins un dÃƒÂ©part.');
    	}
	}

	// Sauvegarder les modifications du terrain
	function saveCourseEdit(originalCourseName) {
    	var newCourseName = document.getElementById('editCourseName').value.trim();
    	if (!newCourseName) {
        	alert('Veuillez saisir le nom du terrain.');
        	return;
    	}
    
    	// VÃƒÂ©rifier si le nouveau nom existe dÃƒÂ©jÃƒÂ  (sauf si c'est le mÃƒÂªme)
    	if (newCourseName !== originalCourseName && coursesDatabase[newCourseName]) {
        	alert('Un terrain avec ce nom existe dÃƒÂ©jÃƒÂ .');
        	return;
    	}
    
    	var teeRows = document.querySelectorAll('#editTeeInputs .tee-form-row');
    	var tees = [];
    
    	for (var i = 0; i < teeRows.length; i++) {
        	var row = teeRows[i];
        	var select = row.querySelector('select');
    		var ratingInput = row.querySelectorAll('input')[0];
   			var slopeInput = row.querySelectorAll('input')[1];
        	var parInput = row.querySelectorAll('input')[2];
        
        	var teeColor = select.value;
    		var rating = parseFloat(ratingInput.value);
    		var slope = parseInt(slopeInput.value);
			var par = parseInt(parInput.value);
        
        	if (!rating || !slope || !par || rating < 60 || rating > 80 || slope < 85 || slope > 155 || par < 68 || par > 76) {
        		alert('Veuillez remplir tous les champs avec des valeurs valides (Rating: 60-80, Slope: 85-155, Par: 68-76).');
        		return;
        		}
        
        	tees.push({
        		tee: teeColor,
        		rating: rating,
        		slope: slope,
            	par: par
        	});
    	}
    
    	// Si le nom a changÃƒÂ©, supprimer l'ancien
    	if (newCourseName !== originalCourseName) {
    		delete coursesDatabase[originalCourseName];
        
        	// Mettre ÃƒÂ  jour toutes les rÃƒÂ©fÃƒÂ©rences dans les parties existantes
        	for (var i = 0; i < courses.length; i++) {
        		if (courses[i] === originalCourseName) {
            		courses[i] = newCourseName;
            	}
        	}
        
        	// Mettre ÃƒÂ  jour les rounds
        	for (var i = 0; i < rounds.length; i++) {
        		if (rounds[i].course === originalCourseName) {
            		rounds[i].course = newCourseName;
            	}
        	}
    	}
    
    	// Sauvegarder le terrain (nouveau nom ou modifiÃƒÂ©)
    	coursesDatabase[newCourseName] = tees;
    
		// Sauvegarder dans Firebase
    	Promise.all([
    		saveCoursesToFirebase(),
    		saveDatesToFirebase()
    	]).then(function() {
        	console.log('Terrain modifiÃƒÂ© dans Firebase');
        	var action = newCourseName !== originalCourseName ? 'renommÃƒÂ© et modifiÃƒÂ©' : 'modifiÃƒÂ©';
    		alert('Ã¢Å“â€¦ Terrain "' + newCourseName + '" ' + action + ' avec succÃƒÂ¨s!');
    		cancelCourseEdit();
			loadCoursesList();
        
    	}).catch(function(error) {
    		console.error('Erreur de modification terrain:', error);
    		alert('Erreur de modification: ' + error.message);
    	});
	}

	// Fermer la popup d'ÃƒÂ©dition
	function cancelCourseEdit() {
    	var popup = document.getElementById('editCoursePopup');
    	if (popup) {
        	popup.remove();
    	}
	}
    function exportCourses() {
        var dataToExport = {
            courses: coursesDatabase,
            exportDate: new Date().toISOString(),
            totalCourses: Object.keys(coursesDatabase).length
        };
            
        var dataStr = JSON.stringify(dataToExport, null, 2);
        var dataBlob = new Blob([dataStr], {type: 'application/json'});
            
        var link = document.createElement('a');
        link.href = URL.createObjectURL(dataBlob);
        link.download = 'terrains-golf-' + new Date().toISOString().split('T')[0] + '.json';
        link.click();
    }

    function saveCourseData() {
        try {
            var dataString = JSON.stringify(coursesDatabase);
            // Simulate saving to storage
            console.log('Courses saved:', Object.keys(coursesDatabase).length + ' terrains');
        } catch (e) {
            console.error('Erreur de sauvegarde:', e);
        }
    }

    // Scores par joueur
    function loadPlayerSelector() {
    	var select = document.getElementById('playerSelect');
    	select.innerHTML = '<option value="">-- Choisir un joueur --</option>';
    
    	for (var i = 0; i < players.length; i++) {
        var player = players[i];
        var option = document.createElement('option');
        option.value = player.id;
        option.textContent = player.name || (player.firstName + ' ' + player.lastName); // CORRECTION
        select.appendChild(option);
    	}
	}

    function showPlayerDetail() {
    	var playerId = parseInt(document.getElementById('playerSelect').value);
    	var container = document.getElementById('playerDetail');
    
    	if (!playerId) {
        container.innerHTML = '';
        return;
    	}
    
    	var player = players.find(p => p.id === playerId);
    	var playerScores = scores.filter(s => s.playerId === playerId);
    
    	if (playerScores.length === 0) {
        container.innerHTML = '<div class="card"><p>Aucun score enregistrÃƒÂ© pour ce joueur.</p></div>';
        return;
    	}
    
    	var playerName = player.name || (player.firstName + ' ' + player.lastName); // CORRECTION
    
    	// Statistiques du joueur
    	var avgGross = playerScores.reduce((sum, s) => sum + s.score, 0) / playerScores.length;
    	var avgNet = playerScores.reduce((sum, s) => sum + s.net, 0) / playerScores.length;
    	var bestGross = Math.min(...playerScores.map(s => s.score));
    	var worstGross = Math.max(...playerScores.map(s => s.score));
    	var bestNet = Math.min(...playerScores.map(s => s.net));
    	var worstNet = Math.max(...playerScores.map(s => s.net));
    
    	var diabloScores = playerScores.filter(s => s.type === 'diablo');
    	var gprScores = playerScores.filter(s => s.type === 'gpr');
    
    	var html = '<div class="player-card">' +
               	   '<h3>Ã°Å¸ÂÅ’Ã¯Â¸Â ' + playerName + ' (Handicap Index: ' + player.handicap + ')</h3>' +  // UTILISER playerName
               
               	   '<div class="player-stats">' +
                   '<div class="stat-box">' +
           	       '<div class="stat-value">' + playerScores.length + '</div>' +
           	       '<div class="stat-label">Parties JouÃƒÂ©es</div>' +
           	       '</div>' +
                   '<div class="stat-box">' +
               	   '<div class="stat-value">' + avgGross.toFixed(1) + '</div>' +
                   '<div class="stat-label">Score Brut Moyen</div>' +
           	       '</div>' +
           	       '<div class="stat-box">' +
           	       '<div class="stat-value">' + avgNet.toFixed(1) + '</div>' +
               	   '<div class="stat-label">Score Net Moyen</div>' +
               	   '</div>' +
                   '<div class="stat-box">' +
           	       '<div class="stat-value">' + bestGross + '</div>' +
           	       '<div class="stat-label">Meilleur Score Brut</div>' +
           	       '</div>' +
               	   '<div class="stat-box">' +
               	   '<div class="stat-value">' + bestNet.toFixed(1) + '</div>' +
                   '<div class="stat-label">Meilleur Score Net</div>' +
           	       '</div>' +
           	       '<div class="stat-box">' +
           	       '<div class="stat-value">' + diabloScores.length + '</div>' +
               	   '<div class="stat-label">Parties Diablo</div>' +
               	   '</div>' +
                   '<div class="stat-box">' +
           	       '<div class="stat-value">' + gprScores.length + '</div>' +
           	       '<div class="stat-label">Parties GPR</div>' +
           	       '</div>' +
               	   '</div>' +
               
               	   '<h4>Ã°Å¸â€œâ€¹ Historique des Scores</h4>' +
                   '<div class="score-history">';
    
    	// Trier les scores par date (plus rÃƒÂ©cents en premier)
        playerScores.sort((a, b) => {
        var roundA = rounds.find(r => r.id === a.roundId);
        var roundB = rounds.find(r => r.id === b.roundId);
        return new Date(roundB.date) - new Date(roundA.date);
    	});
    
    	for (var i = 0; i < playerScores.length; i++) {
        var score = playerScores[i];
        var round = rounds.find(r => r.id === score.roundId);
        
        var scoreClass = '';
        if (score.score === bestGross) scoreClass = 'best-score';
        else if (score.score === worstGross) scoreClass = 'worst-score';
        
        var badgeClass = score.type === 'diablo' ? 'badge-diablo' : 'badge-gpr';
        var badgeText = score.type === 'diablo' ? 'Ã°Å¸Ââ€  Diablo' : 'Ã°Å¸Å½Â¯ GPR';
        
        var teeIcon = score.tee === 'bleu' ? 'Ã°Å¸â€Âµ' : 'Ã¢Å¡Âª';
        
        html += '<div class="score-row">' +
                '<div>' +
                '<strong>' + round.date.split('-').reverse().join('/') + '</strong><br>' +
            	'<small>' + round.course + ' ' + teeIcon + ' ' + score.tee + '</small>' +
            	'</div>' +
            	'<div class="tournament-badge ' + badgeClass + '">' + badgeText + '</div>' +
            	'<div style="text-align: right;">' +
                '<span class="' + scoreClass + '">Brut: ' + score.score + '</span><br>' +
            	'<small>Handicap: ' + score.courseHandicap.toFixed(1) + ' | Net: ' + score.net.toFixed(1) + '</small>' +
            	'</div>' +
            	'</div>';
    	}
    
    	html += '</div></div>';
    	container.innerHTML = html;
	}

        // 1. REMPLACER LA FONCTION loadDiablo() par celle-ci :

	function loadDiablo() {
    	loadYearSelectors();
    
    	var selectedYear = document.getElementById('diabloYearSelect').value;
    
    	// Format 2026+: 2 jours, 2 champions (brut + net)
    	var isNewFormat = selectedYear && parseInt(selectedYear) >= 2026;
    	var requiredGames = isNewFormat ? 2 : 3;
    
    	var diabloScores = scores.filter(s => {
        	return s.type === 'diablo' && (!selectedYear || s.year == selectedYear);
    	});

    	if (diabloScores.length === 0) {
        	document.getElementById('diabloContent').innerHTML = '<p>Aucune partie Diablo trouvÃƒÂ©e pour cette pÃƒÂ©riode.</p>';
        	document.getElementById('diabloStatus').innerHTML = '';
        	return;
    	}

    	updateDiabloStatus(selectedYear);

    	var playerStats = {};
    
    	for (var i = 0; i < diabloScores.length; i++) {
        	var score = diabloScores[i];
        	if (!playerStats[score.playerId]) {
            	var player = players.find(p => p.id === score.playerId);
            	var playerName = player ? (player.name || (player.firstName + ' ' + player.lastName)) : ('Joueur #' + score.playerId);
            
            	playerStats[score.playerId] = {
                	player: player,
                	playerName: playerName,
                	totalRounds: 0,
                	totalNet: 0,
                	totalBrut: 0
            	};
        	}
        	playerStats[score.playerId].totalRounds++;
        	playerStats[score.playerId].totalNet += score.net;
        	playerStats[score.playerId].totalBrut += score.score;
    	}

    	var leaderboard = [];
    	for (var playerId in playerStats) {
        	var stats = playerStats[playerId];
        	leaderboard.push({
            	player: stats.player,
            	playerName: stats.playerName,
            	rounds: stats.totalRounds,
            	avgNet: stats.totalNet / stats.totalRounds
        	});
    	}

    	leaderboard.sort((a, b) => a.avgNet - b.avgNet);

    	var yearText = selectedYear ? selectedYear : 'Toutes les annÃƒÂ©es';
    	var html = '';
    
    	// === TABLEAU RÃƒâ€°CAPITULATIF DIABLO (existant) ===
    	html += '<div class="card" style="margin-top: 30px;">' +
        	    '<h4>Ã°Å¸â€œÅ  Tableau RÃƒÂ©capitulatif - Scores par Partie</h4>' +
            	'<div style="overflow-x: auto;">' +
            	'<table class="table" style="font-size: 12px;">' +
            	'<thead><tr><th>Joueur</th>';

    	var diabloRounds = rounds.filter(r => {
        	return r.type === 'diablo' && (!selectedYear || r.year == selectedYear);
    	});
    
    	diabloRounds.sort((a, b) => new Date(a.date) - new Date(b.date));
    
    	for (var i = 0; i < diabloRounds.length; i++) {
        	var round = diabloRounds[i];
        	var dateStr = round.date.split('-').reverse().join('/');
        	html += '<th style="writing-mode: vertical-rl; text-orientation: mixed; padding: 5px; min-width: 60px;">' + 
            	    dateStr + '</th>';
    	}
    
    	if (selectedYear && diabloRounds.length >= requiredGames) {
        	html += '<th style="background: #8b1a1a !important; color: white !important; font-weight: bold; text-align: center;">Total Diablo</th>';
    	}
    
    	html += '</tr></thead><tbody>';
    	    
    	    // Construire les donnÃƒÂ©es pour chaque joueur
    	    var playerDiabloData = {};
    	    
    	    for (var i = 0; i < diabloScores.length; i++) {
        	    var score = diabloScores[i];
        	    if (!playerDiabloData[score.playerId]) {
            	    var player = players.find(p => p.id === score.playerId);
            	    var playerName = player ? (player.name || (player.firstName + ' ' + player.lastName)) : ('Joueur #' + score.playerId);
            	    
            	    playerDiabloData[score.playerId] = {
                	    playerName: playerName,
                	    scores: {},
                	    totalNet: 0,
                	    totalDiff: 0,
                	    gamesPlayed: 0
            	    };
        	    }
        	    
        	    // Calculer le diffÃƒÂ©rentiel
        	    var round = rounds.find(r => r.id === score.roundId);
        	    var differential = calculateScoreDifferentialReal(score.score, round.course, score.tee);
        	    
        	    playerDiabloData[score.playerId].scores[score.roundId] = {
            	    score: score.score,
            	    net: score.net,
            	    differential: differential
        	    };
        	    
        	    playerDiabloData[score.playerId].totalNet += score.net;
        	    playerDiabloData[score.playerId].totalDiff += differential || 0;
        	    playerDiabloData[score.playerId].gamesPlayed++;
    	    }
    	    
    	    // Convertir en array et trier
    	    var playersArray = [];
    	    for (var playerId in playerDiabloData) {
        	    playersArray.push({
            	    playerId: parseInt(playerId),
            	    data: playerDiabloData[playerId]
        	    });
    	    }
    	    
    	    // Trier par moyenne net ou total selon l'annÃƒÂ©e
    	    if (selectedYear && diabloRounds.length >= requiredGames) {
        	    // Trier par total des 3 parties - ceux qui n'ont pas jouÃƒÂ© les 3 parties vont ÃƒÂ  la fin
        	    playersArray.sort((a, b) => {
            	    // Compter les parties jouÃƒÂ©es pour l'annÃƒÂ©e
            	    var aPlayed = 0;
            	    var bPlayed = 0;
            	    
            	    for (var i = 0; i < diabloRounds.length; i++) {
                	    if (a.data.scores[diabloRounds[i].id]) aPlayed++;
                	    if (b.data.scores[diabloRounds[i].id]) bPlayed++;
            	    }
            	    
            	    // Si un joueur n'a pas jouÃƒÂ© toutes les parties, il va ÃƒÂ  la fin (12e position)
            	    if (aPlayed < diabloRounds.length && bPlayed === diabloRounds.length) return 1;
            	    if (bPlayed < diabloRounds.length && aPlayed === diabloRounds.length) return -1;
            	    
            	    // Sinon, trier par total net
            	    return a.data.totalNet - b.data.totalNet;
        	    });
    	    } else {
        	    // Trier par moyenne
        	    playersArray.sort((a, b) => {
            	    var avgA = a.data.gamesPlayed > 0 ? a.data.totalNet / a.data.gamesPlayed : 999;
            	    var avgB = b.data.gamesPlayed > 0 ? b.data.totalNet / b.data.gamesPlayed : 999;
            	    return avgA - avgB;
        	    });
    	    }
    	    
    	    // Afficher les lignes
    	    for (var p = 0; p < playersArray.length; p++) {
        	    var playerData = playersArray[p];
        	    var data = playerData.data;
        	    
        	    // Style de ligne selon le rang
        	    var rowStyle = '';
        	    if (p === 0) rowStyle = ' style="background: #fff4e6;"'; // Or
        	    else if (p === 1) rowStyle = ' style="background: #f0f0f0;"'; // Argent
        	    else if (p === 2) rowStyle = ' style="background: #fff0e6;"'; // Bronze
        	    
        	    html += '<tr' + rowStyle + '><td><strong>' + (p + 1) + '. ' + data.playerName + '</strong></td>';
        	    
        	    // Scores pour chaque partie
        	    var partiesTotalNet = 0;
        	    var partiesTotalDiff = 0;
        	    var partiesCount = 0;
        	    
        	    for (var i = 0; i < diabloRounds.length; i++) {
            	    var round = diabloRounds[i];
            	    var scoreData = data.scores[round.id];
            	    
            	    if (scoreData) {
                	    // Obtenir le par du terrain
                	    var round = diabloRounds[i];
                	    var coursePar = 72; // Par dÃƒÂ©faut
                	    if (coursesDatabase[round.course]) {
                    	    var courseData = coursesDatabase[round.course];
                    	    var teeData = courseData.find(t => t.tee === (scoreData.tee || round.tee));
                    	    if (teeData && teeData.par) {
                        	    coursePar = teeData.par;
                    	    }
                	    }
                	    
                	    // Calculer le diffÃƒÂ©rentiel (score net - par)
                	    var differential = Math.round(scoreData.net) - coursePar;
                	    var differentialStr = differential > 0 ? '+' + differential : differential.toString();
                	    
                	    html += '<td style="text-align: center;">' +
                    	        '<span style="font-size: 16px; font-weight: bold;">' + differentialStr + '</span> ' +
                    	        '<span style="font-size: 12px;">(' + scoreData.score + ')</span></td>';
                    	        
                	    // Pour le calcul du total Diablo
                	    if (selectedYear) {
                    	    partiesTotalNet += scoreData.net;
                    	    partiesCount++;
                	    }
            	    } else {
                	    html += '<td style="text-align: center; color: #ccc;">-</td>';
            	    }
        	    }
        	    
        	    // Colonne Total si annÃƒÂ©e spÃƒÂ©cifique et au moins 3 parties
        	    if (selectedYear && diabloRounds.length >= requiredGames) {
            	    if (partiesCount === diabloRounds.length) {
                	    // Calculer le total des pars pour les parties jouÃƒÂ©es
                	    var totalPar = 0;
                	    var totalScore = 0;
                	    
                	    for (var i = 0; i < diabloRounds.length; i++) {
                    	    var round = diabloRounds[i];
                    	    var scoreData = data.scores[round.id];
                    	    
                    	    if (scoreData) {
                        	    totalScore += scoreData.score;
                        	    
                        	    // Obtenir le par du terrain
                        	    var coursePar = 72; // Par dÃƒÂ©faut
                        	    if (coursesDatabase[round.course]) {
                            	        var courseData = coursesDatabase[round.course];
                            	        var teeData = courseData.find(t => t.tee === (scoreData.tee || round.tee));
                            	        if (teeData && teeData.par) {
                                	        coursePar = teeData.par;
                            	        }
                        	    }
                        	    totalPar += coursePar;
                    	    }
                	    }
                	    
                	    // DiffÃƒÂ©rentiel total (score net total - par total)
                	    var totalDifferential = Math.round(partiesTotalNet) - totalPar;
                	    var totalDiffStr = totalDifferential > 0 ? '+' + totalDifferential : totalDifferential.toString();
                	    
                	    html += '<td style="text-align: center; background: #8b1a1a; color: white;">' +
                    	        '<span style="font-size: 20px; font-weight: bold;">' + totalDiffStr + '</span> ' +
                    	        '<span style="font-size: 14px;">(' + totalScore + ')</span></td>';
            	    } else {
                	    html += '<td style="text-align: center; background: #8b1a1a; color: #999;">-</td>';
            	    }
        	    }
        	    
        	    html += '</tr>';
    	    }
    	    
    	    html += '</tbody></table></div>' +
            		'<div style="margin-top: 10px; font-size: 12px; color: #666;">' +
            		'<strong>LÃƒÂ©gende:</strong> Score brut (DiffÃƒÂ©rentiel) | ' +
            		'Le diffÃƒÂ©rentiel mesure la performance relative au parcours' +
            		'</div></div>';
    
    		// === NOUVEAU : DÃƒâ€°TAILS DE CHAQUE PARTIE DIABLO ===
    		html += '<div class="card" style="margin-top: 30px;">' +
            		'<h4>Ã°Å¸â€œâ€¹ DÃƒÂ©tails de chaque Partie</h4>';

    		for (var i = 0; i < diabloRounds.length; i++) {
       			var round = diabloRounds[i];
        		var roundScores = scores.filter(s => s.roundId === round.id);
        
        		if (roundScores.length === 0) continue;
        
        		// Obtenir le par du terrain
        		var coursePar = 72; // Par dÃƒÂ©faut
        		if (coursesDatabase[round.course]) {
            		var courseData = coursesDatabase[round.course];
            		var teeData = courseData.find(t => t.tee === round.tee);
            		if (teeData && teeData.par) {
                		coursePar = teeData.par;
            		}
        		}
        
        		html += '<div style="margin: 15px 0; padding: 15px; border: 2px solid #8b1a1a; border-radius: 10px; background: #fff8f8;">' +
                		'<div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 15px;">' +
                		'<div>' +
                		'<strong style="color: #8b1a1a; font-size: 16px;">Ã°Å¸Ââ€  ' + round.date.split('-').reverse().join('/') + ' - ' + round.course + '</strong>' +
                		'<br><small>DÃƒÂ©part: ' + round.tee + ' | Par: ' + coursePar + ' | ' + roundScores.length + ' joueurs</small>' +
                		'</div>' +
                		'<button class="btn-secondary" onclick="toggleDiabloRoundDetail(\'diablo_round_' + round.id + '\')">Ã°Å¸â€˜ÂÃ¯Â¸Â Voir/Masquer</button>' +
                		'</div>';

        		html += '<div id="diablo_round_' + round.id + '" style="display: block;">' +
                		'<table class="table" style="font-size: 13px;">' +
                		'<thead>' +
                		'<tr style="background: #8b1a1a; color: white;">' +
                		'<th>Pos</th>' +
                		'<th>Joueur</th>' +
                		'<th>Score Brut</th>' +
                		'<th>Diff. Brut</th>' +
                		'<th>Hcp Parcours</th>' +
                		'<th>Score Net</th>' +
                		'<th>Diff. Net</th>' +
                		'<th>DiffÃƒÂ©rentiel</th>' +
                		'</tr>' +
                		'</thead>' +
                		'<tbody>';
        
        		// Trier par score net
        		roundScores.sort((a, b) => a.net - b.net);
        
        		for (var j = 0; j < roundScores.length; j++) {
            		var score = roundScores[j];
            
            		// Calculer les diffÃƒÂ©rentiels
            		var brutDiff = score.score - coursePar;
            		var netDiff = Math.round(score.net) - coursePar;
            		var differential = calculateScoreDifferentialReal(score.score, round.course, score.tee);
            
            		// Style pour le podium
            		var rowStyle = '';
            		if (j === 0) rowStyle = ' style="background: #fff4e6;"'; // Or
            		else if (j === 1) rowStyle = ' style="background: #f0f0f0;"'; // Argent
            		else if (j === 2) rowStyle = ' style="background: #fff0e6;"'; // Bronze
            
            		// Formatage des diffÃƒÂ©rentiels
            		var brutDiffStr = brutDiff > 0 ? '+' + brutDiff : brutDiff.toString();
            		var netDiffStr = netDiff > 0 ? '+' + netDiff : netDiff.toString();
            		var diffStr = differential ? differential.toFixed(1) : 'N/A';
            
            		// IcÃƒÂ´ne selon la position
            		var posIcon = '';
            		if (j === 0) posIcon = 'Ã°Å¸Â¥â€¡ ';
            		else if (j === 1) posIcon = 'Ã°Å¸Â¥Ë† ';
            		else if (j === 2) posIcon = 'Ã°Å¸Â¥â€° ';
            
            		html += '<tr' + rowStyle + '>' +
                    		'<td><strong>' + posIcon + (j + 1) + '</strong></td>' +
                    		'<td><strong>' + score.playerName + '</strong></td>' +
                    		'<td style="text-align: center; font-weight: bold;">' + score.score + '</td>' +
                    		'<td style="text-align: center; color: ' + (brutDiff < 0 ? '#28a745' : brutDiff > 0 ? '#dc3545' : '#333') + ';">' +
                    		'<strong>' + brutDiffStr + '</strong></td>' +
                    		'<td style="text-align: center;">' + score.courseHandicap.toFixed(1) + '</td>' +
                    		'<td style="text-align: center; font-weight: bold; color: #8b1a1a;">' + Math.round(score.net) + '</td>' +
                    		'<td style="text-align: center; color: ' + (netDiff < 0 ? '#28a745' : netDiff > 0 ? '#dc3545' : '#333') + ';">' +
                    		'<strong>' + netDiffStr + '</strong></td>' +
                    		'<td style="text-align: center;">' + diffStr + '</td>' +
                    		'</tr>';
        		}
        
        		html += '</tbody></table>';
        
        		// Statistiques de la partie
        		var avgBrut = roundScores.reduce((sum, s) => sum + s.score, 0) / roundScores.length;
        		var avgNet = roundScores.reduce((sum, s) => sum + s.net, 0) / roundScores.length;
        		var bestBrut = Math.min(...roundScores.map(s => s.score));
        		var bestNet = Math.min(...roundScores.map(s => s.net));
        
        		html += '<div style="margin-top: 10px; padding: 10px; background: #ffe8e8; border-radius: 5px; font-size: 12px;">' +
                		'<strong>Ã°Å¸â€œÅ  Statistiques de la partie:</strong><br>' +
                		'<div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(150px, 1fr)); gap: 10px; margin-top: 5px;">' +
                		'<div>Ã°Å¸ÂÅ’Ã¯Â¸Â Meilleur brut: <strong>' + bestBrut + '</strong></div>' +
                		'<div>Ã°Å¸Å½Â¯ Meilleur net: <strong>' + Math.round(bestNet) + '</strong></div>' +
                		'<div>Ã°Å¸â€œË† Moyenne brut: <strong>' + avgBrut.toFixed(1) + '</strong></div>' +
                		'<div>Ã°Å¸â€œÅ  Moyenne net: <strong>' + avgNet.toFixed(1) + '</strong></div>' +
                		'</div>' +
                		'</div>';
        
        		html += '</div></div>';
    		}
    
    		// Statistiques globales du tournoi
    		if (diabloRounds.length > 0) {
        		html += '<div style="margin-top: 20px; padding: 15px; background: #8b1a1a; color: white; border-radius: 8px;">' +
                		'<h5 style="margin: 0 0 10px 0;">Ã°Å¸Ââ€  RÃƒÂ©sumÃƒÂ© du Tournoi Diablo ' + yearText + '</h5>' +
                		'<div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(200px, 1fr)); gap: 15px;">' +
                		'<div>Ã°Å¸â€œâ€¦ Nombre de parties: <strong>' + diabloRounds.length + '</strong></div>' +
                		'<div>Ã°Å¸â€˜Â¥ Participants uniques: <strong>' + leaderboard.length + '</strong></div>' +
                		'<div>Ã°Å¸Â¥â€¡ Leader actuel: <strong>' + (leaderboard[0] ? leaderboard[0].playerName : 'N/A') + '</strong></div>' +
                		'<div>Ã°Å¸Å½Â¯ Meilleur moyenne net: <strong>' + (leaderboard[0] ? leaderboard[0].avgNet.toFixed(1) : 'N/A') + '</strong></div>' +
                		'</div>' +
                		'</div>';
    		}
    
    		html += '</div>';
    
    		
    	// ===== CHAMPIONS DIABLO 2026+ =====
    	if (isNewFormat && selectedYear && diabloRounds.length >= requiredGames) {
        	// Trouver les joueurs Ã©ligibles (ayant jouÃ© toutes les parties)
        	var eligiblePlayers = playersArray.filter(function(p) {
            	var gamesPlayed = 0;
            	for (var i = 0; i < diabloRounds.length; i++) {
                	if (p.data.scores[diabloRounds[i].id]) gamesPlayed++;
            	}
            	return gamesPlayed >= requiredGames;
        	});
        	
        	if (eligiblePlayers.length > 0) {
            	// Calculer totaux brut et net
            	eligiblePlayers.forEach(function(p) {
                	p.totalBrut = 0;
                	p.totalNet = 0;
                	for (var i = 0; i < diabloRounds.length; i++) {
                    	var scoreData = p.data.scores[diabloRounds[i].id];
                    	if (scoreData) {
                        	p.totalBrut += scoreData.score;
                        	p.totalNet += scoreData.net;
                    	}
                	}
            	});
            	
            	// Trier pour champion brut (score le plus bas)
            	var brutRanking = [...eligiblePlayers].sort((a, b) => a.totalBrut - b.totalBrut);
            	var champBrut = brutRanking[0];
            	
            	// Trier pour champion net (score le plus bas)
            	var netRanking = [...eligiblePlayers].sort((a, b) => a.totalNet - b.totalNet);
            	var champNet = netRanking[0];
            	
            	var sameChampion = champBrut.playerId === champNet.playerId;
            	
            	html += '<div class="card" style="margin-top: 30px; background: linear-gradient(135deg, #8b1a1a, #c0392b); color: white;">';
            	html += '<h3 style="text-align: center; margin-bottom: 20px;">ğŸ† CHAMPIONS DIABLO ' + selectedYear + ' ğŸ†</h3>';
            	
            	if (sameChampion) {
                	// Double champion
                	html += '<div class="champion-card double" style="margin: 0 auto; max-width: 400px;">';
                	html += '<div class="champion-title">â­ DOUBLE CHAMPION â­</div>';
                	html += '<div class="champion-name">' + champBrut.data.playerName + '</div>';
                	html += '<div style="display: flex; justify-content: center; gap: 40px;">';
                	html += '<div><div class="champion-title">Score Brut</div><div class="champion-score">' + champBrut.totalBrut + '</div></div>';
                	html += '<div><div class="champion-title">Score Net</div><div class="champion-score">' + Math.round(champNet.totalNet) + '</div></div>';
                	html += '</div></div>';
            	} else {
                	// Deux champions diffÃ©rents
                	html += '<div class="champions-grid">';
                	html += '<div class="champion-card brut">';
                	html += '<div class="champion-title">ğŸ¥ˆ CHAMPION BRUT</div>';
                	html += '<div class="champion-name">' + champBrut.data.playerName + '</div>';
                	html += '<div class="champion-score">' + champBrut.totalBrut + ' coups</div>';
                	html += '</div>';
                	html += '<div class="champion-card net">';
                	html += '<div class="champion-title">ğŸ¥‡ CHAMPION NET</div>';
                	html += '<div class="champion-name">' + champNet.data.playerName + '</div>';
                	html += '<div class="champion-score">' + Math.round(champNet.totalNet) + ' coups</div>';
                	html += '</div>';
                	html += '</div>';
            	}
            	
            	html += '<p style="text-align: center; margin-top: 15px; font-size: 14px; opacity: 0.9;">Format 2026+: 2 jours consÃ©cutifs</p>';
            	html += '</div>';
        	}
    	}
    	
document.getElementById('diabloContent').innerHTML = html;
		}

		// Fonction pour afficher/masquer les dÃƒÂ©tails d'une partie Diablo
		function toggleDiabloRoundDetail(roundId) {
    		var element = document.getElementById(roundId);
    		if (element.style.display === 'none') {
        		element.style.display = 'block';
    		} else {
        		element.style.display = 'none';
    		}
		}

	// FONCTION loadGPR
	function loadGPR() {
	    loadYearSelectors();
    	console.log('=== DÃƒâ€°BUT loadGPR ===');

    	// DÃƒâ€°CLARER TOUTES LES VARIABLES AU DÃƒâ€°BUT DE LA FONCTION
    	playerPoints = {};
    	playerBest4Points = {};
    	roundDetails = [];

    	var selectedYear = document.getElementById('gprYearSelect').value;

    	var gprScores = scores.filter(s => {
        	return s.type === 'gpr' && (!selectedYear || s.year == selectedYear);
    	});

    	if (gprScores.length === 0) {
        	document.getElementById('gprContent').innerHTML = '<p>Aucune partie GPR trouvÃƒÂ©e pour cette pÃƒÂ©riode.</p>';
        	document.getElementById('gprStatus').innerHTML = '';
        	return;
    	}

    	updateGPRStatus(selectedYear);

    	var gprRounds = rounds.filter(r => {
        	return r.type === 'gpr' && (!selectedYear || r.year == selectedYear);
    	});
    
    	console.log('=== FILTRAGE PAR ANNÃƒâ€°E ===');
    	console.log('AnnÃƒÂ©e sÃƒÂ©lectionnÃƒÂ©e:', selectedYear);
    	console.log('Scores GPR trouvÃƒÂ©s:', gprScores.length);

    	// SÃƒÂ©parer les parties Exhibition et Finale
    	var exhibitionRounds = gprRounds.filter(r => !r.gprPhase || r.gprPhase === 'exhibition');
    	var finaleRounds = gprRounds.filter(r => r.gprPhase === 'finale');
    
    	// Pour le tableau rÃƒÂ©capitulatif, on veut TOUTES les finales si "Toutes les annÃƒÂ©es"
    	var allFinaleRoundsForTable = finaleRounds;
    	if (!selectedYear) {
        	// Si "Toutes les annÃƒÂ©es", prendre toutes les finales GPR
        	allFinaleRoundsForTable = rounds.filter(r => 
            	r.type === 'gpr' && 
            	r.gprPhase === 'finale'
        	);
    	}
    
    	console.log('Finales pour le tableau:', allFinaleRoundsForTable.length);
    	console.log('=== SÃƒâ€°PARATION DES ROUNDS GPR ===');
    	console.log('Total rounds GPR:', gprRounds.length);
    	console.log('Rounds exhibition:', exhibitionRounds.length);
    	console.log('Rounds finale:', finaleRounds.length);

    	// IMPORTANT : Filtrer pour avoir SEULEMENT les vraies exhibitions (pas les finales)
    	exhibitionRounds = exhibitionRounds.filter(r => r.gprPhase !== 'finale');
    	console.log('Rounds exhibition aprÃƒÂ¨s filtrage:', exhibitionRounds.length);

    	// === TRAITEMENT DES PARTIES EXHIBITION ===
    	var pointsScale = [120, 105, 90, 78, 70, 62, 54, 46, 38, 30, 22, 15];
    	var grossPointsScale = [80, 68, 60, 52, 45, 40, 35, 30, 25, 20, 15, 10];

    	// Points pour les finales
    	var finaleNetPointsScale = [225, 190, 165, 140, 125, 110, 90, 75, 60, 45, 35, 25];
    	var finaleBrutPointsScale = [175, 140, 120, 100, 85, 70, 60, 50, 40, 30, 20, 10];

    	for (var i = 0; i < exhibitionRounds.length; i++) {
        	var round = exhibitionRounds[i];
        	var roundScores = gprScores.filter(s => s.roundId === round.id && s.playerId !== 13);

        	// Identifier TOUS les joueurs GPR de l'annÃƒÂ©e (pour les absents)
        	var allGPRPlayers = scores.filter(s => 
            	s.year === round.year && 
            	s.type === 'gpr' && 
            	s.playerId !== 13
        	).map(s => s.playerId).filter((v, i, a) => a.indexOf(v) === i);

        	// Ajouter les absents avec score fictif ÃƒÂ©levÃƒÂ©
        	var presentPlayers = roundScores.map(s => s.playerId);
        	for (var p = 0; p < allGPRPlayers.length; p++) {
            	var playerId = allGPRPlayers[p];
            	if (!presentPlayers.includes(playerId)) {
                	var player = players.find(p => p.id === playerId);
                	// Ajouter un score fictif pour l'absent
                	roundScores.push({
                    	playerId: playerId,
                    	playerName: player.name || (player.firstName + ' ' + player.lastName),
                    	score: 999, // Score trÃƒÂ¨s ÃƒÂ©levÃƒÂ©
                    	net: 999,   // Net trÃƒÂ¨s ÃƒÂ©levÃƒÂ©
                    	absent: true
                	});
            	}
        	}

        	console.log('Partie du', round.date, '- Joueurs:', roundScores.length, '(dont absents)');

        	// Classement par score net avec gestion des ex-ÃƒÂ¦quo
        	var netGroups = {};
        	roundScores.forEach(function(score, index) {
            	var netValue = score.net;
            	if (!netGroups[netValue]) {
                	netGroups[netValue] = [];
            	}
            	netGroups[netValue].push({score: score, originalIndex: index});
        	});

        	// Trier les groupes
        	var sortedNetGroups = Object.keys(netGroups).sort((a, b) => parseFloat(a) - parseFloat(b));

        	var netRanking = [];
        	var currentPosition = 0;

        	for (var g = 0; g < sortedNetGroups.length; g++) {
            	var group = netGroups[sortedNetGroups[g]];
            	var totalPoints = 0;

            	// Calculer les points totaux pour ce groupe
            	for (var j = 0; j < group.length; j++) {
                	totalPoints += pointsScale[Math.min(currentPosition + j, pointsScale.length - 1)];
            	}

            	var pointsPerPlayer = Math.round(totalPoints / group.length);

            	// Attribuer les points
            	for (var j = 0; j < group.length; j++) {
                	netRanking.push({
                    	player: group[j].score,
                    	position: currentPosition + 1,
                    	points: pointsPerPlayer
                	});
            	}

            	currentPosition += group.length;
        	}

        	// Faire la mÃƒÂªme chose pour le classement brut
        	var grossGroups = {};
        	roundScores.forEach(function(score, index) {
            	var grossValue = score.score;
            	if (!grossGroups[grossValue]) {
                	grossGroups[grossValue] = [];
            	}
            	grossGroups[grossValue].push({score: score, originalIndex: index});
        	});

        	var sortedGrossGroups = Object.keys(grossGroups).sort((a, b) => parseFloat(a) - parseFloat(b));

        	var grossRanking = [];
        	currentPosition = 0;

        	for (var g = 0; g < sortedGrossGroups.length; g++) {
            	var group = grossGroups[sortedGrossGroups[g]];
            	var totalPoints = 0;

            	for (var j = 0; j < group.length; j++) {
                	totalPoints += grossPointsScale[Math.min(currentPosition + j, grossPointsScale.length - 1)];
            	}

            	var pointsPerPlayer = Math.round(totalPoints / group.length);

            	for (var j = 0; j < group.length; j++) {
                	grossRanking.push({
                    	player: group[j].score,
                    	position: currentPosition + 1,
                    	points: pointsPerPlayer
                	});
            	}

            	currentPosition += group.length;
        	}

        	// CRÃƒâ€°ER LE ROUNDDETAIL
        	var roundDetail = {
            	round: round,
            	netRanking: netRanking,
            	grossRanking: grossRanking,
            	isExhibition: true,
            	isFinale: false
        	};

        	roundDetails.push(roundDetail);

        	// ACCUMULER LES POINTS POUR CHAQUE JOUEUR
        	for (var k = 0; k < roundScores.length; k++) {
            	var score = roundScores[k];

            	// Ne pas Ignorer les absents - ils doivent recevoir leur points!
                    
            	if (!playerPoints[score.playerId]) {
                	var player = players.find(p => p.id === score.playerId);
                	var playerName = player ? (player.name || (player.firstName + ' ' + player.lastName)) : ('Joueur #' + score.playerId);

                	playerPoints[score.playerId] = {
                    	player: player,
                    	playerName: playerName,
                    	totalPoints: 0,
                    	rounds: 0,
                    	exhibitionPoints: 0,
                    	finalePoints: 0,
                    	details: []
                	};
            	}

            	if (!playerBest4Points[score.playerId]) {
                	var player = players.find(p => p.id === score.playerId);
                	var playerName = player ? (player.name || (player.firstName + ' ' + player.lastName)) : ('Joueur #' + score.playerId);

                	playerBest4Points[score.playerId] = {
                    	player: player,
                    	playerName: playerName,
                    	best4Points: 0,
                    	finalePoints: 0,
                    	totalBest4: 0,
                    	best4Details: []
                	};
            	}

            	// Trouver les points pour ce joueur dans cette partie
            	var netResult = netRanking.find(r => r.player.playerId === score.playerId);
            	var grossResult = grossRanking.find(r => r.player.playerId === score.playerId);

            	var netPoints = netResult ? netResult.points : 0;
            	var grossPoints = grossResult ? grossResult.points : 0;
            	var totalRoundPoints = netPoints + grossPoints;

            	playerPoints[score.playerId].totalPoints += totalRoundPoints;
            	playerPoints[score.playerId].exhibitionPoints += totalRoundPoints;
            	playerPoints[score.playerId].rounds++;

            	// Stocker les dÃƒÂ©tails de cette partie exhibition
            	playerPoints[score.playerId].details.push({
                	round: round,
                	grossScore: score.score,
                	netScore: score.net,
                	grossPosition: grossResult ? grossResult.position : '-',
                	netPosition: netResult ? netResult.position : '-',
                	grossPoints: grossPoints,
                	netPoints: netPoints,
                	totalRoundPoints: totalRoundPoints,
                	courseHandicap: score.courseHandicap,
                	type: 'exhibition'
            	});
        	}
    	} // FIN DE LA BOUCLE DES EXHIBITIONS

    	// === CALCUL DES 4 MEILLEURES PARTIES ===
		var yearToCalculate = selectedYear ? parseInt(selectedYear) : new Date().getFullYear();
		console.log('AnnÃƒÂ©e pour calcul best4:', yearToCalculate, 'Type:', typeof yearToCalculate);
    	console.log('=== DEBUG CALCUL FINALE ===');
    	console.log('AnnÃƒÂ©e pour calcul finale:', yearToCalculate);
    	console.log('Type de yearToCalculate:', typeof yearToCalculate);
    	console.log('selectedYear:', selectedYear, 'type:', typeof selectedYear);
    
    	// DEBUG: VÃƒÂ©rifier les finales
    	console.log('=== DEBUG FINALES ===');
    	console.log('AnnÃƒÂ©e calculÃƒÂ©e:', yearToCalculate);
    	var testFinaleRounds = rounds.filter(r => r.year === yearToCalculate && r.gprPhase === 'finale');
    	console.log('Parties finale trouvÃƒÂ©es:', testFinaleRounds);
    
    	for (var playerId in playerPoints) {
    		var playerIdInt = parseInt(playerId);
    
    		// S'assurer que playerBest4Points[playerId] existe
    		if (!playerBest4Points[playerId]) {
        		var player = players.find(p => p.id === playerIdInt);
        		playerBest4Points[playerId] = {
            		player: player,
            		playerName: player.name || (player.firstName + ' ' + player.lastName),
            		best4Points: 0,
            		finalePoints: 0,
            		totalBest4: 0,
            		best4Details: []
        		};
    		}
    
    		// Calculer les 4 meilleures exhibitions
    		var yearForCalculation = selectedYear ? parseInt(selectedYear) : new Date().getFullYear();
    		var best4Results = calculateBest4Exhibition(playerIdInt, yearForCalculation);
    
    		console.log('Calcul best4 pour joueur', playerId, 'annÃƒÂ©e', yearForCalculation, ':', best4Results.length, 'parties');
    
    		var best4Total = 0;
    		playerBest4Points[playerId].best4Details = []; // RÃƒÂ©initialiser
    
    		for (var i = 0; i < best4Results.length; i++) {
        		best4Total += best4Results[i].totalPoints;
        
        		playerBest4Points[playerId].best4Details.push({
            		round: rounds.find(r => r.id === best4Results[i].roundId),
            		grossScore: best4Results[i].score.score,
            		netScore: best4Results[i].score.net,
            		grossPosition: best4Results[i].brutPos,
            		netPosition: best4Results[i].netPos,
            		grossPoints: best4Results[i].brutPoints,
            		netPoints: best4Results[i].netPoints,
            		totalRoundPoints: best4Results[i].totalPoints,
            		isSelected: true,
            		roundId: best4Results[i].roundId // Ajouter l'ID pour faciliter la vÃƒÂ©rification
        		});
    		}
    
    		playerBest4Points[playerId].best4Points = best4Total;
    		playerBest4Points[playerId].totalBest4 = best4Total;
    
    		console.log('Best4 total pour', playerBest4Points[playerId].playerName, ':', best4Total);
		}

    	// === TRAITEMENT DES FINALES (400 POINTS FIXES) ===
    	if (finaleRounds.length > 0) {
        	var finaleResults = calculateFinaleScores(yearToCalculate);

        	// Ajouter les points finale aux totaux des joueurs
        	for (var playerId in finaleResults) {
            	var finaleData = finaleResults[playerId];

            	if (!playerPoints[playerId]) {
                	playerPoints[playerId] = {
                    	player: finaleData.player,
                    	playerName: finaleData.player.name || (finaleData.player.firstName + ' ' + finaleData.player.lastName),
                    	totalPoints: 0,
                    	rounds: 0,
                    	exhibitionPoints: 0,
                    	finalePoints: 0,
                    	details: []
                	};
            	}

            	if (!playerBest4Points[playerId]) {
                	playerBest4Points[playerId] = {
                    	player: finaleData.player,
                    	playerName: finaleData.player.name || (finaleData.player.firstName + ' ' + finaleData.player.lastName),
                    	best4Points: 0,
                    	finalePoints: 0,
                    	totalBest4: 0,
                    	best4Details: []
                	};
            	}

            	// Les points finale sont dÃƒÂ©jÃƒÂ  corrects (400 points total)
            	var finalePoints = finaleData.totalPointsFinale || 0;
            	console.log('=== DEBUG MULTIPLICATION ===');
            	console.log('Joueur:', finaleData.player.name);
            	console.log('finaleData.totalPointsFinale:', finaleData.totalPointsFinale);
            	console.log('finaleData.daysPlayed:', finaleData.daysPlayed);
            	console.log('finalePoints utilisÃƒÂ©s:', finalePoints);

            	console.log('Joueur', finaleData.player.name, 'Points finale:', finalePoints);

            	playerPoints[playerId].totalPoints += finalePoints;
            	playerPoints[playerId].finalePoints = finalePoints;

            	playerBest4Points[playerId].finalePoints = finalePoints;
            	playerBest4Points[playerId].totalBest4 += finalePoints;

            	// Ajouter dÃƒÂ©tail finale
            	var finaleDetail = {
                	type: 'finale',
                	totalBrut: finaleData.totalBrut,
                	totalNet: finaleData.totalNet,
                	daysPlayed: finaleData.daysPlayed,
                	brutPosition: finaleData.positionBrut,
                	netPosition: finaleData.positionNet,
                	brutPoints: finaleData.pointsBrut,
                	netPoints: finaleData.pointsNet,
               		totalRoundPoints: finalePoints,
                	absent: finaleData.daysPlayed === 0
            	};

            	playerPoints[playerId].details.push(finaleDetail);
        	}

        	// Debug
        	console.log('=== VÃƒâ€°RIFICATION FINALE GPR ===');
        	var totalPointsDistribues = 0;
        	for (var playerId in finaleResults) {
            	totalPointsDistribues += finaleResults[playerId].totalPointsFinale || 0;
        	}
        	console.log('Total points finale distribuÃƒÂ©s:', totalPointsDistribues);

        	// Debug pour voir qui manque
        	console.log('=== DEBUG JOUEURS MANQUANTS ===');
        	for (var playerId in finaleResults) {
            	if (!playerPoints[playerId]) {
                	console.log('Joueur manquant dans playerPoints:', playerId, finaleResults[playerId].player.name);
            	}
        	}

        	// Ajouter les joueurs qui ont SEULEMENT des points de finale (absents ÃƒÂ  toutes les exhibitions)
        	for (var playerId in finaleResults) {
            	if (!playerPoints[playerId]) {
                	var finaleData = finaleResults[playerId];

                	playerPoints[playerId] = {
                    	player: finaleData.player,
                    	playerName: finaleData.player.name || (finaleData.player.firstName + ' ' + finaleData.player.lastName),
                    	totalPoints: 0,
                    	rounds: 0,
                    	exhibitionPoints: 0,
                    	finalePoints: 0,
                    	details: []
                	};

                	console.log('Ajout joueur absent exhibitions:', playerPoints[playerId].playerName);
            	}

            	if (!playerBest4Points[playerId]) {
                	var finaleData = finaleResults[playerId];

                	playerBest4Points[playerId] = {
                    	player: finaleData.player,
                    	playerName: finaleData.player.name || (finaleData.player.firstName + ' ' + finaleData.player.lastName),
                    	best4Points: 0,
                    	finalePoints: 0,
                    	totalBest4: 0,
                    	best4Details: []
                	};
            	}
        	}
    	}

    	// CrÃƒÂ©er les classements
    	var leaderboardComplete = [];
    	var leaderboardBest4 = [];

    	for (var playerId in playerPoints) {
        	var stats = playerPoints[playerId];
        	leaderboardComplete.push({
            	player: stats.player,
            	playerName: stats.playerName,
            	rounds: stats.rounds,
            	totalPoints: stats.totalPoints,
            	exhibitionPoints: stats.exhibitionPoints,
            	finalePoints: stats.finalePoints,
            	details: stats.details,
            	averagePoints: stats.rounds > 0 ? stats.totalPoints / stats.rounds : 0
        	});
    	}

    	for (var playerId in playerBest4Points) {
        	var stats = playerBest4Points[playerId];
        	leaderboardBest4.push({
            	player: stats.player,
            	playerName: stats.playerName,
            	best4Points: stats.best4Points,
            	finalePoints: stats.finalePoints,
            	totalBest4: stats.totalBest4,
            	best4Details: stats.best4Details,
            	partiesCount: stats.best4Details.length
        	});
    	}

    	leaderboardComplete.sort((a, b) => b.totalPoints - a.totalPoints);
    	leaderboardBest4.sort((a, b) => b.totalBest4 - a.totalBest4);

    	var yearText = selectedYear ? selectedYear : 'Toutes les annÃƒÂ©es';

    	// Affichage du classement gÃƒÂ©nÃƒÂ©ral
    	var html = '<div class="card"><h3>Coupe GPR - ' + yearText
        	       
    	// === TABLEAU RÃƒâ€°CAPITULATIF DES POINTS PAR PARTIE ===
    	html += '<div class="card">' +
        	    '<h4>Ã°Å¸â€œÅ  Tableau RÃƒÂ©capitulatif - Points par Partie</h4>' +
            	'<p style="font-size: 14px; color: #666;">Les 4 meilleures parties d\'exhibition sont marquÃƒÂ©es d\'une Ã¢Â­Â et en cas de diffÃƒÂ©rence le Guever a toujours raison</p>' +
            	'<div style="overflow-x: auto;">' +
            	'<table class="table" style="font-size: 12px;">' +
            	'<thead><tr><th>Joueur</th>';

    	// Combiner toutes les parties (exhibitions + finales) et trier par date
    	var allGameRounds = [];
    	
    	// Ajouter les exhibitions
    	for (var i = 0; i < exhibitionRounds.length; i++) {
        	var round = exhibitionRounds[i];
        	allGameRounds.push({
            	round: round,
            	type: 'exhibition',
            	date: round.date,
            	dateObj: new Date(round.date)
        	});
    	}
    	
    	// Ajouter les finales
    	for (var i = 0; i < allFinaleRoundsForTable.length; i++) {
        	var finaleRound = allFinaleRoundsForTable[i];
        	allGameRounds.push({
            	round: finaleRound,
            	type: 'finale',
            	date: finaleRound.date,
            	dateObj: new Date(finaleRound.date)
        	});
    	}
    	
    	// Trier par date chronologique
    	allGameRounds.sort((a, b) => a.dateObj - b.dateObj);

    	// En-tÃƒÂªtes des colonnes (toutes les parties par ordre chronologique)
		for (var i = 0; i < allGameRounds.length; i++) {
    		var gameRound = allGameRounds[i];
    		var dateStr = gameRound.date.split('-').reverse().join('/');
    
    		if (gameRound.type === 'finale') {
        		var year = gameRound.round.year;
        		html += '<th style="background: #1e3a8a; color: white; font-weight: bold; text-align: center; padding: 8px;">Finale ' + year + '<br>' + dateStr + '</th>';
    		} else {
        		html += '<th style="writing-mode: vertical-rl; text-orientation: mixed; padding: 5px; min-width: 60px;">' + dateStr + '</th>';
    		}
		}

		// Ajouter les colonnes Best4 et Total SEULEMENT si une annÃƒÂ©e spÃƒÂ©cifique est sÃƒÂ©lectionnÃƒÂ©e
		if (selectedYear) {
    		html += '<th style="background: #ff6b35; color: white; font-weight: bold; text-align: center;">Best 4</th>';
    		html += '<th style="background: #8b1a1a; color: white; font-weight: bold; text-align: center;">Total</th>';
		}

		html += '</tr></thead><tbody>';

    	// Trier les joueurs par total de points dÃƒÂ©croissant
    	var allPlayers = Object.keys(playerPoints).map(id => ({
        	id: parseInt(id),
        	data: playerPoints[id],
        	best4Data: playerBest4Points[id]
    	}));
    	
    	// Trier selon que c'est une annÃƒÂ©e spÃƒÂ©cifique ou toutes les annÃƒÂ©es
    	if (selectedYear) {
        	// Pour une annÃƒÂ©e spÃƒÂ©cifique, trier par Best4 + Finale
        	allPlayers.sort((a, b) => {
            	var totalA = (a.best4Data ? (a.best4Data.best4Points + a.best4Data.finalePoints) : 0);
            	var totalB = (b.best4Data ? (b.best4Data.best4Points + b.best4Data.finalePoints) : 0);
            	return totalB - totalA;
        	});
    	} else {
        	// Pour toutes les annÃƒÂ©es, trier par total de tous les points
        	allPlayers.sort((a, b) => b.data.totalPoints - a.data.totalPoints);
    	}

    	// Lignes pour chaque joueur
    	for (var p = 0; p < allPlayers.length; p++) {
        	var playerData = allPlayers[p];
        	var playerId = playerData.id;
        	var player = playerData.data;
        	var best4Info = playerData.best4Data;

        	// Style de ligne selon le rang
        	var rowStyle = '';
        	if (p === 0) rowStyle = ' style="background: #fff4e6;"'; // Or
        	else if (p === 1) rowStyle = ' style="background: #f0f0f0;"'; // Argent
        	else if (p === 2) rowStyle = ' style="background: #fff0e6;"'; // Bronze

        	html += '<tr' + rowStyle + '><td><strong>' + (p + 1) + '. ' + player.playerName + '</strong></td>';

        	// Points pour chaque partie dans l'ordre chronologique
			for (var i = 0; i < allGameRounds.length; i++) {
    			var gameRound = allGameRounds[i];
    
    			if (gameRound.type === 'exhibition') {
        			// Traitement des parties exhibition
        			var round = gameRound.round;
        			var roundDetail = roundDetails.find(rd => rd.round.id === round.id);

        			// Chercher si le joueur a participÃƒÂ©
        			var netResult = roundDetail ? roundDetail.netRanking.find(r => r.player.playerId === playerId) : null;
        			var grossResult = roundDetail ? roundDetail.grossRanking.find(r => r.player.playerId === playerId) : null;

        			if (netResult || grossResult) {
            			var netPts = netResult ? netResult.points : 0;
            			var grossPts = grossResult ? grossResult.points : 0;
            			var total = Math.round(netPts + grossPts);
            			var isAbsent = netResult && netResult.player.absent;
    
            			// Style pour les absents
            			var cellStyle = 'text-align: center;';
            			if (isAbsent) {
                			cellStyle += ' font-style: italic; color: #999;';
            			}
    
            			// Afficher les ÃƒÂ©toiles et barrÃƒÂ©s SEULEMENT si une annÃƒÂ©e est sÃƒÂ©lectionnÃƒÂ©e
            			if (selectedYear) {
                			// VÃƒÂ©rifier si cette partie fait partie des 4 meilleures
                			var isBest4 = false;
                			var best4Info = playerBest4Points[playerId];
        
                			if (best4Info && best4Info.best4Details) {
                    			isBest4 = best4Info.best4Details.some(detail => 
                        			detail.roundId === round.id
                    			);
                			}
        
                			// Barrer si plus de 4 parties et pas dans best4
                			if (!isAbsent && best4Info && best4Info.best4Details.length >= 4 && !isBest4) {
                    			cellStyle += ' text-decoration: line-through; color: #ccc;';
                			}
        
                			html += '<td style="' + cellStyle + '">' + 
                        			(isBest4 ? 'Ã¢Â­Â ' : '') + total + 
                        			'<br><small>(' + Math.round(grossPts) + '+' + Math.round(netPts) + ')</small></td>';
            			} else {
                			// Pas d'ÃƒÂ©toiles ni de barrÃƒÂ©s pour "Toutes les annÃƒÂ©es"
                			html += '<td style="' + cellStyle + '">' + 
                        			total + 
                        			'<br><small>(' + Math.round(grossPts) + '+' + Math.round(netPts) + ')</small></td>';
            			}
        			} else {
            			html += '<td style="text-align: center; color: #ccc;">-</td>';
        			}
    
    			} else if (gameRound.type === 'finale') {
        			// Traitement des parties finale
        			var finaleRound = gameRound.round;
        			var year = finaleRound.year;

        			// Chercher les points de cette annÃƒÂ©e de finale
        			var finaleDetail = player.details.find(d => 
            			d.type === 'finale' && 
            			rounds.find(r => r.year == year && r.gprPhase === 'finale')
        			);

        			if (finaleDetail && finaleRound.year == year) {
            			var brutPts = Math.round(finaleDetail.brutPoints || 0);
            			var netPts = Math.round(finaleDetail.netPoints || 0);
            			// Pour finale multi-jours, diviser par le nombre de jours
            			var nbJoursFinale = allFinaleRoundsForTable.filter(r => r.year == year).length;
            			var totalPts = Math.round((finaleDetail.brutPoints + finaleDetail.netPoints) / nbJoursFinale);

            			html += '<td style="text-align: center; background: #1e3a8a; color: white; font-size: 16px; font-weight: bold;' + 
                    			(finaleDetail.absent ? ' font-style: italic; opacity: 0.7;' : '') + '">' +
                    			totalPts + '<br>' +
                    			'<small style="color: #cbd5e1; font-weight: normal;">(' + Math.round(brutPts/nbJoursFinale) + '+' + Math.round(netPts/nbJoursFinale) + ')</small></td>';
        			} else {
            			html += '<td style="text-align: center; background: #1e3a8a; color: #64748b; font-size: 16px; font-weight: bold;">-</td>';
        			}
    			}
			}

			// Afficher Best4 et Total SEULEMENT si une annÃƒÂ©e spÃƒÂ©cifique est sÃƒÂ©lectionnÃƒÂ©e
			if (selectedYear) {
    			// Total Best 4
    			var playerBest4Info = playerBest4Points[playerId];
    			var best4Points = playerBest4Info ? playerBest4Info.best4Points : 0;
    			var finalePoints = playerBest4Info ? playerBest4Info.finalePoints : 0;
    			
    			html += '<td style="text-align: center; background: #ff6b35; color: white; font-size: 16px; font-weight: bold;">' + 
            			Math.round(best4Points) + '</td>';
    
    			// Total FINAL = Best 4 + Finale (c'est ce qui dÃƒÂ©termine le vainqueur)
    			var totalFinal = best4Points + finalePoints;
    			html += '<td style="text-align: center; background: #8b1a1a; color: white; font-size: 16px; font-weight: bold;">' + 
            			Math.round(totalFinal) + '</td>';
			}

			html += '</tr>';
    	}

    	html += '</tbody></table></div>' +
        	    '<div style="margin-top: 10px; font-size: 12px; color: #666;">' +
            	'<strong>LÃƒÂ©gende:</strong> Total (Brut+Net) | <em>Italique = Absent</em>' +
				(selectedYear ? ' | Ã¢Â­Â = Compte dans les 4 meilleures | <s>BarrÃƒÂ©</s> = Ne compte pas' : '') +
            	'</div></div>';

    	// Affichage des parties individuelles
    	html += '<div class="card">' +
        	    '<h4>Ã°Å¸â€œâ€¦ DÃƒÂ©tails de chaque Partie</h4>';

    	for (var i = 0; i < roundDetails.length; i++) {
        	var roundDetail = roundDetails[i];
        	var round = roundDetail.round;

        	html += '<div style="margin: 15px 0; padding: 15px; border: 1px solid #ddd; border-radius: 8px; background: #f9f9f9;">' +
            	    '<div style="display: flex; justify-content: space-between; align-items: center;">' +
                	'<div>' +
                	'<strong>' + round.date.split('-').reverse().join('/') + ' - ' + round.course + ' (Exhibition)</strong>' +
                	'<br><small>' + roundDetail.netRanking.length + ' joueurs</small>' +
                	'</div>' +
                	'<button class="btn" onclick="toggleRoundDetail(\'round_' + round.id + '\')">Ã°Å¸â€˜ÂÃ¯Â¸Â Voir classements</button>' +
                	'</div>' +

                	'<div id="round_' + round.id + '" style="display: none; margin-top: 15px;">' +
                	'<div style="display: grid; grid-template-columns: 1fr 1fr; gap: 20px;">' +

                	// Classement net
                	'<div>' +
                	'<h5>Ã°Å¸Å½Â¯ Classement Score Net</h5>' +
                	'<table class="table" style="font-size: 14px;">' +
                	'<thead><tr><th>Pos</th><th>Joueur</th><th>Score Net</th><th>Points</th></tr></thead>' +
                	'<tbody>';

        	for (var j = 0; j < roundDetail.netRanking.length; j++) {
            	var result = roundDetail.netRanking[j];
            	var playerScore = result.player;

            	html += '<tr>' +
                	    '<td><strong>' + result.position + '</strong></td>' +
                    	'<td>' + playerScore.playerName + '</td>' +
                    	'<td><strong>' + (playerScore.net ? playerScore.net.toFixed(1) : 'N/A') + '</strong></td>' +
                    	'<td><span style="background: #28a745; color: white; padding: 2px 6px; border-radius: 10px;">' + result.points + '</span></td>' +
                    	'</tr>';
        	}

        	html += '</tbody></table></div>' +

            	    // Classement brut
                	'<div>' +
                	'<h5>Ã°Å¸ÂÅ’Ã¯Â¸Â Classement Score Brut</h5>' +
                	'<table class="table" style="font-size: 14px;">' +
                	'<thead><tr><th>Pos</th><th>Joueur</th><th>Score Brut</th><th>Points</th></tr></thead>' +
                	'<tbody>';

        	for (var j = 0; j < roundDetail.grossRanking.length; j++) {
            	var result = roundDetail.grossRanking[j];
            	var playerScore = result.player;

            	html += '<tr>' +
                	    '<td><strong>' + result.position + '</strong></td>' +
                    	'<td>' + playerScore.playerName + '</td>' +
                    	'<td><strong>' + playerScore.score + '</strong></td>' +
                    	'<td><span style="background: #17a2b8; color: white; padding: 2px 6px; border-radius: 10px;">' + result.points + '</span></td>' +
                		'</tr>';
    		}

    		html += '</tbody></table></div>' +
            		'</div></div></div>';
		}

		html += '</div>';
		document.getElementById('gprContent').innerHTML = html;
	}

	// 2. FONCTION POUR AFFICHER/MASQUER LES DÃƒâ€°TAILS D'UNE PARTIE
	function toggleRoundDetail(roundId) {
    	    var element = document.getElementById(roundId);
    	    if (element.style.display === 'none') {
        	element.style.display = 'block';
    	    } else {
        	element.style.display = 'none';
    	    }
	}

	// 3. FONCTION POUR AFFICHER LES DÃƒâ€°TAILS D'UN JOUEUR GPR
	function showGPRPlayerDetails(playerId, selectedYear) {
    	    var gprScores = scores.filter(s => {
        	return s.type === 'gpr' && s.playerId === playerId && (!selectedYear || s.year == selectedYear);
    	    });
    
    	    if (gprScores.length === 0) {
        	alert('Aucune partie GPR trouvÃƒÂ©e pour ce joueur.');
        	return;
    	    }
    
    	    var player = players.find(p => p.id === playerId);
    	    var playerName = player ? (player.name || (player.firstName + ' ' + player.lastName)) : 'Joueur #' + playerId;
    
    	    var pointsScale = [120, 105, 90, 78, 70, 62, 54, 46, 38, 30, 22, 15];
    	    var grossPointsScale = [80, 68, 60, 52, 45, 40, 35, 30, 25, 20, 15, 10];
    
    	    var html = '<div style="position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.5); z-index: 1000; display: flex; justify-content: center; align-items: center;">' +
               	       '<div style="background: white; padding: 30px; border-radius: 10px; box-shadow: 0 4px 20px rgba(0,0,0,0.3); max-width: 800px; width: 90%; max-height: 80%; overflow-y: auto;">' +
               	       '<h3 style="margin-top: 0; color: #2c5530;">Ã°Å¸â€œÅ  DÃƒÂ©tails GPR - ' + playerName + '</h3>' +
               
               	       '<table class="table">' +
               	       '<thead><tr><th>Date</th><th>Terrain</th><th>Score Brut</th><th>Pos. Brut</th><th>Pts Brut</th><th>Score Net</th><th>Pos. Net</th><th>Pts Net</th><th>Total Pts</th></tr></thead>' +
               	       '<tbody>';
    
    	    var totalPoints = 0;
    
    	    // Trier par date
    	    gprScores.sort((a, b) => new Date(a.roundId) - new Date(b.roundId));
    
    	    for (var i = 0; i < gprScores.length; i++) {
        	var score = gprScores[i];
        	var round = rounds.find(r => r.id === score.roundId);
        
        	if (!round) continue;
        
        	// Trouver tous les scores de cette partie pour calculer les positions
        	var roundScores = scores.filter(s => s.roundId === score.roundId);
        
        	// Position brute
        	var grossRanking = [...roundScores].sort((a, b) => a.score - b.score);
        	var grossPosition = grossRanking.findIndex(s => s.playerId === playerId) + 1;
        	var grossPoints = grossPointsScale[Math.min(grossPosition - 1, grossPointsScale.length - 1)];
        
        	// Position nette
        	var netRanking = [...roundScores].sort((a, b) => a.net - b.net);
        	var netPosition = netRanking.findIndex(s => s.playerId === playerId) + 1;
        	var netPoints = pointsScale[Math.min(netPosition - 1, pointsScale.length - 1)];
        
        	var roundTotal = grossPoints + netPoints;
        	totalPoints += roundTotal;
        
        	html += '<tr>' +
                	'<td>' + round.date.split('-').reverse().join('/') + '</td>' +
                	'<td><small>' + round.course + '</small></td>' +
                	'<td><strong>' + score.score + '</strong></td>' +
                	'<td>' + grossPosition + '</td>' +
                	'<td><span style="background: #17a2b8; color: white; padding: 1px 5px; border-radius: 8px; font-size: 12px;">' + grossPoints + '</span></td>' +
                	'<td><strong>' + score.net.toFixed(1) + '</strong></td>' +
                	'<td>' + netPosition + '</td>' +
                	'<td><span style="background: #28a745; color: white; padding: 1px 5px; border-radius: 8px; font-size: 12px;">' + netPoints + '</span></td>' +
                	'<td><strong>' + roundTotal + '</strong></td>' +
                	'</tr>';
    	    }
    
    	    html += '</tbody></table>' +
            
            	    '<div style="margin-top: 20px; padding: 15px; background: #f8f9fa; border-radius: 8px; text-align: center;">' +
            	    '<strong>RÃƒÂ©sumÃƒÂ©:</strong> ' + gprScores.length + ' parties GPR | ' +
            	    '<strong>Total: ' + totalPoints + ' points</strong> | ' +
            	    '<strong>Moyenne: ' + (totalPoints / gprScores.length).toFixed(1) + ' pts/partie</strong>' +
            	    '</div>' +
            
            	    '<div style="margin-top: 25px; text-align: center;">' +
            	    '<button onclick="closeGPRPlayerDetails()" style="background: #6c757d; color: white; border: none; padding: 10px 20px; border-radius: 5px; cursor: pointer;">Ã¢ÂÅ’ Fermer</button>' +
            	    '</div>' +
            
            	    '</div></div>';
    
    	    // Ajouter la popup au body
    	    var popup = document.createElement('div');
    	    popup.id = 'gprPlayerDetailsPopup';
    	    popup.innerHTML = html;
    	    document.body.appendChild(popup);
	}

	// 4. FONCTION POUR FERMER LA POPUP DES DÃƒâ€°TAILS
	function closeGPRPlayerDetails() {
    	    var popup = document.getElementById('gprPlayerDetailsPopup');
    	    if (popup) {
        	popup.remove();
    	    }
	}
    
	function showGPRTab(tabName) {
    	// Fonction vide - plus nÃƒÂ©cessaire
    	return;
	}

	// Fonction pour afficher les dÃƒÂ©tails des 4 meilleures parties
	function showGPRBest4Details(playerId, selectedYear) {
    	var yearToCheck = selectedYear || new Date().getFullYear();
    	var best4Results = calculateBest4Exhibition(playerId, yearToCheck);
    
    	if (best4Results.length === 0) {
        	alert('Aucune partie exhibition trouvÃƒÂ©e pour ce joueur.');
        	return;
    	}
    
    	var player = players.find(p => p.id === playerId);
    	var playerName = player ? (player.name || (player.firstName + ' ' + player.lastName)) : 'Joueur #' + playerId;
    
    	var html = '<div style="position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.5); z-index: 1000; display: flex; justify-content: center; align-items: center;">' +
        	       '<div style="background: white; padding: 30px; border-radius: 10px; box-shadow: 0 4px 20px rgba(0,0,0,0.3); max-width: 900px; width: 90%; max-height: 80%; overflow-y: auto;">' +
            	   '<h3 style="margin-top: 0; color: #2c5530;">Ã°Å¸Ââ€  SÃƒÂ©lection des 4 Meilleures Parties - ' + playerName + '</h3>' +
               
            	   '<div style="background: #e7f3ff; padding: 15px; border-radius: 8px; margin-bottom: 20px;">' +
            	   '<strong>RÃƒÂ¨gle:</strong> Les 4 parties avec le plus de points totaux (brut + net) sont automatiquement sÃƒÂ©lectionnÃƒÂ©es. ' +
            	   'Si moins de 5 parties jouÃƒÂ©es, toutes les parties comptent.' +
            	   '</div>' +
               
            	   '<table class="table">' +
            	   '<thead><tr><th>Ã°Å¸Ââ€ </th><th>Date</th><th>Terrain</th><th>Score Brut</th><th>Pos. Brut</th><th>Pts Brut</th><th>Score Net</th><th>Pos. Net</th><th>Pts Net</th><th>Total Pts</th></tr></thead>' +
            	   '<tbody>';
    
    	var totalPoints = 0;
    
    	for (var i = 0; i < best4Results.length; i++) {
        	var result = best4Results[i];
        	var round = rounds.find(r => r.id === result.roundId);
        
        	totalPoints += result.totalPoints;
        
        	html += '<tr style="background: #f8fff8;">' +
            	    '<td style="text-align: center;"><span style="color: #28a745; font-size: 16px;">Ã¢Å“â€¦</span></td>' +
            	    '<td>' + round.date.split('-').reverse().join('/') + '</td>' +
            	    '<td><small>' + round.course + '</small></td>' +
            	    '<td><strong>' + result.score.score + '</strong></td>' +
            	    '<td>' + result.brutPos + '</td>' +
            	    '<td><span style="background: #17a2b8; color: white; padding: 1px 5px; border-radius: 8px; font-size: 12px;">' + result.brutPoints + '</span></td>' +
            	    '<td><strong>' + result.score.net.toFixed(1) + '</strong></td>' +
           		    '<td>' + result.netPos + '</td>' +
            	    '<td><span style="background: #28a745; color: white; padding: 1px 5px; border-radius: 8px; font-size: 12px;">' + result.netPoints + '</span></td>' +
            	    '<td><strong style="color: #2c5530;">' + result.totalPoints + '</strong></td>' +
            	    '</tr>';
    	}
    
    	html += '</tbody></table>' +
		
        	    '<div style="margin-top: 20px; padding: 15px; background: #f8f9fa; border-radius: 8px; text-align: center;">' +
            	'<strong>RÃƒÂ©sumÃƒÂ©:</strong> ' + best4Results.length + ' partie(s) sÃƒÂ©lectionnÃƒÂ©e(s) | ' +
            	'<strong>Total Exhibition: ' + totalPoints + ' points</strong>';
    
    	// Ajouter les points de finale s'ils existent
    	var finalePoints = 0;
    	var finaleRounds = rounds.filter(r => r.type === 'gpr' && r.gprPhase === 'finale' && r.year === yearToCheck);
    
    	if (finaleRounds.length > 0) {
        	var finaleResults = calculateFinaleScores(yearToCheck);
        	if (finaleResults[playerId]) {
            	finalePoints = (finaleResults[playerId].pointsBrut || 0) + (finaleResults[playerId].pointsNet || 0);
            	html += ' | <strong>Points Finale: ' + finalePoints + '</strong>';
        	}
    	}
    
    	html += ' | <strong style="color: #e74c3c;">TOTAL OFFICIEL: ' + (totalPoints + finalePoints) + ' points</strong>' +
        	    '</div>' +
            
            	'<div style="margin-top: 25px; text-align: center;">' +
            	'<button onclick="closeGPRBest4Details()" style="background: #6c757d; color: white; border: none; padding: 10px 20px; border-radius: 5px; cursor: pointer;">Ã¢ÂÅ’ Fermer</button>' +
            	'</div>' +
            
            	'</div></div>';
    
    	// Ajouter la popup au body
    	var popup = document.createElement('div');
    	popup.id = 'gprBest4DetailsPopup';
    	popup.innerHTML = html;
    	document.body.appendChild(popup);
	}

	// Fonction pour fermer la popup des dÃƒÂ©tails best4
	function closeGPRBest4Details() {
    	var popup = document.getElementById('gprBest4DetailsPopup');
    	if (popup) {
        	popup.remove();
    	}
	}

	// Fonctions utilitaires
        function loadYearSelectors() {
            var years = [];
            for (var i = 0; i < rounds.length; i++) {
                if (years.indexOf(rounds[i].year) === -1) {
                    years.push(rounds[i].year);
                }
            }
            years.sort();

            var diabloSelect = document.getElementById('diabloYearSelect');
            var gprSelect = document.getElementById('gprYearSelect');
            
            var currentDiabloYear = diabloSelect.value;
            var currentGprYear = gprSelect.value;
            
            diabloSelect.innerHTML = '<option value="">-- Toutes les annÃƒÂ©es --</option>';
            gprSelect.innerHTML = '<option value="">-- Toutes les annÃƒÂ©es --</option>';
            
            for (var i = 0; i < years.length; i++) {
                var year = years[i];
                
                var diabloOption = document.createElement('option');
                diabloOption.value = year;
                diabloOption.textContent = year;
                if (year == currentDiabloYear) diabloOption.selected = true;
                diabloSelect.appendChild(diabloOption);
                
                var gprOption = document.createElement('option');
                gprOption.value = year;
                gprOption.textContent = year;
                if (year == currentGprYear) gprOption.selected = true;
                gprSelect.appendChild(gprOption);
            }
        }

        function updateDiabloStatus(selectedYear) {
            var statusElement = document.getElementById('diabloStatus');
            var currentDate = new Date();
            var currentYear = currentDate.getFullYear();
            var currentMonth = currentDate.getMonth() + 1;
            
            if (!selectedYear || selectedYear == currentYear) {
                if (currentMonth >= 9) {
                    statusElement.innerHTML = 'Ã°Å¸â€Â´ En cours';
                    statusElement.style.background = '#28a745';
                    statusElement.style.color = 'white';
                } else {
                    statusElement.innerHTML = 'Ã¢ÂÂ³ Ãƒâ‚¬ venir (Septembre)';
                    statusElement.style.background = '#ffc107';
                    statusElement.style.color = 'black';
                }
            } else if (selectedYear < currentYear) {
                statusElement.innerHTML = 'Ã¢Å“â€¦ TerminÃƒÂ©e';
                statusElement.style.background = '#6c757d';
                statusElement.style.color = 'white';
            } else {
                statusElement.innerHTML = 'Ã°Å¸â€œâ€¦ Future';
                statusElement.style.background = '#17a2b8';
                statusElement.style.color = 'white';
            }
        }

        function updateGPRStatus(selectedYear) {
            var statusElement = document.getElementById('gprStatus');
            var currentDate = new Date();
            var currentYear = currentDate.getFullYear();
            var currentMonth = currentDate.getMonth() + 1;
            
            if (!selectedYear || selectedYear == currentYear) {
                if (currentMonth >= 5 && currentMonth <= 7) {
                    statusElement.innerHTML = 'Ã°Å¸â€Â´ En cours';
                    statusElement.style.background = '#28a745';
                    statusElement.style.color = 'white';
                } else if (currentMonth < 5) {
                    statusElement.innerHTML = 'Ã¢ÂÂ³ Ãƒâ‚¬ venir (Mai-Juillet)';
                    statusElement.style.background = '#ffc107';
                    statusElement.style.color = 'black';
                } else {
                    statusElement.innerHTML = 'Ã¢Å“â€¦ TerminÃƒÂ©e';
                    statusElement.style.background = '#6c757d';
                    statusElement.style.color = 'white';
                }
            } else if (selectedYear < currentYear) {
                statusElement.innerHTML = 'Ã¢Å“â€¦ TerminÃƒÂ©e';
                statusElement.style.background = '#6c757d';
                statusElement.style.color = 'white';
            } else {
                statusElement.innerHTML = 'Ã°Å¸â€œâ€¦ Future';
                statusElement.style.background = '#17a2b8';
                statusElement.style.color = 'white';
            }
        }

        function getUniquePlayersCount(scoresList) {
            var playerIds = [];
            for (var i = 0; i < scoresList.length; i++) {
                if (playerIds.indexOf(scoresList[i].playerId) === -1) {
                    playerIds.push(scoresList[i].playerId);
                }
            }
            return playerIds.length;
        }

        function loadProgress() {
            var currentDate = new Date();
            var currentYear = currentDate.getFullYear();
            var currentMonth = currentDate.getMonth() + 1;
            
            var html = '<div class="card">' +
                       '<h3>Ãƒâ€°tat des Coupes ' + currentYear + '</h3>' +
                       '</div>';
            
            // Progression GPR
            var gprRounds = rounds.filter(r => r.type === 'gpr' && r.year === currentYear);
            var gprScores = scores.filter(s => s.type === 'gpr' && s.year === currentYear);
            
            html += '<div class="card">' +
                    '<h4>Ã°Å¸Å½Â¯ Coupe GPR ' + currentYear + ' (Mai - Juillet)</h4>';
            
            if (currentMonth >= 5 && currentMonth <= 7) {
                html += '<p style="color: #28a745;"><strong>Ã°Å¸â€Â´ EN COURS</strong></p>';
            } else if (currentMonth < 5) {
                html += '<p style="color: #ffc107;"><strong>Ã¢ÂÂ³ Ãƒâ‚¬ VENIR</strong></p>';
            } else {
                html += '<p style="color: #6c757d;"><strong>Ã¢Å“â€¦ TERMINÃƒâ€°E</strong></p>';
            }
            
            html += '<p><strong>Parties jouÃƒÂ©es:</strong> ' + gprRounds.length + '</p>' +
                    '<p><strong>Participants:</strong> ' + getUniquePlayersCount(gprScores) + '</p>';
            
            if (gprScores.length > 0) {
                var gprLeader = getGPRLeader(gprRounds, gprScores);
                html += '<p><strong>Leader actuel:</strong> ' + gprLeader + '</p>';
            }
            
            html += '</div>';
            
            // Progression Diablo
            var diabloRounds = rounds.filter(r => r.type === 'diablo' && r.year === currentYear);
            var diabloScores = scores.filter(s => s.type === 'diablo' && s.year === currentYear);
            
            html += '<div class="card">' +
                    '<h4>Ã°Å¸Ââ€  Coupe Diablo ' + currentYear + ' (Septembre)</h4>';
            
            if (currentMonth >= 9) {
                html += '<p style="color: #28a745;"><strong>Ã°Å¸â€Â´ EN COURS</strong></p>';
            } else {
                html += '<p style="color: #ffc107;"><strong>Ã¢ÂÂ³ Ãƒâ‚¬ VENIR</strong></p>';
            }
            
            html += '<p><strong>Parties jouÃƒÂ©es:</strong> ' + diabloRounds.length + '</p>' +
                    '<p><strong>Participants:</strong> ' + getUniquePlayersCount(diabloScores) + '</p>';
            
            if (diabloScores.length > 0) {
                var diabloLeader = getDiabloLeader(diabloScores);
                html += '<p><strong>Leader actuel:</strong> ' + diabloLeader + '</p>';
            }
            
            html += '</div>';
            
            document.getElementById('progressContent').innerHTML = html;
        }

        function getGPRLeader(gprRounds, gprScores) {
    		var tempPlayerPoints = {};  // Utiliser une variable locale
    		var pointsScale = [120, 105, 90, 78, 70, 62, 54, 46, 38, 30, 22, 15];
    		var grossPointsScale = [80, 68, 60, 52, 45, 40, 35, 30, 25, 20, 15, 10];

    		for (var i = 0; i < gprRounds.length; i++) {
        		var round = gprRounds[i];
        		var roundScores = gprScores.filter(s => s.roundId === round.id);
        
        		roundScores.sort((a, b) => a.net - b.net);
        
        		for (var k = 0; k < roundScores.length; k++) {
            		var score = roundScores[k];
            		if (!tempPlayerPoints[score.playerId]) {
                		var player = players.find(p => p.id === score.playerId);
                		var playerName = player ? (player.name || (player.firstName + ' ' + player.lastName)) : ('Joueur #' + score.playerId);
                
                		tempPlayerPoints[score.playerId] = {
                    		playerName: playerName,
                    		totalPoints: 0
                		};
            		}
            
            		var netPoints = pointsScale[Math.min(k, pointsScale.length - 1)];
            		var grossPoints = grossPointsScale[Math.min(k, grossPointsScale.length - 1)];
            
            		tempPlayerPoints[score.playerId].totalPoints += netPoints + grossPoints;
        		}
    		}

    		var maxPoints = 0;
    		var leader = 'Aucun';
    		for (var playerId in tempPlayerPoints) {
        		if (tempPlayerPoints[playerId].totalPoints > maxPoints) {
            		maxPoints = tempPlayerPoints[playerId].totalPoints;
            		leader = tempPlayerPoints[playerId].playerName + ' (' + maxPoints + ' pts)';
        		}
    		}
    
    		return leader;
		}

	function getDiabloLeader(diabloScores) {
    	    var playerStats = {};
    
    	    for (var i = 0; i < diabloScores.length; i++) {
        	var score = diabloScores[i];
        	if (!playerStats[score.playerId]) {
            	    // CORRECTION : MÃƒÂªme logique que dans l'overview
            	    var player = players.find(p => p.id === score.playerId);
            	    var playerName = player ? (player.name || (player.firstName + ' ' + player.lastName)) : ('Joueur #' + score.playerId);
            
            	    playerStats[score.playerId] = {
                	playerName: playerName,  // UTILISER le nom calculÃƒÂ©
                	totalNet: 0,
                	rounds: 0
            	    };
        	}
        	playerStats[score.playerId].totalNet += score.net;
        	playerStats[score.playerId].rounds++;
    	    }

    	    var bestAvg = 999;
    	    var leader = 'Aucun';
    	    for (var playerId in playerStats) {
        	var avg = playerStats[playerId].totalNet / playerStats[playerId].rounds;
        	if (avg < bestAvg) {
            	    bestAvg = avg;
            	    leader = playerStats[playerId].playerName + ' (' + avg.toFixed(1) + ' net)';  // UTILISER playerName
        	}
    	    }
    
    	    return leader;
	}

        function loadDetails() {
            var select = document.getElementById('roundSelect');
            select.innerHTML = '<option value="">-- SÃƒÂ©lectionner une partie --</option>';
            
            for (var i = 0; i < rounds.length; i++) {
                var round = rounds[i];
                var icon = round.type === 'diablo' ? 'Ã°Å¸Ââ€ ' : 'Ã°Å¸Å½Â¯';
                var date = round.date.split('-').reverse().join('/');
                
                var option = document.createElement('option');
                option.value = round.id;
                option.textContent = icon + ' ' + date + ' - ' + round.course;
                select.appendChild(option);
            }
        }

        function showRoundDetail() {
            var roundId = parseInt(document.getElementById('roundSelect').value);
            if (!roundId) {
                document.getElementById('detailsContent').innerHTML = '';
                return;
            }

            var round = rounds.find(r => r.id === roundId);
            var roundScores = scores.filter(s => s.roundId === roundId);

            if (!round || roundScores.length === 0) {
                document.getElementById('detailsContent').innerHTML = '<p>Aucun score pour cette partie.</p>';
                return;
            }

            console.log('DEBUG: round =', round);
            console.log('DEBUG: roundScores =', roundScores);
            console.log('DEBUG: round.type =', round.type);

            var html = '<div class="card">' +
                       '<h3>' + round.date.split('-').reverse().join('/') + ' - ' + round.course + '</h3>' +
                       '<p><strong>Type:</strong> ' + (round.type === 'diablo' ? 'Ã°Å¸Ââ€  Coupe Diablo' : 'Ã°Å¸Å½Â¯ Coupe GPR') + '</p>' +
                       '<p><strong>DÃƒÂ©part:</strong> ' + (round.tee === 'bleu' ? 'Ã°Å¸â€Âµ Bleu' : 'Ã¢Å¡Âª Blanc') + ' (Antonio: ' + (teeUsed[round.id-1] === 'bleu' ? 'Ã°Å¸â€Âµ Bleu' : 'Ã¢Å¡Âª Blanc') + ', Autres: Ã¢Å¡Âª Blanc)</p>' +
                       '<div style="margin: 15px 0; text-align: center; background: #f8f9fa; padding: 15px; border-radius: 8px;">' +
					   '<h4 style="margin: 0 0 10px 0; color: #2c5530;">Ã¢Å¡â„¢Ã¯Â¸Â Actions sur cette partie</h4>' +
					   '<button class="btn-secondary" onclick="editRound(' + round.id + ')" style="margin: 5px;">Ã¢Å“ÂÃ¯Â¸Â Modifier Scores</button>' +
					   '<button class="btn-danger" onclick="deleteRound(' + round.id + ')" style="margin: 5px;">Ã°Å¸â€”â€˜Ã¯Â¸Â Supprimer Partie</button>' +
					   '<button class="btn" onclick="duplicateRound(' + round.id + ')" style="margin: 5px;">Ã°Å¸â€œâ€¹ Dupliquer Partie</button>' +
					   '</div>' +
					   '</div>';

            if (round.type === 'diablo') {
                console.log('DEBUG: GÃƒÂ©nÃƒÂ©ration dÃƒÂ©tails Diablo');
                html += generateDiabloRoundDetail(round, roundScores);
            } else {
                console.log('DEBUG: GÃƒÂ©nÃƒÂ©ration dÃƒÂ©tails GPR');
                html += generateGPRRoundDetail(round, roundScores);
            }

            console.log('DEBUG: HTML final =', html);
            document.getElementById('detailsContent').innerHTML = html;
        }

        // GÃƒÂ©nÃƒÂ©rer les dÃƒÂ©tails pour une partie Diablo
        function generateDiabloRoundDetail(round, roundScores) {
            var html = '';
            
            // Classement de la partie
            roundScores.sort((a, b) => a.net - b.net);
            
            html += '<div class="card">' +
                    '<h4>Ã°Å¸Ââ€  Classement de la Partie</h4>' +
                    '<table class="table">' +
                    '<thead><tr><th>Position</th><th>Joueur</th><th>Score Brut</th><th>Score Net</th><th>DiffÃƒÂ©rentiel</th></tr></thead>' +
                    '<tbody>';

            for (var i = 0; i < roundScores.length; i++) {
                var score = roundScores[i];
                var rowStyle = '';
                if (i === 0) rowStyle = ' style="background: gold;"';
                else if (i === 1) rowStyle = ' style="background: silver;"';
                else if (i === 2) rowStyle = ' style="background: #cd7f32;"';
                
                // Calculer le diffÃƒÂ©rentiel
                var differential = calculateScoreDifferentialReal(score.score, round.course, score.tee);
                
                html += '<tr' + rowStyle + '>' +
                        '<td><strong>' + (i + 1) + '</strong></td>' +
                        '<td><strong>' + score.playerName + '</strong></td>' +
                        '<td>' + score.score + '</td>' +
                        '<td><strong>' + score.net.toFixed(1) + '</strong></td>' +
                        '<td>' + (differential ? differential.toFixed(1) : 'N/A') + '</td>' +
                        '</tr>';
            }

            html += '</tbody></table></div>';
            
            // Pointage global du tournoi Diablo pour cette annÃƒÂ©e
            html += generateDiabloTournamentStandings(round.year);
            
            return html;
        }

        // GÃƒÂ©nÃƒÂ©rer les dÃƒÂ©tails pour une partie GPR
        function generateGPRRoundDetail(round, roundScores) {
            var html = '';
            
            // Points scale
            var brutPointsScale = [80, 68, 60, 52, 45, 40, 35, 30, 25, 20, 15, 10];
            var netPointsScale = [120, 105, 90, 78, 70, 62, 54, 46, 38, 30, 22, 15];
            
            // Exclure Ãƒâ€°ric Gosselin (ID 12) des classements GPR
            var gprScores = roundScores.filter(s => s.playerId !== 13);
            
            // 1. Classement Brut avec pointage
            var brutRanking = [...gprScores].sort((a, b) => a.score - b.score);
            
            html += '<div class="card">' +
                    '<h4>Ã°Å¸ÂÅ’Ã¯Â¸Â Classement Score Brut</h4>' +
                    '<table class="table">' +
                    '<thead><tr><th>Position</th><th>Joueur</th><th>Score Brut</th><th>Points</th></tr></thead>' +
                    '<tbody>';

            for (var i = 0; i < brutRanking.length; i++) {
                var score = brutRanking[i];
                var points = brutPointsScale[Math.min(i, brutPointsScale.length - 1)];
                var rowStyle = '';
                if (i === 0) rowStyle = ' style="background: gold;"';
                else if (i === 1) rowStyle = ' style="background: silver;"';
                else if (i === 2) rowStyle = ' style="background: #cd7f32;"';
                
                html += '<tr' + rowStyle + '>' +
                        '<td><strong>' + (i + 1) + '</strong></td>' +
                        '<td><strong>' + score.playerName + '</strong></td>' +
                        '<td>' + score.score + '</td>' +
                        '<td><span style="background: #17a2b8; color: white; padding: 2px 8px; border-radius: 10px;">' + points + '</span></td>' +
                        '</tr>';
            }

            html += '</tbody></table></div>';
            
            // 2. Classement Net avec pointage
            var netRanking = [...gprScores].sort((a, b) => a.net - b.net);
            
            html += '<div class="card">' +
                    '<h4>Ã°Å¸Å½Â¯ Classement Score Net</h4>' +
                    '<table class="table">' +
                    '<thead><tr><th>Position</th><th>Joueur</th><th>Score Net</th><th>Points</th></tr></thead>' +
                    '<tbody>';

            for (var i = 0; i < netRanking.length; i++) {
                var score = netRanking[i];
                var points = netPointsScale[Math.min(i, netPointsScale.length - 1)];
                var rowStyle = '';
                if (i === 0) rowStyle = ' style="background: gold;"';
                else if (i === 1) rowStyle = ' style="background: silver;"';
                else if (i === 2) rowStyle = ' style="background: #cd7f32;"';
                
                html += '<tr' + rowStyle + '>' +
                        '<td><strong>' + (i + 1) + '</strong></td>' +
                        '<td><strong>' + score.playerName + '</strong></td>' +
                        '<td><strong>' + score.net.toFixed(1) + '</strong></td>' +
                        '<td><span style="background: #28a745; color: white; padding: 2px 8px; border-radius: 10px;">' + points + '</span></td>' +
                        '</tr>';
            }

            html += '</tbody></table></div>';
            
            // 3. Points totaux pour cette partie
            var roundTotals = [];
            
            for (var i = 0; i < gprScores.length; i++) {
                var score = gprScores[i];
                var brutPos = brutRanking.findIndex(s => s.playerId === score.playerId) + 1;
                var netPos = netRanking.findIndex(s => s.playerId === score.playerId) + 1;
                var brutPoints = brutPointsScale[Math.min(brutPos - 1, brutPointsScale.length - 1)];
                var netPoints = netPointsScale[Math.min(netPos - 1, netPointsScale.length - 1)];
                var totalPoints = brutPoints + netPoints;
                
                roundTotals.push({
                    player: score,
                    brutPoints: brutPoints,
                    netPoints: netPoints,
                    totalPoints: totalPoints
                });
            }
            
            roundTotals.sort((a, b) => b.totalPoints - a.totalPoints);
            
            html += '<div class="card">' +
                    '<h4>Ã°Å¸Ââ€  Points Totaux de la Partie</h4>' +
                    '<table class="table">' +
                    '<thead><tr><th>Position</th><th>Joueur</th><th>Points Brut</th><th>Points Net</th><th>Total</th></tr></thead>' +
                    '<tbody>';

            for (var i = 0; i < roundTotals.length; i++) {
                var total = roundTotals[i];
                var rowStyle = '';
                if (i === 0) rowStyle = ' style="background: gold;"';
                else if (i === 1) rowStyle = ' style="background: silver;"';
                else if (i === 2) rowStyle = ' style="background: #cd7f32;"';
                
                html += '<tr' + rowStyle + '>' +
                        '<td><strong>' + (i + 1) + '</strong></td>' +
                        '<td><strong>' + total.player.playerName + '</strong></td>' +
                        '<td>' + total.brutPoints + '</td>' +
                        '<td>' + total.netPoints + '</td>' +
                        '<td><strong>' + total.totalPoints + '</strong></td>' +
                        '</tr>';
            }

            html += '</tbody></table></div>';
            
            // 4. Pointage global du tournoi GPR pour cette annÃƒÂ©e
            html += generateGPRTournamentStandings(round.year);
            
            return html;
        }

        // GÃƒÂ©nÃƒÂ©rer le classement global Diablo pour une annÃƒÂ©e
        function generateDiabloTournamentStandings(year) {
            var diabloScores = scores.filter(s => s.type === 'diablo' && s.year === year);
            
            if (diabloScores.length === 0) {
                return '<div class="card"><h4>Ã°Å¸Ââ€  Classement Global Diablo ' + year + '</h4><p>Aucune partie Diablo pour cette annÃƒÂ©e.</p></div>';
            }
            
            var playerStats = {};
            
            for (var i = 0; i < diabloScores.length; i++) {
                var score = diabloScores[i];
                if (!playerStats[score.playerId]) {
                    playerStats[score.playerId] = {
                        playerName: score.playerName,
                        totalNet: 0,
                        rounds: 0
                    };
                }
                playerStats[score.playerId].totalNet += score.net;
                playerStats[score.playerId].rounds++;
            }
            
            var leaderboard = [];
            for (var playerId in playerStats) {
                var stats = playerStats[playerId];
                leaderboard.push({
                    playerName: stats.playerName,
                    rounds: stats.rounds,
                    avgNet: stats.totalNet / stats.rounds
                });
            }
            
            leaderboard.sort((a, b) => a.avgNet - b.avgNet);
            
            var html = '<div class="card">' +
                       '<h4>Ã°Å¸Ââ€  Classement Global Diablo ' + year + '</h4>' +
                       '<table class="table">' +
                       '<thead><tr><th>Position</th><th>Joueur</th><th>Parties</th><th>Score Net Moyen</th></tr></thead>' +
                       '<tbody>';
            
            for (var i = 0; i < leaderboard.length; i++) {
                var stats = leaderboard[i];
                var rowStyle = '';
                if (i === 0) rowStyle = ' style="background: gold;"';
                else if (i === 1) rowStyle = ' style="background: silver;"';
                else if (i === 2) rowStyle = ' style="background: #cd7f32;"';
                
                html += '<tr' + rowStyle + '>' +
                        '<td><strong>' + (i + 1) + '</strong></td>' +
                        '<td><strong>' + stats.playerName + '</strong></td>' +
                        '<td>' + stats.rounds + '</td>' +
                        '<td><strong>' + stats.avgNet.toFixed(1) + '</strong></td>' +
                        '</tr>';
            }
            
            html += '</tbody></table></div>';
            
            return html;
        }

        // GÃƒÂ©nÃƒÂ©rer le classement global GPR pour une annÃƒÂ©e
        function generateGPRTournamentStandings(year) {
            var gprScores = scores.filter(s => s.type === 'gpr' && s.year === year && s.playerId !== 13); // Exclure Gosselin
            
            if (gprScores.length === 0) {
                return '<div class="card"><h4>Ã°Å¸Å½Â¯ Classement Global GPR ' + year + '</h4><p>Aucune partie GPR pour cette annÃƒÂ©e.</p></div>';
            }
            
            var gprRounds = rounds.filter(r => r.type === 'gpr' && r.year === year);
            var playerPoints = {};
            var brutPointsScale = [80, 68, 60, 52, 45, 40, 35, 30, 25, 20, 15, 10];
            var netPointsScale = [120, 105, 90, 78, 70, 62, 54, 46, 38, 30, 22, 15];
            
            for (var i = 0; i < gprRounds.length; i++) {
                var round = gprRounds[i];
                var roundScores = gprScores.filter(s => s.roundId === round.id);
                
                // Classement brut pour cette partie
                var brutRanking = [...roundScores].sort((a, b) => a.score - b.score);
                // Classement net pour cette partie
                var netRanking = [...roundScores].sort((a, b) => a.net - b.net);
                
                for (var j = 0; j < roundScores.length; j++) {
                    var score = roundScores[j];
                    if (!playerPoints[score.playerId]) {
                        playerPoints[score.playerId] = {
                            playerName: score.playerName,
                            totalPoints: 0,
                            rounds: 0
                        };
                    }
                    
                    var brutPos = brutRanking.findIndex(s => s.playerId === score.playerId) + 1;
                    var netPos = netRanking.findIndex(s => s.playerId === score.playerId) + 1;
                    var brutPoints = brutPointsScale[Math.min(brutPos - 1, brutPointsScale.length - 1)];
                    var netPoints = netPointsScale[Math.min(netPos - 1, netPointsScale.length - 1)];
                    
                    playerPoints[score.playerId].totalPoints += brutPoints + netPoints;
                    playerPoints[score.playerId].rounds++;
                }
            }
            
            var leaderboard = [];
            for (var playerId in playerPoints) {
                var stats = playerPoints[playerId];
                leaderboard.push({
                    playerName: stats.playerName,
                    rounds: stats.rounds,
                    totalPoints: stats.totalPoints
                });
            }
            
            leaderboard.sort((a, b) => b.totalPoints - a.totalPoints);
            
            var html = '<div class="card">' +
                       '<h4>Ã°Å¸Å½Â¯ Classement Global GPR ' + year + '</h4>' +
                       '<table class="table">' +
                       '<thead><tr><th>Position</th><th>Joueur</th><th>Parties</th><th>Points Totaux</th></tr></thead>' +
                       '<tbody>';
            
            for (var i = 0; i < leaderboard.length; i++) {
                var stats = leaderboard[i];
                var rowStyle = '';
                if (i === 0) rowStyle = ' style="background: gold;"';
                else if (i === 1) rowStyle = ' style="background: silver;"';
                else if (i === 2) rowStyle = ' style="background: #cd7f32;"';
                
                html += '<tr' + rowStyle + '>' +
                        '<td><strong>' + (i + 1) + '</strong></td>' +
                        '<td><strong>' + stats.playerName + '</strong></td>' +
                        '<td>' + stats.rounds + '</td>' +
                        '<td><strong>' + stats.totalPoints + '</strong></td>' +
                        '</tr>';
            }
            
            html += '</tbody></table></div>';
            
            return html;
        }

	// Variables globales pour le graphique
	var selectedPlayers = [];
	var handicapEvolutionData = {};

	// Fonction pour afficher la section ÃƒÂ©volution des handicaps
	function showHandicapEvolution() {
    	    hideAllSections();
    	    document.getElementById('handicapEvolution').style.display = 'block';
    	    setActiveButton('showHandicapEvolution'); // Ajustez l'index selon votre navigation
    	    loadHandicapEvolution();
	}

	// Charger l'interface d'ÃƒÂ©volution des handicaps
	function loadHandicapEvolution() {
    	    // PrÃƒÂ©parer les donnÃƒÂ©es d'ÃƒÂ©volution pour tous les joueurs
    	    prepareHandicapEvolutionData();
    
    	    // CrÃƒÂ©er les checkboxes pour sÃƒÂ©lectionner les joueurs
    	    createPlayerCheckboxes();
    
    	    // SÃƒÂ©lectionner automatiquement les 3 premiers joueurs
    	    selectDefaultPlayers();
    
    	    // Afficher le graphique initial
    	    updateHandicapChart();
    
    	    // CORRECTION : Toujours afficher les statistiques, mÃƒÂªme sans sÃƒÂ©lection
    	    displayHandicapStats();
	}

	// PrÃƒÂ©parer les donnÃƒÂ©es d'ÃƒÂ©volution des handicaps
	function prepareHandicapEvolutionData() {
    	    console.log("Ã°Å¸â€â€ PrÃƒÂ©paration des donnÃƒÂ©es d'ÃƒÂ©volution avec calculs rÃƒÂ©els...");
    
    	    handicapEvolutionData = {};
    
    	    // Vider le cache pour ÃƒÂ©viter les conflits
    	    if (typeof handicapCache !== 'undefined') {
        	handicapCache = {};
    	    }
    
    	    for (var i = 0; i < players.length; i++) {
        	var player = players[i];
        	var evolution = [];
        	var playerName = player.name || (player.firstName + ' ' + player.lastName);
        
        	console.log("Calcul pour:", playerName);
        
        	// Handicap de dÃƒÂ©part (avant toute partie)
        	var currentHandicap = player.handicap;
        
        	// Point de dÃƒÂ©part
        	evolution.push({
            	    date: dates[0] || '2023-01-01',
            	    handicap: currentHandicap,
            	    gameNumber: 0,
            	    change: 0
        	});
        
        	// CORRECTION : Calculer l'ÃƒÂ©volution RÃƒâ€°ELLE aprÃƒÂ¨s chaque partie
        	var scoresCount = 0;
        	var allDifferentials = [];
        
        	for (var j = 0; j < dates.length; j++) {
            	    if (allScores[i][j] > 0) {
                	scoresCount++;
                	var grossScore = allScores[i][j];
                	var courseName = courses[j];
                	var teeForPlayer = (player.id === 1) ? teeUsed[j] : 'blanc';
                
                	// Calculer le diffÃƒÂ©rentiel pour ce score
                	var differential = calculateScoreDifferentialReal(grossScore, courseName, teeForPlayer);
                	if (differential > 0) {
                    	    allDifferentials.push(differential);
                	}
                
                	// Calculer le nouveau handicap basÃƒÂ© sur tous les scores jusqu'ici
                	var newHandicap = calculateNewHandicapFromDifferentials(allDifferentials, player.handicap);
                	var change = newHandicap - currentHandicap;
                
                	evolution.push({
                    	    date: dates[j],
                    	    handicap: newHandicap,
                    	    gameNumber: j + 1,
                    	    change: change,
                    	    score: grossScore,
                    	    course: courseName,
                    	    differential: differential,
                    	    totalDifferentials: allDifferentials.length
                	});
                
                	currentHandicap = newHandicap;
                
                	console.log(`  Partie ${j+1}: Score ${grossScore} Ã¢â€ â€™ Handicap ${newHandicap.toFixed(1)} (${change > 0 ? '+' : ''}${change.toFixed(1)})`);
            	    }
        	}
        
        	handicapEvolutionData[player.id] = {
            	    player: player,
            	    playerName: playerName,
            	    evolution: evolution
        	};
        
        	var finalChange = evolution.length > 1 ? evolution[evolution.length-1].handicap - evolution[0].handicap : 0;
        	console.log(`${playerName} - Changement total: ${finalChange > 0 ? '+' : ''}${finalChange.toFixed(1)}`);
    	    }
    
    	    console.log("Ã¢Å“â€¦ DonnÃƒÂ©es d'ÃƒÂ©volution prÃƒÂ©parÃƒÂ©es avec calculs rÃƒÂ©els!");
	}

	// 1. FONCTION DE DIAGNOSTIC POUR COMPRENDRE LE PROBLÃƒË†ME
	function diagnoseHandicapProgression() {
    	    console.log("Ã°Å¸â€Â DIAGNOSTIC DE LA PROGRESSION DES HANDICAPS");
    	    console.log("=============================================");
    
    	    // Prendre Antonio comme exemple
    	    var antonio = players.find(p => p.id === 1);
    	    if (!antonio || !allScores[0]) {
        	console.log("Ã¢ÂÅ’ Pas de donnÃƒÂ©es pour Antonio");
        	return;
    	    }
    
    	    console.log("Analyse pour Antonio Coccaro:");
    	    console.log("Handicap initial:", antonio.handicap);
    
    	    var progressiveDifferentials = [];
    
    	    for (var i = 0; i < Math.min(10, dates.length); i++) {
        	if (allScores[0][i] > 0) {
            	    var score = allScores[0][i];
            	    var course = courses[i];
            	    var tee = teeUsed[i]; // Antonio joue des bleus parfois
            
            	    // Calculer le diffÃƒÂ©rentiel pour ce score
            	    var diff = calculateScoreDifferentialReal(score, course, tee);
            	    if (diff > 0) {
                	progressiveDifferentials.push(diff);
                
                	// Calculer le handicap avec SEULEMENT les scores jusqu'ici
                	var handicapAtThisPoint = calculateNewHandicapFromDifferentials(progressiveDifferentials, antonio.handicap);
                
                	console.log(`Partie ${i+1} (${dates[i]}):`);
                	console.log(`  Score: ${score} au ${course} (${tee})`);
                	console.log(`  DiffÃƒÂ©rentiel: ${diff}`);
                	console.log(`  DiffÃƒÂ©rentiels accumulÃƒÂ©s: ${progressiveDifferentials.length}`);
                	console.log(`  Handicap calculÃƒÂ©: ${handicapAtThisPoint}`);
                	console.log(`  ---`);
            	    }
        	}
    	    }
    
    	    console.log("\nÃ°Å¸Å½Â¯ Si les handicaps sont identiques, c'est que le calcul ne progresse pas correctement!");
	}

	// 2. FONCTION CORRIGÃƒâ€°E POUR CALCULER L'Ãƒâ€°VOLUTION PROGRESSIVE
	function prepareHandicapEvolutionDataProgressive() {
    	    console.log("Ã°Å¸â€â€ PrÃƒÂ©paration PROGRESSIVE des donnÃƒÂ©es d'ÃƒÂ©volution...");
    
    	    handicapEvolutionData = {};
    
    	    for (var i = 0; i < players.length; i++) {
        	var player = players[i];
        	var evolution = [];
        	var playerName = player.name || (player.firstName + ' ' + player.lastName);
        
        	console.log(`\nCalcul progressif pour: ${playerName}`);
        
        	// Handicap de dÃƒÂ©part
        	var currentHandicap = player.handicap;
        
        	// Point de dÃƒÂ©part
        	evolution.push({
            	    date: dates[0] || '2023-01-01',
            	    handicap: currentHandicap,
            	    gameNumber: 0,
            	    change: 0,
            	    scoresUsed: 0,
            	    status: 'Initial'
        	});
        
        	// CORRECTION : Accumuler progressivement les diffÃƒÂ©rentiels
        	var progressiveDifferentials = [];
        	var gameNumber = 0;
        
        	for (var j = 0; j < dates.length; j++) {
            	    if (allScores[i][j] > 0) {
                	gameNumber++;
                	var grossScore = allScores[i][j];
                	var courseName = courses[j];
                	var teeForPlayer = (player.id === 1) ? teeUsed[j] : 'blanc';
                
                	// Calculer le diffÃƒÂ©rentiel pour cette partie
                	var differential = calculateScoreDifferentialReal(grossScore, courseName, teeForPlayer);
                
                	if (differential > 0) {
                    	    // AJOUTER ce diffÃƒÂ©rentiel ÃƒÂ  la liste progressive
                    	    progressiveDifferentials.push({
                        	date: dates[j],
                        	differential: differential,
                        	score: grossScore,
                        	course: courseName
                    	    });
                    
                    	    // Calculer le nouveau handicap avec SEULEMENT les scores jusqu'ÃƒÂ  cette date
                    	    var newHandicap;
                    
                    	    if (progressiveDifferentials.length < 5) {
                        	// Pas assez de scores, garder le handicap prÃƒÂ©cÃƒÂ©dent
                        	newHandicap = currentHandicap;
                        	var status = `Pas assez de scores (${progressiveDifferentials.length}/5)`;
                    	    } else {
                        	// Calculer avec les diffÃƒÂ©rentiels disponibles jusqu'ici
                        	var diffValues = progressiveDifferentials.map(d => d.differential);
                        	newHandicap = calculateNewHandicapFromDifferentials(diffValues, player.handicap);
                        	var status = `CalculÃƒÂ© avec ${progressiveDifferentials.length} scores`;
                    	    }
                    
                    	    var change = newHandicap - currentHandicap;
                    
                    	    evolution.push({
                        	date: dates[j],
                        	handicap: newHandicap,
                        	gameNumber: gameNumber,
                        	change: change,
                        	score: grossScore,
                        	course: courseName,
                        	differential: differential,
                        	scoresUsed: progressiveDifferentials.length,
                        	status: status
                    	    });
                    
                    	    console.log(`  Partie ${gameNumber}: ${grossScore} Ã¢â€ â€™ H=${newHandicap.toFixed(1)} (${progressiveDifferentials.length} scores)`);
                    
                    	    currentHandicap = newHandicap;
                	}
            	    }
        	}
        
        	handicapEvolutionData[player.id] = {
            	    player: player,
            	    playerName: playerName,
            	    evolution: evolution
        	};
        
        	// RÃƒÂ©sumÃƒÂ© pour ce joueur
        	if (evolution.length > 1) {
            	    var initialH = evolution[0].handicap;
            	    var finalH = evolution[evolution.length - 1].handicap;
            	    // Trouver l'handicap ÃƒÂ  la 6e partie JOUÃƒâ€°E par ce joueur
					var initialHandicapForDisplay = evolution[0].handicap;
					var partiesJouees = 0;
					for (var k = 0; k < evolution.length; k++) {
    					// VÃƒÂ©rifier s'il a jouÃƒÂ© cette partie (a un score)
    					if (evolution[k].score && evolution[k].score > 0) {
        					partiesJouees++;
        					if (partiesJouees === 6) {
            					initialHandicapForDisplay = evolution[k].handicap;
            					break;
        					}
    					}
					}
					// Si le joueur n'a pas 6 parties, garder son handicap initial
					if (partiesJouees < 6) {
    					initialHandicapForDisplay = evolution[0].handicap;
					}
					var totalChange = finalH - initialHForDisplay;
            	    var totalGames = evolution[evolution.length - 1].gameNumber;
            
            	    console.log(`${playerName} RÃƒâ€°SUMÃƒâ€°: ${initialH.toFixed(1)} Ã¢â€ â€™ ${finalH.toFixed(1)} (${totalChange > 0 ? '+' : ''}${totalChange.toFixed(1)}) sur ${totalGames} parties`);
        	}
    	    }
    
    	    console.log("\nÃ¢Å“â€¦ Ãƒâ€°volution PROGRESSIVE calculÃƒÂ©e!");
	}

	// 3. FONCTION POUR CALCULER AVEC VARIATION RÃƒâ€°ALISTE (alternative)
	function prepareHandicapEvolutionWithRealisticVariation() {
    	    console.log("Ã°Å¸Å½Â­ PrÃƒÂ©paration avec variation rÃƒÂ©aliste...");
    
    	    handicapEvolutionData = {};
    
    	    for (var i = 0; i < players.length; i++) {
        	var player = players[i];
        	var evolution = [];
        	var playerName = player.name || (player.firstName + ' ' + player.lastName);
        
        	// Handicap de dÃƒÂ©part
        	var currentHandicap = player.handicap;
        
        	evolution.push({
            	    date: dates[0] || '2023-01-01',
            	    handicap: currentHandicap,
            	    gameNumber: 0,
            	    change: 0
        	});
        
        	// Variables pour la progression rÃƒÂ©aliste
        	var recentScores = [];
        	var gameNumber = 0;
        	var lastHandicapUpdate = 0;
        
        	for (var j = 0; j < dates.length; j++) {
            	    if (allScores[i][j] > 0) {
                	gameNumber++;
                	var grossScore = allScores[i][j];
                
                	// Ajouter ÃƒÂ  la liste des scores rÃƒÂ©cents
                	recentScores.push(grossScore);
                
                	// Garder seulement les 8 derniers scores pour l'ÃƒÂ©valuation
                	if (recentScores.length > 8) {
                    	    recentScores.shift();
                	}
                
                	// Calculer un changement basÃƒÂ© sur la performance rÃƒÂ©cente
                	var change = 0;
                
                	if (gameNumber >= 5 && (gameNumber - lastHandicapUpdate) >= 3) {
                    	    // Recalculer le handicap tous les 3 parties aprÃƒÂ¨s les 5 premiÃƒÂ¨res
                    	    var avgRecentScore = recentScores.reduce((sum, s) => sum + s, 0) / recentScores.length;
                    	    var expectedScore = 72 + currentHandicap; // Score attendu basÃƒÂ© sur par + handicap
                    
                    	    var performance = avgRecentScore - expectedScore;
                    
                    	    if (performance < -3) {
                        	// TrÃƒÂ¨s bonne performance = handicap baisse
                        	change = -0.5 - (Math.random() * 0.5);
                    	    } else if (performance < -1) {
                        	// Bonne performance = lÃƒÂ©gÃƒÂ¨re baisse
                        	change = -0.2 - (Math.random() * 0.3);
                    	    } else if (performance > 3) {
                        	// Mauvaise performance = handicap monte
                        	change = 0.3 + (Math.random() * 0.7);
                    	    } else if (performance > 1) {
                        	// Performance dÃƒÂ©cevante = lÃƒÂ©gÃƒÂ¨re hausse
                        	change = 0.1 + (Math.random() * 0.3);
                    	    } else {
                        	// Performance stable = changement minimal
                        	change = (Math.random() - 0.5) * 0.2;
                    	    }
                    
                    	    lastHandicapUpdate = gameNumber;
                	}
                
                	// Appliquer le changement
                	currentHandicap = Math.max(0, Math.min(36.4, currentHandicap + change));
                	currentHandicap = Math.round(currentHandicap * 10) / 10;
                
                	evolution.push({
                    	    date: dates[j],
                    	    handicap: currentHandicap,
                    	    gameNumber: gameNumber,
                    	    change: change,
                    	    score: grossScore,
                    	    course: courses[j],
                    	    avgRecent: recentScores.length > 0 ? (recentScores.reduce((sum, s) => sum + s, 0) / recentScores.length).toFixed(1) : 'N/A'
                	});
            	    }
        	}
        
        	handicapEvolutionData[player.id] = {
            	    player: player,
            	    playerName: playerName,
            	    evolution: evolution
        	};
    	    }
    
    	    console.log("Ã¢Å“â€¦ Ãƒâ€°volution avec variation rÃƒÂ©aliste calculÃƒÂ©e!");
	}

	// 4. FONCTION POUR CHOISIR LA MÃƒâ€°THODE DE CALCUL
	function updateHandicapEvolutionMethod(method) {
    	    console.log(`Ã°Å¸â€â€ Mise ÃƒÂ  jour avec mÃƒÂ©thode: ${method}`);
    
    	    switch(method) {
        	case 'progressive':
            	    prepareHandicapEvolutionDataProgressive();
            	    break;
        	case 'realistic':
            	    prepareHandicapEvolutionWithRealisticVariation();
            	    break;
        	default:
            	    console.log("Ã¢ÂÅ’ MÃƒÂ©thode inconnue. Utilisez 'progressive' ou 'realistic'");
            	    return;
    	    }
    
    	    // Mettre ÃƒÂ  jour l'affichage
    	    if (typeof displayHandicapStats === 'function') {
        	displayHandicapStats();
    	    }
    
    	    if (typeof selectedPlayers !== 'undefined' && selectedPlayers.length > 0) {
        	if (typeof drawHandicapChart === 'function') {
            	    drawHandicapChart();
        	}
    	    }
    
    	    console.log("Ã¢Å“â€¦ Affichage mis ÃƒÂ  jour!");
	}

	// 5. INSTRUCTIONS DE TEST
	console.log("=== INSTRUCTIONS POUR CORRIGER L'Ãƒâ€°VOLUTION ===");
	console.log("1. Diagnostic: diagnoseHandicapProgression()");
	console.log("2. MÃƒÂ©thode progressive: updateHandicapEvolutionMethod('progressive')");
	console.log("3. MÃƒÂ©thode rÃƒÂ©aliste: updateHandicapEvolutionMethod('realistic')");
	console.log("4. La mÃƒÂ©thode rÃƒÂ©aliste donnera des variations plus visibles");

	// CrÃƒÂ©er les checkboxes pour sÃƒÂ©lectionner les joueurs
	function createPlayerCheckboxes() {
    	    var container = document.getElementById('playerCheckboxes');
    	    var html = '';
    
    	    for (var i = 0; i < players.length; i++) {
        	var player = players[i];
        	var totalScores = allScores[i].filter(score => score > 0).length;
        
        	if (totalScores >= 5) { // Seulement les joueurs avec assez de scores
            	    // CORRECTION : Utiliser le nom calculÃƒÂ©
            	    var playerName = player.name || (player.firstName + ' ' + player.lastName);
            
            	    html += '<label style="display: flex; align-items: center; gap: 8px; padding: 8px; border: 1px solid #ddd; border-radius: 5px;">' +
                    	    '<input type="checkbox" value="' + player.id + '" onchange="togglePlayer(' + player.id + ')">' +
                    	    '<span><strong>' + playerName + '</strong> (' + totalScores + ' parties)</span>' +
                    	    '</label>';
        	}
    	    }
    
    	    container.innerHTML = html;
	}

	// SÃƒÂ©lectionner les joueurs par dÃƒÂ©faut
	function selectDefaultPlayers() {
    	    var checkboxes = document.querySelectorAll('#playerCheckboxes input[type="checkbox"]');
    	    selectedPlayers = [];
    
    	    // SÃƒÂ©lectionner les 3 premiers joueurs avec assez de scores
    	    for (var i = 0; i < Math.min(3, checkboxes.length); i++) {
        	checkboxes[i].checked = true;
        	selectedPlayers.push(parseInt(checkboxes[i].value));
    	    }
	}

	// Basculer la sÃƒÂ©lection d'un joueur
	function togglePlayer(playerId) {
    	var index = selectedPlayers.indexOf(playerId);
    	if (index > -1) {
        	selectedPlayers.splice(index, 1);
    	} else {
        	selectedPlayers.push(playerId);
    	}
    
    	// Mettre ÃƒÂ  jour le graphique aprÃƒÂ¨s chaque changement
    	updateHandicapChart();
	}

	// SÃƒÂ©lectionner tous les joueurs
	function selectAllPlayers() {
    	    var checkboxes = document.querySelectorAll('#playerCheckboxes input[type="checkbox"]');
    	    selectedPlayers = [];
    
    	    for (var i = 0; i < checkboxes.length; i++) {
        	checkboxes[i].checked = true;
        	selectedPlayers.push(parseInt(checkboxes[i].value));
    	    }
    
    	    updateHandicapChart();
	}

	// DÃƒÂ©sÃƒÂ©lectionner tous les joueurs
	function clearAllPlayers() {
    	    var checkboxes = document.querySelectorAll('#playerCheckboxes input[type="checkbox"]');
    	    selectedPlayers = [];
    
    	    for (var i = 0; i < checkboxes.length; i++) {
        	checkboxes[i].checked = false;
    	    }
    
    	    updateHandicapChart();
    
    	    // CORRECTION : Maintenir l'affichage des statistiques mÃƒÂªme quand aucun joueur n'est sÃƒÂ©lectionnÃƒÂ©
    	    displayHandicapStats();
	}

	// Mettre ÃƒÂ  jour le graphique
	function updateHandicapChart() {
    	    if (selectedPlayers.length === 0) {
        	document.getElementById('handicapChart').innerHTML = 
            	    '<div style="text-align: center; padding: 50px; color: #666; border: 2px dashed #ddd; border-radius: 8px; background: #f9f9fa;">' +
            	    '<h3 style="color: #999; margin-bottom: 10px;">Ã°Å¸â€œË† Graphique d\'Ãƒâ€°volution</h3>' +
            	    '<p>Veuillez sÃƒÂ©lectionner au moins un joueur pour voir le graphique d\'ÃƒÂ©volution des handicaps.</p>' +
            	    '<p style="font-size: 14px; color: #999;">Les statistiques de tous les joueurs sont affichÃƒÂ©es ci-dessous.</p>' +
            	    '</div>';
        
        	// CORRECTION : Toujours afficher les statistiques
        	displayHandicapStats();
        	return;
    	    }
    
    	    // Remettre le canvas si des joueurs sont sÃƒÂ©lectionnÃƒÂ©s
    	    document.getElementById('handicapChart').innerHTML = 
        	'<canvas id="handicapCanvas" width="1000" height="500" style="max-width: 100%; border: 1px solid #ddd; border-radius: 8px;"></canvas>';
    
    	    drawHandicapChart();
    	    displayHandicapStats();
	}

	// Dessiner le graphique des handicaps
	function drawHandicapChart() {
    	var canvas = document.getElementById('handicapCanvas');
    	var ctx = canvas.getContext('2d');

    	// Dimensions
    	var width = canvas.width;
    	var height = canvas.height;
    	var padding = 60;
    	var chartWidth = width - 2 * padding;
    	var chartHeight = height - 2 * padding;

    	// Nettoyer le canvas
    	ctx.clearRect(0, 0, width, height);

    	// Couleurs pour les joueurs
    	var colors = ['#e74c3c', '#3498db', '#2ecc71', '#f39c12', '#9b59b6', '#1abc9c', '#e67e22', '#34495e', '#f1c40f', '#95a5a6', '#d35400', '#8e44ad', '#16a085'];

    	// Trouver les limites des donnÃƒÂ©es (seulement ÃƒÂ  partir de la 6e partie)
    	var minHandicap = Infinity;
    	var maxHandicap = -Infinity;
    	var maxGames = 0;

    	for (var i = 0; i < selectedPlayers.length; i++) {
        	var playerId = selectedPlayers[i];
        	var evolution = handicapEvolutionData[playerId].evolution;
        
        	for (var j = 0; j < evolution.length; j++) {
            	if (evolution[j].gameNumber >= 5) { // Seulement ÃƒÂ  partir de la 6e partie
                	minHandicap = Math.min(minHandicap, evolution[j].handicap);
                	maxHandicap = Math.max(maxHandicap, evolution[j].handicap);
                	// Ajuster pour que maxGames reprÃƒÂ©sente la plage visible (0 = 6e partie)
                	maxGames = Math.max(maxGames, evolution[j].gameNumber - 5);
            	}
        	}
    	}

    	// Ajouter une marge
    	var handicapRange = maxHandicap - minHandicap;
    	minHandicap -= handicapRange * 0.1;
    	maxHandicap += handicapRange * 0.1;

    	// Dessiner les axes
    	ctx.strokeStyle = '#333';
    	ctx.lineWidth = 2;
    	ctx.beginPath();
    	ctx.moveTo(padding, padding);
    	ctx.lineTo(padding, height - padding);
    	ctx.lineTo(width - padding, height - padding);
    	ctx.stroke();

    	// Dessiner la grille horizontale
    	ctx.strokeStyle = '#e0e0e0';
    	ctx.lineWidth = 1;
    	for (var i = 0; i <= 10; i++) {
        	var y = padding + (chartHeight * i / 10);
        	ctx.beginPath();
        	ctx.moveTo(padding, y);
        	ctx.lineTo(width - padding, y);
        	ctx.stroke();
        
        	// Ãƒâ€°tiquettes handicap
        	var handicapValue = maxHandicap - (handicapRange * i / 10);
        	ctx.fillStyle = '#666';
        	ctx.font = '12px Arial';
        	ctx.textAlign = 'right';
        	ctx.fillText(handicapValue.toFixed(1), padding - 10, y + 4);
    	}

    	// Dessiner la grille verticale
    	for (var i = 0; i <= maxGames; i += Math.max(1, Math.floor(maxGames / 10))) {
        	var x = padding + (chartWidth * i / maxGames);
        	ctx.beginPath();
        	ctx.moveTo(x, padding);
        	ctx.lineTo(x, height - padding);
        	ctx.stroke();
        
        	// Ãƒâ€°tiquettes parties (ajuster pour montrer le vrai numÃƒÂ©ro de partie)
        	ctx.fillStyle = '#666';
        	ctx.font = '12px Arial';
        	ctx.textAlign = 'center';
        	ctx.fillText('P' + (i + 6), x, height - padding + 20); // +6 car on commence ÃƒÂ  la 6e partie
    	}

    	// Dessiner les lignes des joueurs
    	for (var i = 0; i < selectedPlayers.length; i++) {
        	var playerId = selectedPlayers[i];
        	var playerData = handicapEvolutionData[playerId];
        	var evolution = playerData.evolution;
        	var color = colors[i % colors.length];

        	ctx.strokeStyle = color;
        	ctx.fillStyle = color;
        	ctx.lineWidth = 3;

        	// Filtrer pour ne montrer qu'ÃƒÂ  partir de la 6e partie (gameNumber >= 5)
        	var visibleEvolution = evolution.filter(point => point.gameNumber >= 5);
        
        	if (visibleEvolution.length === 0) continue;

        	// Dessiner la ligne (seulement pour les parties 6+)
        	ctx.beginPath();
        	for (var j = 0; j < visibleEvolution.length; j++) {
            	var point = visibleEvolution[j];
            	// Ajuster gameNumber pour que la 6e partie devienne la position 0
            	var adjustedGameNumber = point.gameNumber - 5;
            	var x = padding + (chartWidth * adjustedGameNumber / maxGames);
            	var y = padding + (chartHeight * (maxHandicap - point.handicap) / handicapRange);

            	if (j === 0) {
                	ctx.moveTo(x, y);
            	} else {
                	ctx.lineTo(x, y);
            	}
        	}
        	ctx.stroke();

        	// Dessiner les points (seulement pour les parties 6+)
        	for (var j = 0; j < visibleEvolution.length; j++) {
            	var point = visibleEvolution[j];
            	var adjustedGameNumber = point.gameNumber - 5;
            	var x = padding + (chartWidth * adjustedGameNumber / maxGames);
            	var y = padding + (chartHeight * (maxHandicap - point.handicap) / handicapRange);

            	ctx.beginPath();
            	ctx.arc(x, y, 4, 0, 2 * Math.PI);
            	ctx.fill();
        	}
    	}

    	// LÃƒÂ©gende
    	var legendY = 20;
    	for (var i = 0; i < selectedPlayers.length; i++) {
        	var playerId = selectedPlayers[i];
        	var playerData = handicapEvolutionData[playerId];
        	var color = colors[i % colors.length];
        
        	var playerName = playerData.playerName || playerData.player.name || (playerData.player.firstName + ' ' + playerData.player.lastName);
        
        	ctx.fillStyle = color;
        	ctx.fillRect(width - 200, legendY + (i * 25), 15, 15);
        
        	ctx.fillStyle = '#333';
        	ctx.font = '14px Arial';
        	ctx.textAlign = 'left';
        	ctx.fillText(playerName, width - 180, legendY + (i * 25) + 12);
    	}

    	// Titre
    	ctx.fillStyle = '#333';
    	ctx.font = 'bold 16px Arial';
    	ctx.textAlign = 'center';
    	ctx.fillText('Ãƒâ€°volution des Handicaps par Partie (ÃƒÂ  partir de la 6e partie)', width / 2, 30);

    	// Ãƒâ€°tiquettes des axes
    	ctx.fillStyle = '#666';
    	ctx.font = '14px Arial';
    	ctx.textAlign = 'center';
    	ctx.fillText('NumÃƒÂ©ro de Partie', width / 2, height - 10);

    	ctx.save();
    	ctx.translate(20, height / 2);
    	ctx.rotate(-Math.PI / 2);
    	ctx.fillText('Handicap Index', 0, 0);
    	ctx.restore();
	}

	// Afficher les statistiques d'ÃƒÂ©volution
	function displayHandicapStats() {
    	    // CORRECTION : Afficher les stats pour TOUS les joueurs avec des scores, pas seulement les sÃƒÂ©lectionnÃƒÂ©s
    	    var allPlayersWithScores = [];
    
    	    for (var playerId in handicapEvolutionData) {
        	var playerData = handicapEvolutionData[playerId];
        	var evolution = playerData.evolution;
        
        	if (evolution.length >= 2) { // Au moins 2 points pour calculer l'ÃƒÂ©volution
            	    allPlayersWithScores.push({
                	playerId: playerId,
                	playerData: playerData
            	    });
        	}
    	    }
    
    	    if (allPlayersWithScores.length === 0) {
        	document.getElementById('handicapStats').innerHTML = '<p style="text-align: center; color: #666; padding: 20px;">Aucune donnÃƒÂ©e d\'ÃƒÂ©volution disponible</p>';
        	return;
    	    }
    
    	    var html = '<h3>Ã°Å¸â€œÅ  Statistiques d\'Ãƒâ€°volution - Tous les Joueurs</h3>';
    	    html += '<p style="color: #666; margin-bottom: 15px;">Ãƒâ€°volution des handicaps pour tous les joueurs ayant au moins 5 parties</p>';
    	    html += '<table class="table"><thead><tr><th>Joueur</th><th>Handicap Initial</th><th>Handicap Final</th><th>Changement Total</th><th>Plus Grande AmÃƒÂ©lioration</th><th>Plus Grande DÃƒÂ©gradation</th><th>Parties</th></tr></thead><tbody>';
    
    	    // Trier par changement total (les amÃƒÂ©liorations en premier)
    	    allPlayersWithScores.sort((a, b) => {
        	var evolutionA = a.playerData.evolution;
        	var evolutionB = b.playerData.evolution;
        	var changeA = evolutionA[evolutionA.length - 1].handicap - evolutionA[0].handicap;
        	var changeB = evolutionB[evolutionB.length - 1].handicap - evolutionB[0].handicap;
        	return changeA - changeB; // Ordre croissant (amÃƒÂ©liorations nÃƒÂ©gatives en premier)
    	    });
    
    	    for (var i = 0; i < allPlayersWithScores.length; i++) {
        		var playerData = allPlayersWithScores[i].playerData;
        		var evolution = playerData.evolution;
        
        		// Trouver l'handicap ÃƒÂ  la 6e partie JOUÃƒâ€°E par ce joueur
				var initialHandicapForDisplay = evolution[0].handicap;
				var partiesJouees = 0;
				for (var k = 0; k < evolution.length; k++) {
    				// VÃƒÂ©rifier s'il a jouÃƒÂ© cette partie (a un score)
    				if (evolution[k].score && evolution[k].score > 0) {
        				partiesJouees++;
        				if (partiesJouees === 6) {
            				initialHandicapForDisplay = evolution[k].handicap;
            				break;
        				}
    				}
				}
				// Si le joueur n'a pas 6 parties, garder son handicap initial
				if (partiesJouees < 6) {
    				initialHandicapForDisplay = evolution[0].handicap;
				}

				var initialHandicap = evolution[0].handicap; // Garder le vrai initial pour les calculs
				var finalHandicap = evolution[evolution.length - 1].handicap;
				var totalChange = finalH - initialHandicapForDisplay; // Changement depuis la 6e partie
        
        	var bestChange = 0;
        	var worstChange = 0;
        
        	for (var j = 1; j < evolution.length; j++) {
            	    var change = evolution[j].change;
            	    if (change < bestChange) bestChange = change;
            	    if (change > worstChange) worstChange = change;
        	}
        
        	// Style de ligne selon l'amÃƒÂ©lioration/dÃƒÂ©gradation
        	var changeClass = '';
        	var rowStyle = '';
        	if (totalChange < -2) {
            	    changeClass = 'style="color: #28a745; font-weight: bold;"'; // Vert pour grosse amÃƒÂ©lioration
            	    rowStyle = ' style="background: #f8fff8;"';
        	} else if (totalChange < 0) {
            	    changeClass = 'style="color: #28a745;"'; // Vert pour amÃƒÂ©lioration
        	} else if (totalChange > 2) {
            	    changeClass = 'style="color: #dc3545; font-weight: bold;"'; // Rouge pour grosse dÃƒÂ©gradation
            	    rowStyle = ' style="background: #fff8f8;"';
        	} else if (totalChange > 0) {
            	    changeClass = 'style="color: #dc3545;"'; // Rouge pour dÃƒÂ©gradation
        	}
        
        	var playerName = playerData.playerName || playerData.player.name || (playerData.player.firstName + ' ' + playerData.player.lastName);
        	var totalGames = evolution.length - 1; // -1 car le premier point est l'ÃƒÂ©tat initial
        
        	html += '<tr' + rowStyle + '>' +
                	'<td><strong>' + playerName + '</strong></td>' +
                	'<td>' + initialHandicapForDisplay.toFixed(1) + '</td>' +
                	'<td>' + finalHandicap.toFixed(1) + '</td>' +
                	'<td ' + changeClass + '><strong>' + (totalChange > 0 ? '+' : '') + totalChange.toFixed(1) + '</strong></td>' +
                	'<td style="color: #28a745;">' + bestChange.toFixed(1) + '</td>' +
                	'<td style="color: #dc3545;">+' + worstChange.toFixed(1) + '</td>' +
                	'<td>' + totalGames + '</td>' +
                	'</tr>';
    	    }
    
    	    html += '</tbody></table>';
    
    	    // Ajouter une lÃƒÂ©gende
    	    html += '<div style="margin-top: 15px; padding: 10px; background: #f8f9fa; border-radius: 5px; font-size: 14px;">' +
            	    '<strong>LÃƒÂ©gende:</strong> ' +
            	    '<span style="color: #28a745;">Ã°Å¸Å¸Â¢ AmÃƒÂ©lioration du handicap</span> | ' +
            	    '<span style="color: #dc3545;">Ã°Å¸â€Â´ DÃƒÂ©gradation du handicap</span> | ' +
            	    '<span style="color: #666;">Ã¢Å¡Âª Changement minimal (Ã‚Â±2 points)</span>' +
            	    '</div>';
    
    	    document.getElementById('handicapStats').innerHTML = html;
	}

	// 5. AJOUTER UNE FONCTION POUR FILTRER LES STATISTIQUES PAR SÃƒâ€°LECTION (optionnel) :

	function toggleStatsDisplay() {
    	    var showOnlySelected = document.getElementById('showOnlySelected').checked;
    
    	    if (showOnlySelected && selectedPlayers.length > 0) {
        	displayHandicapStatsFiltered();
    	    } else {
        	displayHandicapStats();
    	    }
	}

	function displayHandicapStatsFiltered() {
    	    if (selectedPlayers.length === 0) return;
    
    	    var html = '<h3>Ã°Å¸â€œÅ  Statistiques d\'Ãƒâ€°volution - Joueurs SÃƒÂ©lectionnÃƒÂ©s</h3>';
    	    html += '<table class="table"><thead><tr><th>Joueur</th><th>Handicap Initial</th><th>Handicap Final</th><th>Changement Total</th><th>Plus Grande AmÃƒÂ©lioration</th><th>Plus Grande DÃƒÂ©gradation</th><th>Parties</th></tr></thead><tbody>';
    
    	    for (var i = 0; i < selectedPlayers.length; i++) {
        	var playerId = selectedPlayers[i];
        	var playerData = handicapEvolutionData[playerId];
        	var evolution = playerData.evolution;
        
        	if (evolution.length < 2) continue;
        
        	var initialHandicap = evolution[0].handicap;
        	var finalHandicap = evolution[evolution.length - 1].handicap;
        	// Trouver l'handicap ÃƒÂ  la 6e partie JOUÃƒâ€°E par ce joueur
			var initialHandicapForDisplay = evolution[0].handicap;
			var partiesJouees = 0;
			for (var k = 0; k < evolution.length; k++) {
    			// VÃƒÂ©rifier s'il a jouÃƒÂ© cette partie (a un score)
    			if (evolution[k].score && evolution[k].score > 0) {
        			partiesJouees++;
        			if (partiesJouees === 6) {
            			initialHandicapForDisplay = evolution[k].handicap;
            			break;
        			}
    			}
			}
			// Si le joueur n'a pas 6 parties, garder son handicap initial
			if (partiesJouees < 6) {
    			initialHandicapForDisplay = evolution[0].handicap;
			}
			var totalChange = finalHandicap - initialHandicapForDisplay;
        
        	var bestChange = 0;
        	var worstChange = 0;
        
        	for (var j = 1; j < evolution.length; j++) {
            	    var change = evolution[j].change;
            	    if (change < bestChange) bestChange = change;
            	    if (change > worstChange) worstChange = change;
        	}
        
        	var changeClass = totalChange < 0 ? 'style="color: #28a745;"' : totalChange > 0 ? 'style="color: #dc3545;"' : '';
        	var playerName = playerData.playerName || playerData.player.name || (playerData.player.firstName + ' ' + playerData.player.lastName);
        	var totalGames = evolution.length - 1;
        
        	html += '<tr>' +
                	'<td><strong>' + playerName + '</strong></td>' +
                	'<td>' + initialHandicap.toFixed(1) + '</td>' +
                	'<td>' + finalHandicap.toFixed(1) + '</td>' +
                	'<td ' + changeClass + '><strong>' + (totalChange > 0 ? '+' : '') + totalChange.toFixed(1) + '</strong></td>' +
                	'<td style="color: #28a745;">' + bestChange.toFixed(1) + '</td>' +
                	'<td style="color: #dc3545;">+' + worstChange.toFixed(1) + '</td>' +
                	'<td>' + totalGames + '</td>' +
                	'</tr>';
    	    }
    
    	    html += '</tbody></table>';
    
    	    document.getElementById('handicapStats').innerHTML = html;
	}

	// Exporter les donnÃƒÂ©es d'ÃƒÂ©volution
	function exportHandicapData() {
    	    if (selectedPlayers.length === 0) {
        	alert('Veuillez sÃƒÂ©lectionner au moins un joueur');
        	return;
    	    }
    
    	    var csvContent = 'Joueur,Date,NumÃƒÂ©ro Partie,Handicap,Changement,Score,Terrain\n';
    
    	    for (var i = 0; i < selectedPlayers.length; i++) {
        	var playerId = selectedPlayers[i];
        	var playerData = handicapEvolutionData[playerId];
        	var evolution = playerData.evolution;
        
        	// CORRECTION : Utiliser le nom calculÃƒÂ©
        	var playerName = playerData.playerName || playerData.player.name || (playerData.player.firstName + ' ' + playerData.player.lastName);
        
        	for (var j = 0; j < evolution.length; j++) {
            	    var point = evolution[j];
            	    csvContent += playerName + ',' +  // UTILISER playerName
                         	point.date + ',' +
                                point.gameNumber + ',' +
                         	point.handicap.toFixed(1) + ',' +
                         	point.change.toFixed(1) + ',' +
                         	(point.score || '') + ',' +
                         	(point.course || '') + '\n';
        	}
    	    }
    
    	    var blob = new Blob([csvContent], { type: 'text/csv' });
    	    var link = document.createElement('a');
    	    link.href = URL.createObjectURL(blob);
    	    link.download = 'evolution-handicaps-' + new Date().toISOString().split('T')[0] + '.csv';
    	    link.click();
	}

	// Variables pour la gestion des joueurs
	var nextPlayerId = 14; // Commencer aprÃƒÂ¨s les joueurs existants

	// Afficher la section de gestion des joueurs
	function showPlayerManagement() {
    	    hideAllSections();
    	    document.getElementById('playerManagement').style.display = 'block';
    	    setActiveButton('showPlayerManagement'); // Ajustez selon votre ordre de boutons
    	    loadPlayersGrid();
	}

	// Charger la grille des joueurs
	function loadPlayersGrid() {
    	    var html = '';
    
    	    // CORRECTION : S'assurer que tous les joueurs ont la propriÃƒÂ©tÃƒÂ© 'active'
    	    for (var i = 0; i < players.length; i++) {
        	if (players[i].active === undefined) {
            	    players[i].active = true; // Par dÃƒÂ©faut, tous les joueurs sont actifs
        	}
    	    }
    
    	    var activePlayers = players.filter(p => p.active);
    
    	    console.log("DEBUG: Nombre total de joueurs:", players.length);
    	    console.log("DEBUG: Joueurs actifs:", activePlayers.length);
    
    	    // Statistiques gÃƒÂ©nÃƒÂ©rales
    	    html += '<div class="card" style="background: #f8f9fa;">' +
            	    '<h3>Ã°Å¸â€œÅ  Statistiques du Club</h3>' +
            	    '<div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(150px, 1fr)); gap: 15px;">' +
            	    '<div class="stat-box"><div class="stat-value">' + activePlayers.length + '</div><div class="stat-label">Joueurs Actifs</div></div>' +
            	    '<div class="stat-box"><div class="stat-value">' + (players.length - activePlayers.length) + '</div><div class="stat-label">Joueurs Inactifs</div></div>' +
            	    '<div class="stat-box"><div class="stat-value">' + getAverageHandicap().toFixed(1) + '</div><div class="stat-label">Handicap Moyen</div></div>' +
            	    '<div class="stat-box"><div class="stat-value">' + getTotalGamesPlayed() + '</div><div class="stat-label">Parties Totales</div></div>' +
            	    '</div>' +
            	    '</div>';
    
    	    // CORRECTION : Afficher TOUS les joueurs (actifs ET inactifs) pour la gestion
    	    for (var i = 0; i < players.length; i++) {
        	var player = players[i];
        
        	// CORRECTION : Calculer le nom du joueur
        	var playerName = player.name || (player.firstName + ' ' + player.lastName) || ('Joueur #' + player.id);
        
        	var playerStats = calculatePlayerStats(player);
        	var statusBadge = player.active ? 
            	    '<span style="background: #28a745; color: white; padding: 2px 8px; border-radius: 10px; font-size: 11px;">ACTIF</span>' : 
            	    '<span style="background: #6c757d; color: white; padding: 2px 8px; border-radius: 10px; font-size: 11px;">INACTIF</span>';
        
        	html += '<div class="course-card">' +
                	'<div class="course-header">' +
                	'<div class="course-name">Ã°Å¸ÂÅ’Ã¯Â¸Â ' + playerName + '</div>' +
                	'<div>' +
                	statusBadge +
                	'<button class="btn-secondary" onclick="editPlayer(' + player.id + ')" style="margin-left: 10px;">Ã¢Å“ÂÃ¯Â¸Â Modifier</button>' +
                	'<button class="btn-danger" onclick="togglePlayerStatus(' + player.id + ')">Ã°Å¸â€â€ Statut</button>' +
                	'</div>' +
                	'</div>' +
                
                	'<div style="margin: 10px 0; padding: 10px; background: #f8f9fa; border-radius: 5px;">' +
                	'<div style="display: grid; grid-template-columns: 1fr 1fr; gap: 10px; font-size: 14px;">' +
                	'<div><strong>Ã°Å¸â€œÅ¾ TÃƒÂ©lÃƒÂ©phone:</strong><br>' + (player.phone || 'Non renseignÃƒÂ©') + '</div>' +
                	'<div><strong>Ã°Å¸â€œÂ§ Courriel:</strong><br>' + (player.email || 'Non renseignÃƒÂ©') + '</div>' +
                	'<div><strong>Ã°Å¸ÂÅ’Ã¯Â¸Â Handicap:</strong><br>' + player.handicap.toFixed(1) + '</div>' +
                	'<div><strong>Ã°Å¸â€œâ€¦ Membre depuis:</strong><br>' + formatDate(player.dateJoined) + '</div>' +
                	'</div>' +
                	'</div>' +
                
                	'<div style="border: 2px solid #4a7c59; border-radius: 8px; padding: 15px; background: #fff;">' +
                	'<h4 style="margin: 0 0 10px 0; color: #2c5530;">Ã°Å¸â€œË† Statistiques GÃƒÂ©nÃƒÂ©rales</h4>' +
                	'<div style="display: grid; grid-template-columns: repeat(2, 1fr); gap: 10px; text-align: center;">' +
                	'<div style="background: #e8f5e8; padding: 10px; border-radius: 5px;"><strong>' + playerStats.totalGames + '</strong><br><small>Parties</small></div>' +
                	'<div style="background: #e3f2fd; padding: 10px; border-radius: 5px;"><strong>' + playerStats.avgScore.toFixed(1) + '</strong><br><small>Score Moyen</small></div>' +
                	'<div style="background: #fff3e0; padding: 10px; border-radius: 5px;"><strong>' + playerStats.bestScore + '</strong><br><small>Meilleur Score</small></div>' +
                	'<div style="background: #fce4ec; padding: 10px; border-radius: 5px;"><strong>' + playerStats.worstScore + '</strong><br><small>Pire Score</small></div>' +
                	'</div>' +
                	'<div style="margin-top: 10px; text-align: center; font-size: 12px; color: #666;">' +
                	'DerniÃƒÂ¨re partie: ' + (playerStats.lastGame || 'Aucune') + 
                	'</div>' +
                	'</div>' +
                
                	'</div>';
    	    }
    
    	    console.log("DEBUG: HTML gÃƒÂ©nÃƒÂ©rÃƒÂ©, longueur:", html.length);
    	    document.getElementById('playersGrid').innerHTML = html;
	}

	// Calculer les statistiques d'un joueur
	function calculatePlayerStats(player) {
    	    var playerIndex = players.findIndex(p => p.id === player.id);
    
    	    console.log("DEBUG: Calcul stats pour joueur", player.id, "index:", playerIndex);
    
    	    if (playerIndex === -1 || !allScores[playerIndex]) {
        	console.log("DEBUG: Pas de scores pour le joueur", player.id);
        	return {
            	    totalGames: 0,
            	    avgScore: 0,
            	    bestScore: 'N/A',
            	    worstScore: 'N/A',
            	    lastGame: 'Aucune'
        	};
    	    }
    
    	    var scores = allScores[playerIndex].filter(score => score > 0);
    
    	    console.log("DEBUG: Joueur", player.id, "a", scores.length, "scores");
    
    	    if (scores.length === 0) {
        	return {
            	    totalGames: 0,
            	    avgScore: 0,
            	    bestScore: 'N/A',
            	    worstScore: 'N/A',
            	    lastGame: 'Aucune'
        	};
    	    }
    
    	    var totalScore = scores.reduce((sum, score) => sum + score, 0);
    	    var avgScore = totalScore / scores.length;
    	    var bestScore = Math.min(...scores);
    	    var worstScore = Math.max(...scores);
    
    	    // Trouver la derniÃƒÂ¨re partie
    	    var lastGameIndex = -1;
    	    for (var i = allScores[playerIndex].length - 1; i >= 0; i--) {
        	if (allScores[playerIndex][i] > 0) {
            	    lastGameIndex = i;
            	    break;
        	}
    	    }
    
    	    var lastGame = lastGameIndex >= 0 ? formatDate(dates[lastGameIndex]) : 'Aucune';
    
    	    return {
        	totalGames: scores.length,
        	avgScore: avgScore,
        	bestScore: bestScore,
        	worstScore: worstScore,
        	lastGame: lastGame
    	    };
	}

	// Afficher le formulaire d'ajout de joueur
	function showAddPlayerForm() {
    	    var form = document.getElementById('addPlayerForm');
    	    if (form.style.display === 'none') {
        	form.style.display = 'block';
        	// DÃƒÂ©finir la date d'aujourd'hui par dÃƒÂ©faut
        	document.getElementById('newPlayerDateJoined').value = new Date().toISOString().split('T')[0];
        	// Vider les champs
        	document.getElementById('newPlayerFirstName').value = '';
        	document.getElementById('newPlayerLastName').value = '';
        	document.getElementById('newPlayerPhone').value = '';
        	document.getElementById('newPlayerEmail').value = '';
        	document.getElementById('newPlayerHandicap').value = '';
    	    } else {
        	form.style.display = 'none';
    	    }
	}

	// Sauvegarder un nouveau joueur
	function saveNewPlayer() {
    	    var firstName = document.getElementById('newPlayerFirstName').value.trim();
    	    var lastName = document.getElementById('newPlayerLastName').value.trim();
    	    var phone = document.getElementById('newPlayerPhone').value.trim();
    	    var email = document.getElementById('newPlayerEmail').value.trim();
    	    var handicap = parseFloat(document.getElementById('newPlayerHandicap').value);
    	    var dateJoined = document.getElementById('newPlayerDateJoined').value;
    
    	    // Validation
    	    if (!firstName || !lastName) {
        	alert('Le prÃƒÂ©nom et le nom sont obligatoires.');
        	return;
    	    }
    
    	    if (isNaN(handicap) || handicap < 0 || handicap > 36.4) {
        	alert('Le handicap doit ÃƒÂªtre un nombre entre 0 et 36.4.');
        	return;
    	    }
    
    	    if (email && !isValidEmail(email)) {
        	alert('L\'adresse courriel n\'est pas valide.');
        	return;
    	    }
    
    	    // VÃƒÂ©rifier si le joueur existe dÃƒÂ©jÃƒÂ 
    	    var existingPlayer = players.find(p => 
        	p.firstName.toLowerCase() === firstName.toLowerCase() && 
        	p.lastName.toLowerCase() === lastName.toLowerCase()
    	    );
    
    	    if (existingPlayer) {
        	alert('Un joueur avec ce nom existe dÃƒÂ©jÃƒÂ .');
        	return;
    	    }
    
    	    // Trouver le prochain ID disponible
    	    var nextId = Math.max(...players.map(p => p.id)) + 1;
    
    	    // CrÃƒÂ©er le nouveau joueur
    	    var newPlayer = {
        	id: nextId,
        	firstName: firstName,
        	lastName: lastName,
        	name: firstName + ' ' + lastName,
        	phone: phone,
        	email: email,
        	handicap: handicap,
        	dateJoined: dateJoined,
        	active: true
    	    };
    
    	    players.push(newPlayer);
    
    	    // Ajouter un tableau vide de scores pour ce joueur
    	    var emptyScores = new Array(dates.length).fill(null);
    	    allScores.push(emptyScores);
    
            // Sauvegarder dans Firebase
            Promise.all([
                savePlayersToFirebase(),
                saveScoresToFirebase()
            ]).then(function() {
                console.log('Nouveau joueur sauvegardÃƒÂ© dans Firebase');
            }).catch(function(error) {
                console.error('Erreur de sauvegarde:', error);
                alert('Erreur de sauvegarde: ' + error.message);
            });

    	    // Sauvegarder et recharger
    	    loadPlayersGrid();
    	    showAddPlayerForm(); // Fermer le formulaire
    
    	    alert('Ã¢Å“â€¦ Joueur "' + newPlayer.name + '" ajoutÃƒÂ© avec succÃƒÂ¨s!');
	}

	// Annuler l'ajout de joueur
	function cancelAddPlayer() {
    	    showAddPlayerForm();
	}

	// Ãƒâ€°diter un joueur
	function editPlayer(playerId) {
    	    var player = players.find(p => p.id === playerId);
    	    if (!player) {
        	alert('Joueur non trouvÃƒÂ©!');
        	return;
    	    }
    
    	    var playerName = player.name || (player.firstName + ' ' + player.lastName);
    
    	    // CrÃƒÂ©er un formulaire d'ÃƒÂ©dition plus complet
    	    var formHtml = 
        	'<div style="position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.5); z-index: 1000; display: flex; justify-content: center; align-items: center;">' +
        	'<div style="background: white; padding: 30px; border-radius: 10px; box-shadow: 0 4px 20px rgba(0,0,0,0.3); max-width: 500px; width: 90%;">' +
        	'<h3 style="margin-top: 0; color: #2c5530;">Ã¢Å“ÂÃ¯Â¸Â Modifier ' + playerName + '</h3>' +
        
        	'<div style="margin: 15px 0;">' +
        	'<label style="display: block; font-weight: bold; margin-bottom: 5px;">PrÃƒÂ©nom:</label>' +
        	'<input type="text" id="editFirstName" value="' + (player.firstName || '') + '" style="width: 100%; padding: 8px; border: 1px solid #ddd; border-radius: 4px;">' +
        	'</div>' +
        
        	'<div style="margin: 15px 0;">' +
        	'<label style="display: block; font-weight: bold; margin-bottom: 5px;">Nom:</label>' +
        	'<input type="text" id="editLastName" value="' + (player.lastName || '') + '" style="width: 100%; padding: 8px; border: 1px solid #ddd; border-radius: 4px;">' +
        	'</div>' +
        
        	'<div style="margin: 15px 0;">' +
        	'<label style="display: block; font-weight: bold; margin-bottom: 5px;">TÃƒÂ©lÃƒÂ©phone:</label>' +
        	'<input type="tel" id="editPhone" value="' + (player.phone || '') + '" style="width: 100%; padding: 8px; border: 1px solid #ddd; border-radius: 4px;">' +
        	'</div>' +
        
        	'<div style="margin: 15px 0;">' +
        	'<label style="display: block; font-weight: bold; margin-bottom: 5px;">Courriel:</label>' +
        	'<input type="email" id="editEmail" value="' + (player.email || '') + '" style="width: 100%; padding: 8px; border: 1px solid #ddd; border-radius: 4px;">' +
        	'</div>' +
        
        	'<div style="margin: 15px 0;">' +
        	'<label style="display: block; font-weight: bold; margin-bottom: 5px;">Handicap:</label>' +
        	'<input type="number" id="editHandicap" value="' + player.handicap + '" step="0.1" min="0" max="36.4" style="width: 100%; padding: 8px; border: 1px solid #ddd; border-radius: 4px;">' +
        	'</div>' +
        
        	'<div style="margin: 15px 0;">' +
        	'<label style="display: block; font-weight: bold; margin-bottom: 5px;">Date d\'adhÃƒÂ©sion:</label>' +
        	'<input type="date" id="editDateJoined" value="' + (player.dateJoined || '') + '" style="width: 100%; padding: 8px; border: 1px solid #ddd; border-radius: 4px;">' +
        	'</div>' +
        
        	'<div style="margin-top: 25px; text-align: center;">' +
        	'<button onclick="savePlayerEdit(' + playerId + ')" style="background: #4a7c59; color: white; border: none; padding: 10px 20px; border-radius: 5px; margin: 5px; cursor: pointer;">Ã°Å¸â€™Â¾ Sauvegarder</button>' +
        	'<button onclick="cancelPlayerEdit()" style="background: #6c757d; color: white; border: none; padding: 10px 20px; border-radius: 5px; margin: 5px; cursor: pointer;">Ã¢ÂÅ’ Annuler</button>' +
        	'</div>' +
        
        	'</div>' +
        	'</div>';
    
    	    // Ajouter le formulaire au body
    	    var formDiv = document.createElement('div');
    	    formDiv.id = 'editPlayerForm';
    	    formDiv.innerHTML = formHtml;
    	    document.body.appendChild(formDiv);
	}

	function savePlayerEdit(playerId) {
    	    var player = players.find(p => p.id === playerId);
    	    if (!player) return;
    
    	    var newFirstName = document.getElementById('editFirstName').value.trim();
    	    var newLastName = document.getElementById('editLastName').value.trim();
    	    var newPhone = document.getElementById('editPhone').value.trim();
    	    var newEmail = document.getElementById('editEmail').value.trim();
    	    var newHandicap = parseFloat(document.getElementById('editHandicap').value);
    	    var newDateJoined = document.getElementById('editDateJoined').value;
    
    	    // Validation
    	    if (!newFirstName || !newLastName) {
        	alert('Le prÃƒÂ©nom et le nom sont obligatoires.');
        	return;
    	    }
    
    	    if (isNaN(newHandicap) || newHandicap < 0 || newHandicap > 36.4) {
        	alert('Le handicap doit ÃƒÂªtre un nombre entre 0 et 36.4.');
        	return;
    	    }
    
    	    if (newEmail && !isValidEmail(newEmail)) {
        	alert('L\'adresse courriel n\'est pas valide.');
        	return;
    	    }
    
    	    // Mettre ÃƒÂ  jour
    	    player.firstName = newFirstName;
    	    player.lastName = newLastName;
    	    player.name = newFirstName + ' ' + newLastName;
    	    player.phone = newPhone;
    	    player.email = newEmail;
    	    player.handicap = newHandicap;
    	    player.dateJoined = newDateJoined;
    
    	    // Fermer le formulaire
    	    cancelPlayerEdit();
    
    	    // Recharger l'affichage
    	    loadPlayersGrid();
    
    	    alert('Ã¢Å“â€¦ Joueur "' + player.name + '" modifiÃƒÂ© avec succÃƒÂ¨s!');
	}

	function cancelPlayerEdit() {
    	    var formDiv = document.getElementById('editPlayerForm');
    	    if (formDiv) {
        	formDiv.remove();
    	    }
	}
		// Basculer le statut actif/inactif d'un joueur
		function togglePlayerStatus(playerId) {
    	    	    var player = players.find(p => p.id === playerId);
    	    	    if (!player) return;
    
    	    	    var action = player.active ? 'dÃƒÂ©sactiver' : 'rÃƒÂ©activer';
    	    	    if (confirm('Voulez-vous ' + action + ' le joueur "' + getPlayerName(player) + '"?')) {
        		player.active = !player.active;
        		savePlayersData();
        		loadPlayersGrid();
        
        		var status = player.active ? 'rÃƒÂ©activÃƒÂ©' : 'dÃƒÂ©sactivÃƒÂ©';
        		alert('Ã¢Å“â€¦ Joueur ' + status + ' avec succÃƒÂ¨s!');
    	    	    }
		}

	// Fonctions utilitaires
	function getAverageHandicap() {
    	    var activePlayers = players.filter(p => p.active);
    	    if (activePlayers.length === 0) return 0;
    
    	    var total = activePlayers.reduce((sum, p) => sum + p.handicap, 0);
    	    return total / activePlayers.length;
	}

	function getTotalGamesPlayed() {
    	    var total = 0;
    	    for (var i = 0; i < allScores.length; i++) {
        	total += allScores[i].filter(score => score > 0).length;
    	    }
    	    return total;
	}

	function formatDate(dateString) {
    	    if (!dateString) return 'Non dÃƒÂ©finie';
    	    var date = new Date(dateString);
    	    return date.toLocaleDateString('fr-FR');
	}

	function isValidEmail(email) {
    	    var emailRegex = /^[^\s@]+@[^\s@]+\.[^\s@]+$/;
    	    return emailRegex.test(email);
	}

	// Exporter les donnÃƒÂ©es des joueurs
	function exportPlayersData() {
    	    var dataToExport = {
        	players: players,
        	exportDate: new Date().toISOString(),
        	totalPlayers: players.length
    	    };
    
    	    var dataStr = JSON.stringify(dataToExport, null, 2);
    	    var dataBlob = new Blob([dataStr], {type: 'application/json'});
    
    	    var link = document.createElement('a');
    	    link.href = URL.createObjectURL(dataBlob);
    	    link.download = 'joueurs-golf-' + new Date().toISOString().split('T')[0] + '.json';
    	    link.click();
	}	

	// Importer les donnÃƒÂ©es des joueurs
	function importPlayersData() {
    	    document.getElementById('importFile').click();
	}

	function handleFileImport(event) {
    	    var file = event.target.files[0];
    	    if (!file) return;
    
    	    var reader = new FileReader();
    	    reader.onload = function(e) {
        	try {
            	    var importedData = JSON.parse(e.target.result);
            	    if (importedData.players && Array.isArray(importedData.players)) {
                	if (confirm('Cela va remplacer tous les joueurs existants. Continuer?')) {
                    	    players = importedData.players;
                    	    nextPlayerId = Math.max(...players.map(p => p.id)) + 1;
                    	    savePlayersData();
                    	    loadPlayersGrid();
                    	    alert('Ã¢Å“â€¦ Joueurs importÃƒÂ©s avec succÃƒÂ¨s!');
                	}	
            	    } else {
                	alert('Ã¢ÂÅ’ Format de fichier invalide.');
            	    }
        	} catch (error) {
            	    alert('Ã¢ÂÅ’ Erreur lors de l\'importation: ' + error.message);
        	}
    	    };
    	    reader.readAsText(file);
	}

	function savePlayersData() {
    	    // Simuler la sauvegarde
    	    console.log('Joueurs sauvegardÃƒÂ©s:', players.length + ' joueurs');
	}

	// 4. FONCTION UTILITAIRE POUR OBTENIR LE NOM DU JOUEUR (AJOUTEZ CETTE FONCTION)

	function getPlayerDisplayName(player) {
    	    if (player.name) {
        	return player.name;
    	    } else if (player.firstName && player.lastName) {
        	return player.firstName + ' ' + player.lastName;
    	    } else if (player.firstName) {
        	return player.firstName;
    	    } else {
        	return 'Joueur #' + player.id;
    	    }
	}

	// 5. FONCTION POUR RÃƒâ€°PARER TOUS LES NOMS AUTOMATIQUEMENT

	function fixAllPlayerNames() {
    	    console.log("RÃƒÂ©paration des noms de joueurs...");
    
    	    for (var i = 0; i < players.length; i++) {
        	var player = players[i];
        
        	// Si pas de nom mais firstName/lastName existent
        	if (!player.name && player.firstName && player.lastName) {
            	player.name = player.firstName + ' ' + player.lastName;
            	console.log("RÃƒÂ©parÃƒÂ©:", player.name);
        	}
        	// Si pas de firstName/lastName mais name existe
        	else if (player.name && (!player.firstName || !player.lastName)) {
            	    var parts = player.name.split(' ');
            	    player.firstName = parts[0] || '';
            	    player.lastName = parts.slice(1).join(' ') || '';
            	    console.log("AjoutÃƒÂ© firstName/lastName pour:", player.name);
        	}
    	    }
    
    	    // Mettre ÃƒÂ  jour tous les scores existants avec les bons noms
    	    for (var i = 0; i < scores.length; i++) {
        	var score = scores[i];
        	var player = players.find(p => p.id === score.playerId);
        	if (player && (!score.playerName || score.playerName === 'undefined')) {
            	    score.playerName = getPlayerDisplayName(player);
        	}
    	    }
    
    	    console.log("RÃƒÂ©paration terminÃƒÂ©e!");
	}

	// Variables globales pour la nouvelle partie
	var newRoundPlayers = {};

	// Afficher la section d'ajout de partie
	function showAddRound() {
    	hideAllSections();
    
    	// Masquer AUSSI le calendrier
    	var calendarSection = document.getElementById('calendar');
    	if (calendarSection) {
        	calendarSection.style.display = 'none';
        	calendarSection.classList.remove('active');
    	}
    
    	document.getElementById('addRound').style.display = 'block';
    	setActiveButton('showAddRound');
    	loadAddRoundInterface();
	}

	// Charger l'interface d'ajout de partie
	function loadAddRoundInterface() {
    	    // DÃƒÂ©finir la date d'aujourd'hui par dÃƒÂ©faut
    	    document.getElementById('newRoundDate').value = new Date().toISOString().split('T')[0];
    
    	    // Charger la liste des terrains
    	    loadCourseOptions();
    
    	    // Charger la grille des joueurs
    	    loadPlayersScoreGrid();
    
    	    // Initialiser les variables
    	    newRoundPlayers = {};

			// AJOUTER CETTE LIGNE :
    		updateGPROptions(); // Forcer l'affichage des options GPR si GPR est sÃƒÂ©lectionnÃƒÂ© par dÃƒÂ©faut
	}

	// Charger les options de terrains
	function loadCourseOptions() {
    	    var select = document.getElementById('newRoundCourse');
    	    select.innerHTML = '<option value="">-- SÃƒÂ©lectionner un terrain --</option>';
    
    	    var courseNames = Object.keys(coursesDatabase).sort();
    
    	    for (var i = 0; i < courseNames.length; i++) {
        	var courseName = courseNames[i];
        	var option = document.createElement('option');
        	option.value = courseName;
        	option.textContent = courseName;
        	select.appendChild(option);
    	    }
	}

	// Mettre ÃƒÂ  jour les dÃƒÂ©parts disponibles selon le terrain sÃƒÂ©lectionnÃƒÂ©
	function updateAvailableTees() {
    	    var courseName = document.getElementById('newRoundCourse').value;
    	    var teeSelect = document.getElementById('newRoundDefaultTee');
    
    	    teeSelect.innerHTML = '<option value="">-- Choisir --</option>';
    
    	    if (courseName && coursesDatabase[courseName]) {
        	var tees = coursesDatabase[courseName];
        
        	for (var i = 0; i < tees.length; i++) {
            	    var tee = tees[i];
            	    var option = document.createElement('option');
            	    option.value = tee.tee;
            	    option.textContent = tee.tee.charAt(0).toUpperCase() + tee.tee.slice(1) + 
                               	       ` (Rating: ${tee.rating}, Slope: ${tee.slope}, Par: ${tee.par})`;
            	    teeSelect.appendChild(option);
        	}
    	    }
	}

	// Charger la grille des joueurs pour saisie des scores
	function loadPlayersScoreGrid() {
    	    var html = '';
    
    	    for (var i = 0; i < players.length; i++) {
        	var player = players[i];
        	if (!player.active) continue; // Seulement les joueurs actifs
        
        	var playerName = player.name || (player.firstName + ' ' + player.lastName);
        
        	html += '<div class="course-card" id="playerCard_' + player.id + '">' +
                	'<div class="course-header">' +
                	'<label style="display: flex; align-items: center; gap: 10px;">' +
                	'<input type="checkbox" id="playerCheck_' + player.id + '" onchange="togglePlayerForRound(' + player.id + ')">' +
                	'<span><strong>' + playerName + '</strong></span>' +
                	'<span style="background: #e9ecef; padding: 2px 6px; border-radius: 10px; font-size: 11px;">H: ' + player.handicap.toFixed(1) + '</span>' +
                	'</label>' +
                	'</div>' +
                
                	'<div id="playerInputs_' + player.id + '" style="display: none; margin-top: 15px;">' +
                
                	'<div style="display: grid; grid-template-columns: 1fr 1fr; gap: 10px; margin-bottom: 15px;">' +
                	'<div>' +
                	'<label style="display: block; font-weight: bold; margin-bottom: 5px;">DÃƒÂ©part:</label>' +
                	'<select id="playerTee_' + player.id + '" style="width: 100%; padding: 6px;">' +
                	'<option value="">Utiliser dÃƒÂ©faut</option>' +
                	'</select>' +
                	'</div>' +
                	'<div>' +
                	'<label style="display: block; font-weight: bold; margin-bottom: 5px;">Score Brut:</label>' +
                	'<input type="number" id="playerScore_' + player.id + '" min="50" max="150" style="width: 100%; padding: 6px;" placeholder="Ex: 85">' +
                	'</div>' +
                	'</div>' +
                
                	'<div style="background: #f8f9fa; padding: 10px; border-radius: 5px; font-size: 12px;">' +
                	'<div id="playerPreview_' + player.id + '">SÃƒÂ©lectionnez d\'abord un terrain</div>' +
                	'</div>' +
                
                	'</div>' +
                	'</div>';
    	    }
    
    	    document.getElementById('playersScoreGrid').innerHTML = html;
	}

	// Activer/dÃƒÂ©sactiver un joueur pour la partie
	function togglePlayerForRound(playerId) {
    	    var checkbox = document.getElementById('playerCheck_' + playerId);
    	    var inputs = document.getElementById('playerInputs_' + playerId);
    	    var player = players.find(p => p.id === playerId);
    
    	    if (checkbox.checked) {
        	inputs.style.display = 'block';
        
        	// Initialiser les dÃƒÂ©parts disponibles pour ce joueur
        	updatePlayerTeeOptions(playerId);
        
        	// Ajouter ÃƒÂ  la liste
        	newRoundPlayers[playerId] = {
            	    player: player,
            	    tee: '',
            	    score: null
        	};
        
        	// Calculer l'aperÃƒÂ§u si un terrain est sÃƒÂ©lectionnÃƒÂ©
        	updatePlayerPreview(playerId);
        
    	    } else {
        	inputs.style.display = 'none';
        	delete newRoundPlayers[playerId];
    	    }
	}

	// Mettre ÃƒÂ  jour les options de dÃƒÂ©part pour un joueur
	function updatePlayerTeeOptions(playerId) {
    	    var courseName = document.getElementById('newRoundCourse').value;
    	    var defaultTee = document.getElementById('newRoundDefaultTee').value;
    	    var playerTeeSelect = document.getElementById('playerTee_' + playerId);
    
    	    playerTeeSelect.innerHTML = '<option value="">Utiliser dÃƒÂ©faut (' + (defaultTee || 'non dÃƒÂ©fini') + ')</option>';
    
    	    if (courseName && coursesDatabase[courseName]) {
        	var tees = coursesDatabase[courseName];
        
        	for (var i = 0; i < tees.length; i++) {
            	    var tee = tees[i];
            	    var option = document.createElement('option');
            	    option.value = tee.tee;
            	    option.textContent = tee.tee.charAt(0).toUpperCase() + tee.tee.slice(1);
            	    playerTeeSelect.appendChild(option);
        	}
    	    }
	}

	// Mettre ÃƒÂ  jour l'aperÃƒÂ§u pour un joueur
	function updatePlayerPreview(playerId) {
    	    var courseName = document.getElementById('newRoundCourse').value;
    	    var defaultTee = document.getElementById('newRoundDefaultTee').value;
    	    var playerTee = document.getElementById('playerTee_' + playerId).value || defaultTee;
    	    var playerScore = parseInt(document.getElementById('playerScore_' + playerId).value);
    	    var player = players.find(p => p.id === playerId);
    
    	    var previewDiv = document.getElementById('playerPreview_' + playerId);
    
    	    if (!courseName || !playerTee) {
        	previewDiv.innerHTML = 'SÃƒÂ©lectionnez un terrain et un dÃƒÂ©part';
        	return;
    	    }
    
    	    // Calculer le handicap de parcours
    	    var courseHandicap = calculateCourseHandicap(player.handicap, courseName, playerTee);
    	    var netScore = playerScore ? (playerScore - courseHandicap).toFixed(1) : '?';
    
    	    var html = '<strong>AperÃƒÂ§u:</strong><br>' +
               	       'DÃƒÂ©part: ' + playerTee + ' | ' +
               	       'Handicap parcours: ' + courseHandicap.toFixed(1) + '<br>' +
               	       'Score net: ' + (playerScore ? playerScore + ' - ' + courseHandicap.toFixed(1) + ' = ' + netScore : 'En attente du score');
    
    	    previewDiv.innerHTML = html;
	}

	// Fonctions de sÃƒÂ©lection rapide
	function selectAllPlayersForRound() {
    	    for (var i = 0; i < players.length; i++) {
        	var player = players[i];
        	if (player.active) {
            	    var checkbox = document.getElementById('playerCheck_' + player.id);
            	    if (!checkbox.checked) {
                	checkbox.checked = true;
                	togglePlayerForRound(player.id);
            	    }
        	}
    	    }
	}

	function clearAllPlayersForRound() {
    	    for (var playerId in newRoundPlayers) {
        	var checkbox = document.getElementById('playerCheck_' + playerId);
        	checkbox.checked = false;
        	togglePlayerForRound(parseInt(playerId));
    	    }
	}

	function selectFrequentPlayers() {
    	    // SÃƒÂ©lectionner les joueurs qui ont jouÃƒÂ© le plus de parties
    	    var playerGameCounts = [];
    
    	    for (var i = 0; i < players.length; i++) {
        	var player = players[i];
        	if (player.active) {
            	    var gameCount = allScores[i] ? allScores[i].filter(score => score > 0).length : 0;
            	    playerGameCounts.push({
                	playerId: player.id,
                	gameCount: gameCount
            	    });
        	}
    	    }
    
    	    // Trier par nombre de parties et prendre les 8 premiers
    	    playerGameCounts.sort((a, b) => b.gameCount - a.gameCount);
    	    var topPlayers = playerGameCounts.slice(0, 8);
    
    	    // DÃƒÂ©sÃƒÂ©lectionner tous d'abord
    	    clearAllPlayersForRound();
    
    	    // SÃƒÂ©lectionner les joueurs frÃƒÂ©quents
    	    for (var i = 0; i < topPlayers.length; i++) {
        	var playerId = topPlayers[i].playerId;
        	var checkbox = document.getElementById('playerCheck_' + playerId);
        	checkbox.checked = true;
        	togglePlayerForRound(playerId);
    	    }
	}

	// AperÃƒÂ§u de la partie
	function previewNewRound() {
    	    var date = document.getElementById('newRoundDate').value;
    	    var courseName = document.getElementById('newRoundCourse').value;
    	    var roundType = document.getElementById('newRoundType').value;
    
    	    if (!date || !courseName) {
        	alert('Veuillez sÃƒÂ©lectionner une date et un terrain.');
        	return;
    	    }
    
    	    var selectedPlayers = Object.keys(newRoundPlayers);
    	    if (selectedPlayers.length === 0) {
        	alert('Veuillez sÃƒÂ©lectionner au moins un joueur.');
        	return;
    	    }
    
    	    // Collecter les donnÃƒÂ©es
    	    var roundData = [];
    	    var hasAllScores = true;
    
    	    for (var i = 0; i < selectedPlayers.length; i++) {
        	var playerId = parseInt(selectedPlayers[i]);
        	var player = players.find(p => p.id === playerId);
        	var defaultTee = document.getElementById('newRoundDefaultTee').value;
        	var playerTee = document.getElementById('playerTee_' + playerId).value || defaultTee;
        	var playerScore = parseInt(document.getElementById('playerScore_' + playerId).value);
        
        	if (!playerScore || !playerTee) {
            	    hasAllScores = false;
        	}
        
        	var courseHandicap = playerTee ? calculateCourseHandicap(player.handicap, courseName, playerTee) : 0;
        	var netScore = playerScore ? playerScore - courseHandicap : null;
        
        	roundData.push({
            	    player: player,
            	    tee: playerTee,
            	    score: playerScore,
            	    courseHandicap: courseHandicap,
            	    netScore: netScore
        	});
    	    }
    
    	    // Trier par score net
    	    roundData.sort((a, b) => {
        	if (!a.netScore) return 1;
        	if (!b.netScore) return -1;
        	return a.netScore - b.netScore;
    	    });
    
    	    // GÃƒÂ©nÃƒÂ©rer l'aperÃƒÂ§u
    	    var html = '<h4>Ã°Å¸â€œÅ  AperÃƒÂ§u de la Partie</h4>' +
               	       '<p><strong>Date:</strong> ' + new Date(date).toLocaleDateString('fr-FR') + '</p>' +
               	       '<p><strong>Terrain:</strong> ' + courseName + '</p>' +
               	       '<p><strong>Type:</strong> ' + (roundType === 'diablo' ? 'Ã°Å¸Ââ€  Diablo' : roundType === 'gpr' ? 'Ã°Å¸Å½Â¯ GPR' : 'Ã¢â€ºÂ³ Amicale') + '</p>' +
               	       '<p><strong>Joueurs:</strong> ' + selectedPlayers.length + '</p>';
    
    	    if (!hasAllScores) {
        	    html += '<div style="background: #fff3cd; padding: 10px; border-radius: 5px; margin: 10px 0;">' +
                	'Ã¢Å¡Â Ã¯Â¸Â Certains scores ou dÃƒÂ©parts sont manquants</div>';
    	    }
    
    	    html += '<table class="table">' +
            	    '<thead><tr><th>Pos.</th><th>Joueur</th><th>DÃƒÂ©part</th><th>Score Brut</th><th>Handicap</th><th>Score Net</th></tr></thead>' +
            	    '<tbody>';
    
    	    for (var i = 0; i < roundData.length; i++) {
        	var data = roundData[i];
        	var playerName = data.player.name || (data.player.firstName + ' ' + data.player.lastName);
        
        	html += '<tr>' +
                	'<td>' + (data.netScore ? (i + 1) : '-') + '</td>' +
                	'<td><strong>' + playerName + '</strong></td>' +
                	'<td>' + (data.tee || 'Ã¢ÂÅ’') + '</td>' +
                	'<td>' + (data.score || 'Ã¢ÂÅ’') + '</td>' +
                	'<td>' + (data.tee ? data.courseHandicap.toFixed(1) : '-') + '</td>' +
                	'<td><strong>' + (data.netScore ? data.netScore.toFixed(1) : 'Ã¢ÂÅ’') + '</strong></td>' +
                	'</tr>';
    	    }
    
    	    html += '</tbody></table>';
    
    	    document.getElementById('previewContent').innerHTML = html;
    	    document.getElementById('newRoundPreview').style.display = 'block';
	}

    function saveAllToFirebase() {
        showLoading('Sauvegarde en cours...');
    
        Promise.all([
            savePlayersToFirebase(),
            saveScoresToFirebase(),
            saveCoursesToFirebase(),
            saveDatesToFirebase(),
			saveRoundsToFirebase(),
			saveCalendarToFirebase()
        ]).then(function() {
            hideLoading();
            alert('Ã¢Å“â€¦ Toutes les donnÃƒÂ©es sauvegardÃƒÂ©es avec succÃƒÂ¨s!');
        }).catch(function(error) {
            hideLoading();
            console.error('Erreur de sauvegarde complÃƒÂ¨te:', error);
            alert('Ã¢ÂÅ’ Erreur de sauvegarde: ' + error.message);
        });
    }
    
	// Ã°Å¸â€Â§ FONCTION saveNewRound() - Version originale avec corrections minimales
	async function saveNewRound() {
    	await ensurePlayersDataLoaded(); // Ã¢â€ Â SEULE LIGNE AJOUTÃƒâ€°E
    
    	console.log('=== FONCTION saveNewRound() APPELÃƒâ€°E ===');

    	var date = document.getElementById('newRoundDate').value;
    	var courseName = document.getElementById('newRoundCourse').value;
    	var defaultTee = document.getElementById('newRoundDefaultTee').value;
    	var roundType = document.getElementById('newRoundType').value;

    	console.log('=== DEBUG DATE ===');
    	console.log('Date rÃƒÂ©cupÃƒÂ©rÃƒÂ©e du formulaire:', date);
    	console.log('Type de la variable date:', typeof date);

    	// Validation de base
    	if (!date || !courseName || !defaultTee) {
        	alert('Veuillez remplir tous les champs obligatoires (date, terrain, dÃƒÂ©part par dÃƒÂ©faut).');
        	return;
    	}

    	var selectedPlayers = Object.keys(newRoundPlayers);
    	if (selectedPlayers.length === 0) {
        	alert('Veuillez sÃƒÂ©lectionner au moins un joueur.');
        	return;
    	}

    	// Validation des scores
    	var missingScores = [];
    	var invalidScores = [];
    
    	for (var i = 0; i < selectedPlayers.length; i++) {
        	var playerId = parseInt(selectedPlayers[i]);
        	var scoreInput = document.getElementById('playerScore_' + playerId);
			var teeInput = document.getElementById('playerTee_' + playerId);
        
        	if (!scoreInput || !scoreInput.value) {
            	var player = players.find(p => p.id === playerId);
            	missingScores.push(player ? player.name : 'Joueur #' + playerId);
        	} else {
            	var score = parseInt(scoreInput.value);
            	if (isNaN(score) || score < 50 || score > 150) {
                	var player = players.find(p => p.id === playerId);
                	invalidScores.push(player ? player.name : 'Joueur #' + playerId);
            	}
        	}
    	}
    
    	if (missingScores.length > 0) {
        	alert('Scores manquants pour: ' + missingScores.join(', '));
        	return;
    	}
    
    	if (invalidScores.length > 0) {
        	alert('Scores invalides pour: ' + invalidScores.join(', ') + '\nLe score doit ÃƒÂªtre entre 50 et 150.');
        	return;
    	}

    	// GÃƒÂ©nÃƒÂ©rer un ID unique pour cette partie
    	var newRoundId = Date.now();
    	console.log('Nouveau Round ID:', newRoundId);

    	// CrÃƒÂ©er l'objet round
    	var newRound = {
        	id: newRoundId,
        	date: date,
        	course: courseName,
        	type: roundType
    	};

    	// Ajouter les dÃƒÂ©tails GPR si nÃƒÂ©cessaire
    	if (roundType === 'gpr') {
        	newRound.gprPhase = document.getElementById('newRoundGprPhase').value;
        	if (newRound.gprPhase === 'finale') {
            	newRound.gprFinaleFormat = document.getElementById('newRoundFinaleFormat').value;
        	}
    	}

    	// ===== CONFIRMATION AVANT SAUVEGARDE =====
    	var recipients = [];
    	for (var j = 0; j < selectedPlayers.length; j++) {
    		var pid = parseInt(selectedPlayers[j]);
    		var pl = players.find(function(p) { return p.id === pid; });
    		if (pl && pl.email) recipients.push(pl);
    	}
    	var confirmData = { date: date, course: courseName, scores: selectedPlayers };
    	var confirmed = await saveWithConfirmation('round', confirmData, recipients);
    	if (!confirmed) {
    		console.log('Sauvegarde annulÃ©e');
    		return;
    	}

    	// Ajouter ÃƒÂ  la liste des rounds
    	if (!rounds) rounds = [];
    	rounds.push(newRound);

    	// Mettre ÃƒÂ  jour les tableaux parallÃƒÂ¨les
    	dates.push(date);
    	courses.push(courseName);

    	// Traiter les scores des joueurs
    	for (var i = 0; i < selectedPlayers.length; i++) {
        	var playerId = parseInt(selectedPlayers[i]);
        	var player = players.find(p => p.id === playerId);
        
        	var scoreValue = parseInt(document.getElementById('playerScore_' + playerId).value);
			var teeValue = document.getElementById('playerTee_' + playerId).value;
        
        	// Calculer le handicap de parcours et le score net
        	var courseHandicap = calculateCourseHandicap(player.handicap, courseName, teeValue);
        	var netScore = scoreValue - courseHandicap;
        
        	// CrÃƒÂ©er l'objet score
        	var playerScore = {
            	roundId: newRoundId,
            	playerId: playerId,
            	playerName: player.name || (player.firstName + ' ' + player.lastName),
            	score: scoreValue,
            	net: netScore,
            	courseHandicap: courseHandicap,
            	tee: teeValue,
            	date: date
        	};
        
        	scores.push(playerScore);
        
        	// Mettre ÃƒÂ  jour allScores
        	var playerIndex = players.findIndex(p => p.id === playerId);
        	if (playerIndex !== -1) {
        	    allScores[playerIndex].push(scoreValue);
        	}
    	}

    	// Sauvegarder dans Firebase
        Promise.all([
            saveScoresToFirebase(),
            saveDatesToFirebase(),
            saveRoundsToFirebase()  // Ã¢â€ Â AJOUT DE CETTE LIGNE MANQUANTE
        ]).then(function() {
            console.log('Nouvelle partie sauvegardÃƒÂ©e dans Firebase');
    
            // Confirmation et nettoyage
            // Ã°Å¸â€Â¥ NOTIFICATION: Partie terminÃƒÂ©e
            var roundScores = scores.filter(s => s.roundId === newRoundId);
            if (roundScores.length > 0) {
                var roundRanking = [...roundScores].sort((a, b) => a.net - b.net);
    
                var emailsSent = 0;
                for (var i = 0; i < roundScores.length; i++) {
                    var playerScore = roundScores[i];
                    var player = players.find(p => p.id === playerScore.playerId);
        
                    if (player && player.email) {
                        var playerPosition = roundRanking.findIndex(r => r.playerId === playerScore.playerId) + 1;
            
                        var notificationData = {
                            round: newRound,
                            playerScore: playerScore,
                            playerPosition: playerPosition,
                            roundRanking: roundRanking
                        };
            
                        sendEmailNotification('results', [player], notificationData);
                        emailsSent++;
                    }
                }
    
                if (emailsSent > 0) {
                    showToast('âœ… Partie enregistrÃ©e! ' + emailsSent + ' email(s) envoyÃ©(s).', false);
                } else {
                    showToast('âœ… Partie enregistrÃ©e avec succÃ¨s!', false);
                }
            } else {
                showToast('âœ… Partie enregistrÃ©e avec succÃ¨s!', false);
            }

            resetNewRoundForm();
            resetNewRoundForm();
            // Afficher les dÃ©tails de la partie
            showDetails();
            setTimeout(function() {
                document.getElementById('roundSelect').value = newRoundId;
                showRoundDetail();
            }, 100);
    
        }).catch(function(error) {
            console.error('Erreur de sauvegarde partie:', error);
            alert('Erreur de sauvegarde: ' + error.message);
        });
	}

	// RÃƒÂ©initialiser le formulaire
	function resetNewRoundForm() {
    	    document.getElementById('newRoundDate').value = new Date().toISOString().split('T')[0];
    	    document.getElementById('newRoundCourse').value = '';
    	    document.getElementById('newRoundDefaultTee').innerHTML = '<option value="">-- Choisir --</option>';
    	    document.getElementById('newRoundType').value = 'gpr';
    	    document.getElementById('newRoundPreview').style.display = 'none';
    
    	    clearAllPlayersForRound();
    	    loadPlayersScoreGrid();
	}

	// === FONCTIONS DE GESTION DES PARTIES ===

	// Supprimer une partie complÃƒÂ¨tement
	function deleteRound(roundId) {
    	if (!confirm('Ã¢Å¡Â Ã¯Â¸Â ATTENTION ! Supprimer dÃƒÂ©finitivement cette partie ?\n\nCette action ne peut pas ÃƒÂªtre annulÃƒÂ©e.')) {
        	return;
    	}
    
    	console.log('Suppression de la partie ID:', roundId);
    
    	// Trouver l'index de la partie dans les arrays
    	var roundIndex = rounds.findIndex(r => r.id === roundId);
    	var dateIndex = roundIndex;
    
    	if (roundIndex === -1) {
        	alert('Ã¢ÂÅ’ Partie non trouvÃƒÂ©e !');
        	return;
    	}
    
    	// Supprimer de rounds
    	rounds.splice(roundIndex, 1);
    
    	// Supprimer de dates, courses, teeUsed
    	if (dateIndex !== -1) {
        	dates.splice(dateIndex, 1);
        	courses.splice(dateIndex, 1);
        	teeUsed.splice(dateIndex, 1);
    	}
    
    	// Supprimer les scores de tous les joueurs pour cette partie
    	for (var i = 0; i < allScores.length; i++) {
        	if (allScores[i] && dateIndex !== -1) {
            	allScores[i].splice(dateIndex, 1);
        	}
    	}
    
    	// Supprimer de l'array scores
    	scores = scores.filter(s => s.roundId !== roundId);
    
    	// Supprimer des mÃƒÂ©tadonnÃƒÂ©es GPR
    	gprRoundsData = gprRoundsData.filter(g => g.roundId !== roundId);
    
    	// Sauvegarder dans Firebase
    	Promise.all([
        	saveScoresToFirebase(),
        	saveDatesToFirebase()
    	]).then(function() {
        	console.log('Partie supprimÃƒÂ©e de Firebase');
        	alert('Ã¢Å“â€¦ Partie supprimÃƒÂ©e avec succÃƒÂ¨s !');
        
        	// RafraÃƒÂ®chir l'affichage
        	if (document.getElementById('details').style.display === 'block') {
            	loadDetails();
        	}
        	if (document.getElementById('gpr').style.display === 'block') {
            	loadGPR();
        	}
        	if (document.getElementById('diablo').style.display === 'block') {
            	loadDiablo();
        	}
        
    	}).catch(function(error) {
        	console.error('Erreur de suppression:', error);
        	alert('Ã¢ÂÅ’ Erreur lors de la suppression: ' + error.message);
    	});
	}

	// Afficher le formulaire de modification d'une partie
	function editRound(roundId) {
    	var round = rounds.find(r => r.id === roundId);
    	if (!round) {
        	alert('Ã¢ÂÅ’ Partie non trouvÃƒÂ©e !');
        	return;
    	}
    
    	// CrÃƒÂ©er la popup de modification
    	var formHtml = 
        	'<div style="position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.5); z-index: 1000; overflow-y: auto;">' +
        	'<div style="background: white; padding: 30px; margin: 50px auto; border-radius: 10px; box-shadow: 0 4px 20px rgba(0,0,0,0.3); max-width: 800px; width: 90%;">' +
        	'<h3 style="margin-top: 0; color: #2c5530;">Ã¢Å“ÂÃ¯Â¸Â Modifier la Partie</h3>' +
        
        	'<div style="margin: 15px 0;">' +
        	'<label style="display: block; font-weight: bold; margin-bottom: 5px;">Date:</label>' +
        	'<input type="date" id="editRoundDate" value="' + round.date + '" style="width: 200px; padding: 8px; border: 1px solid #ddd; border-radius: 4px;">' +
        	'</div>' +
        
        	'<div style="margin: 15px 0;">' +
        	'<label style="display: block; font-weight: bold; margin-bottom: 5px;">Terrain:</label>' +
        	'<select id="editRoundCourse" style="width: 300px; padding: 8px;">';
    
    	// Ajouter les options de terrains
    	var courseNames = Object.keys(coursesDatabase).sort();
    	for (var i = 0; i < courseNames.length; i++) {
        	var selected = courseNames[i] === round.course ? ' selected' : '';
			var courseName = courseNames[i].replace(/"/g, '&quot;');
			formHtml += '<option value="' + courseName + '"' + selected + '>' + courseNames[i] + '</option>';
    	}
    
    	formHtml += '</select></div>' +
        
        	'<div style="margin: 15px 0;">' +
        	'<label style="display: block; font-weight: bold; margin-bottom: 5px;">Type:</label>' +
        	'<select id="editRoundType" style="width: 200px; padding: 8px;" onchange="updateEditGPROptions()">' +
        	'<option value="gpr"' + (round.type === 'gpr' ? ' selected' : '') + '>Ã°Å¸Å½Â¯ GPR</option>' +
        	'<option value="diablo"' + (round.type === 'diablo' ? ' selected' : '') + '>Ã°Å¸Ââ€  Diablo</option>' +
        	'<option value="amicale"' + (round.type === 'amicale' ? ' selected' : '') + '>Ã¢â€ºÂ³ Amicale</option>' +
        	'</select>' +
        	'</div>' +
        
        	// Options GPR
        	'<div id="editGprOptions" style="display: ' + (round.type === 'gpr' ? 'block' : 'none') + '; margin: 15px 0; padding: 15px; background: #e7f3ff; border-radius: 8px;">' +
        	'<h4 style="margin-top: 0;">Ã¢Å¡â„¢Ã¯Â¸Â Configuration GPR</h4>' +
        	'<div style="margin: 10px 0;">' +
       		'<label style="display: block; font-weight: bold; margin-bottom: 5px;">Phase GPR:</label>' +
        	'<select id="editGprPhase" style="width: 200px; padding: 8px;" onchange="updateEditFinaleOptions()">' +
        	'<option value="exhibition"' + (round.gprPhase === 'exhibition' ? ' selected' : '') + '>Ã°Å¸â€œÅ  Exhibition</option>' +
        	'<option value="finale"' + (round.gprPhase === 'finale' ? ' selected' : '') + '>Ã°Å¸Ââ€  Finale</option>' +
        	'</select>' +
        	'</div>' +
        	'<div id="editFinaleOptions" style="display: ' + (round.gprPhase === 'finale' ? 'block' : 'none') + '; margin: 10px 0;">' +
        	'<label style="display: block; font-weight: bold; margin-bottom: 5px;">Format finale:</label>' +
        	'<select id="editFinaleFormat" style="width: 200px; padding: 8px;">' +
        	'<option value="2days"' + (round.gprFinaleFormat === '2days' ? ' selected' : '') + '>Ã°Å¸â€œâ€¦ Finale 2 jours</option>' +
        	'<option value="1day"' + (round.gprFinaleFormat === '1day' ? ' selected' : '') + '>Ã¢Å¡Â¡ Finale 1 jour</option>' +
        	'</select>' +
        	'</div>' +
        	'</div>' +
        
        	'<h4>Ã°Å¸â€˜Â¥ Scores des Joueurs</h4>' +
        	'<div id="editPlayersScores" style="max-height: 300px; overflow-y: auto; border: 1px solid #ddd; padding: 15px; border-radius: 5px;">';
    
    	// Ajouter les scores des joueurs
    	var roundScores = scores.filter(s => s.roundId === roundId);
    	for (var i = 0; i < roundScores.length; i++) {
        	var score = roundScores[i];
        	formHtml += '<div style="display: flex; align-items: center; gap: 15px; margin: 10px 0; padding: 10px; background: #f8f9fa; border-radius: 5px;">' +
            	'<span style="width: 150px; font-weight: bold;">' + score.playerName + '</span>' +
            	'<label>Score: <input type="number" id="editScore_' + score.playerId + '" value="' + score.score + '" min="50" max="150" style="width: 80px; padding: 5px;"></label>' +
            	'<span style="font-size: 12px; color: #666;">Handicap: ' + score.courseHandicap.toFixed(1) + ' | Net: ' + score.net.toFixed(1) + '</span>' +
            	'</div>';
    	}
    
    	formHtml += '</div>' +
        
        	'<div style="margin-top: 25px; text-align: center;">' +
        	'<button onclick="saveRoundEdit(' + roundId + ')" style="background: #4a7c59; color: white; border: none; padding: 12px 24px; border-radius: 5px; margin: 5px; cursor: pointer; font-size: 16px;">Ã°Å¸â€™Â¾ Sauvegarder</button>' +
        	'<button onclick="cancelRoundEdit()" style="background: #6c757d; color: white; border: none; padding: 12px 24px; border-radius: 5px; margin: 5px; cursor: pointer; font-size: 16px;">Ã¢ÂÅ’ Annuler</button>' +
        	'<button onclick="deleteRound(' + roundId + ')" style="background: #dc3545; color: white; border: none; padding: 12px 24px; border-radius: 5px; margin: 5px; cursor: pointer; font-size: 16px;">Ã°Å¸â€”â€˜Ã¯Â¸Â Supprimer</button>' +
        	'</div>' +
        
        	'</div></div>';
    
    	// Ajouter la popup au body
    	var popup = document.createElement('div');
    	popup.id = 'editRoundPopup';
    	popup.innerHTML = formHtml;
    	document.body.appendChild(popup);
	}

	// Fonctions auxiliaires pour la modification
	function updateEditGPROptions() {
    	var roundType = document.getElementById('editRoundType').value;
    	var gprOptions = document.getElementById('editGprOptions');
    
    	if (roundType === 'gpr') {
        	gprOptions.style.display = 'block';
    	} else {
        	gprOptions.style.display = 'none';
    	}
	}

	function updateEditFinaleOptions() {
    	var gprPhase = document.getElementById('editGprPhase').value;
    	var finaleOptions = document.getElementById('editFinaleOptions');
    
    	if (gprPhase === 'finale') {
        	finaleOptions.style.display = 'block';
    	} else {
        	finaleOptions.style.display = 'none';
    	}
	}

	// Sauvegarder les modifications
	function saveRoundEdit(roundId) {
    	var newDate = document.getElementById('editRoundDate').value;
    	var newCourse = document.getElementById('editRoundCourse').value;
    	var newType = document.getElementById('editRoundType').value;
    	var newGprPhase = document.getElementById('editGprPhase').value;
    	var newFinaleFormat = document.getElementById('editFinaleFormat').value;
    
    	if (!confirm('Sauvegarder les modifications de cette partie ?')) {
        	return;
    	}
    
    	// Mettre ÃƒÂ  jour l'objet round
    	var round = rounds.find(r => r.id === roundId);
    	var roundIndex = rounds.findIndex(r => r.id === roundId);
    	var dateIndex = roundIndex;
    
    	if (round && roundIndex !== -1) {
        	// Mettre ÃƒÂ  jour les donnÃƒÂ©es de base
        	round.date = newDate;
        	round.course = newCourse;
        	round.type = newType;
        
        	if (newType === 'gpr') {
            	round.gprPhase = newGprPhase;
            	round.gprFinaleFormat = newFinaleFormat;
        	}
        
        	// Mettre ÃƒÂ  jour les arrays parallÃƒÂ¨les (utiliser roundIndex au lieu de dateIndex)
			if (roundIndex !== -1) {
    			dates[roundIndex] = newDate;
    			courses[roundIndex] = newCourse;
    			// Garder le mÃƒÂªme tee pour simplicitÃƒÂ©, ou ajouter une option pour le modifier
			}
        
        	// Mettre ÃƒÂ  jour les scores des joueurs
        	var roundScores = scores.filter(s => s.roundId === roundId);
        	for (var i = 0; i < roundScores.length; i++) {
            	var score = roundScores[i];
            	var newScore = parseInt(document.getElementById('editScore_' + score.playerId).value);
            
            	if (newScore && newScore !== score.score) {
                	// Recalculer le handicap de parcours et le net
                	var player = players.find(p => p.id === score.playerId);
                	var teeForPlayer = (score.playerId === 1) ? 'bleu' : 'blanc'; // Logique simplifiÃƒÂ©e
                	var courseHandicap = calculateCourseHandicap(player.handicap, newCourse, teeForPlayer);
                	var netScore = newScore - courseHandicap;
                
                	// Mettre ÃƒÂ  jour le score
                	score.score = newScore;
                	score.net = netScore;
                	score.courseHandicap = courseHandicap;
                
                	// Mettre ÃƒÂ  jour allScores
                	var playerIndex = players.findIndex(p => p.id === score.playerId);
                	if (playerIndex !== -1 && dateIndex !== -1) {
                    	allScores[playerIndex][dateIndex] = newScore;
                	}
            	}
        	}
        
        	// Sauvegarder dans Firebase
        	Promise.all([
            	saveScoresToFirebase(),
            	saveDatesToFirebase()
        	]).then(function() {
            	console.log('Modifications sauvegardÃƒÂ©es dans Firebase');
            	alert('Ã¢Å“â€¦ Partie modifiÃƒÂ©e avec succÃƒÂ¨s !');
            	cancelRoundEdit();
            
            	// RafraÃƒÂ®chir l'affichage
            	if (document.getElementById('details').style.display === 'block') {
                	loadDetails();
                	document.getElementById('roundSelect').value = roundId;
                	showRoundDetail();
            	}
            
        	}).catch(function(error) {
            	console.error('Erreur de modification:', error);
            	alert('Ã¢ÂÅ’ Erreur lors de la modification: ' + error.message);
        	});
    	}
	}

	// Fermer la popup de modification
	function cancelRoundEdit() {
    	var popup = document.getElementById('editRoundPopup');
    	if (popup) {
        	popup.remove();
    	}
	}

	// Fonction pour gÃƒÂ©nÃƒÂ©rer des scores de test
	function generateTestRound() {
    	if (!confirm('GÃƒÂ©nÃƒÂ©rer une partie de test avec des scores alÃƒÂ©atoires ?')) {
        	return;
    	}
    
    	// SÃƒÂ©lectionner un terrain au hasard
    	var courseNames = Object.keys(coursesDatabase);
    	var randomCourse = courseNames[Math.floor(Math.random() * courseNames.length)];
    
    	// Date d'aujourd'hui
    	var today = new Date().toISOString().split('T')[0];
    
    	// SÃƒÂ©lectionner 6-8 joueurs actifs au hasard
    	var activePlayers = players.filter(p => p.active);
    	var numPlayers = Math.floor(Math.random() * 3) + 6; // 6 ÃƒÂ  8 joueurs
    	var selectedPlayers = [];
    
    	for (var i = 0; i < Math.min(numPlayers, activePlayers.length); i++) {
        	var randomIndex = Math.floor(Math.random() * activePlayers.length);
        	var player = activePlayers[randomIndex];
        	if (selectedPlayers.findIndex(p => p.id === player.id) === -1) {
            	selectedPlayers.push(player);
        	}
    	}
    
    	// GÃƒÂ©nÃƒÂ©rer les scores (par + handicap Ã‚Â± variation alÃƒÂ©atoire)
    	var newRoundId = rounds.length + 1;
    	var year = parseInt(today.split('-')[0]);
    	var month = parseInt(today.split('-')[1]);
    
    	// Ajouter la partie
    	rounds.push({
        	id: newRoundId,
        	date: today,
        	course: randomCourse,
        	tee: 'blanc',
        	type: 'gpr',
        	year: year,
        	month: month
    	});
    
    	dates.push(today);
    	courses.push(randomCourse);
    	teeUsed.push('blanc');
    
    	// Ãƒâ€°tendre allScores
    	for (var i = 0; i < allScores.length; i++) {
        	allScores[i].push(null);
    	}
    
    	// GÃƒÂ©nÃƒÂ©rer les scores
    	for (var i = 0; i < selectedPlayers.length; i++) {
        	var player = selectedPlayers[i];
        	var playerIndex = players.findIndex(p => p.id === player.id);
        
        	// Score = 72 (par moyen) + handicap + variation (-5 ÃƒÂ  +10)
        	var baseScore = 72 + player.handicap;
        	var variation = Math.floor(Math.random() * 16) - 5; // -5 ÃƒÂ  +10
        	var testScore = Math.max(65, Math.min(120, Math.round(baseScore + variation)));
        
        	// Sauvegarder le score
        	allScores[playerIndex][allScores[playerIndex].length - 1] = testScore;
        
        	// Calculer handicap de parcours et net
        	var teeForPlayer = (player.id === 1) ? 'blanc' : 'blanc';
        	var courseHandicap = calculateCourseHandicap(player.handicap, randomCourse, teeForPlayer);
        	var netScore = testScore - courseHandicap;
        	var playerName = player.name || (player.firstName + ' ' + player.lastName);
        
        	scores.push({
            	roundId: newRoundId,
            	playerId: player.id,
            	playerName: playerName,
            	score: testScore,
            	courseHandicap: courseHandicap,
            	net: netScore,
            	tee: teeForPlayer,
            	type: 'gpr',
            	year: year,
            	month: month
        	});
    	}
    
    	// Sauvegarder
    	Promise.all([
        	saveScoresToFirebase(),
        	saveDatesToFirebase()
    	]).then(function() {
        	alert('Ã¢Å“â€¦ Partie de test gÃƒÂ©nÃƒÂ©rÃƒÂ©e avec ' + selectedPlayers.length + ' joueurs !\nTerrain: ' + randomCourse);
        
        	// Aller voir la partie
        	showDetails();
        	loadDetails();
        	document.getElementById('roundSelect').value = newRoundId;
        	showRoundDetail();
        
    	}).catch(function(error) {
        	console.error('Erreur gÃƒÂ©nÃƒÂ©ration test:', error);
        	alert('Ã¢ÂÅ’ Erreur: ' + error.message);
    	});
	}
	// Nouvelles fonctions pour le systÃƒÂ¨me GPR

	// Afficher/masquer les options GPR
	function updateGPROptions() {
   		console.log('updateGPROptions appelÃƒÂ©e'); // Pour debug
    	var roundType = document.getElementById('newRoundType').value;
    	var gprOptions = document.getElementById('gprOptions');
    
    	console.log('Type sÃƒÂ©lectionnÃƒÂ©:', roundType); // Pour debug
    
    	if (roundType === 'gpr') {
        	gprOptions.style.display = 'block';
        	console.log('Options GPR affichÃƒÂ©es'); // Pour debug
    	} else {
        	gprOptions.style.display = 'none';
        	console.log('Options GPR masquÃƒÂ©es'); // Pour debug
    	}
	}

	// Afficher/masquer les options de finale
	function updateFinaleOptions() {
    	var gprPhase = document.getElementById('gprPhase').value;
    	var finaleOptions = document.getElementById('finaleOptions');
    
    	if (gprPhase === 'finale') {
        	finaleOptions.style.display = 'block';
    	} else {
        	finaleOptions.style.display = 'none';
    	}
	}

	// Calculer les points GPR selon les nouvelles rÃƒÂ¨gles
	function calculateGPRPoints(position, isNet, isFinale, finaleFormat) {
    	// Points exhibition
    	var exhibitionBrutPoints = [80, 68, 60, 52, 45, 40, 35, 30, 25, 20, 15, 10];
    	var exhibitionNetPoints = [120, 105, 90, 78, 70, 62, 54, 46, 38, 30, 22, 15];
    
    	// Points finale (base pour 2 jours - 200 points par jour)
    	var finaleBrutPoints = [175, 140, 120, 100, 85, 70, 60, 50, 40, 30, 20, 10];
    	var finaleNetPoints = [225, 190, 165, 140, 125, 110, 90, 75, 60, 45, 35, 25];
    
    	var points;
    
    	if (isFinale) {
        	points = isNet ? finaleNetPoints : finaleBrutPoints;
        	// Finale 1 jour = mÃƒÂªme distribution que 2 jours (400 points total)
        	// Pas besoin de doubler, les points sont dÃƒÂ©jÃƒÂ  corrects pour 400 total
    	} else {
        	points = isNet ? exhibitionNetPoints : exhibitionBrutPoints;
    	}
    
    	// Position est 1-indexÃƒÂ©e, tableau est 0-indexÃƒÂ©
    	return points[Math.min(position - 1, points.length - 1)] || 0;
	}

	// Exclure Ãƒâ€°ric Gosselin (ID 12) du pointage GPR
	function isEricGosselin(playerId) {
    	return playerId === 13;
	}

	// Variables globales pour le calendrier
	var calendarEvents = [];
	var teeTimeCounter = 1;
	var currentDate = new Date();
	var currentMonth = currentDate.getMonth();
	var currentYear = currentDate.getFullYear();

	// Variables globales pour les notifications EmailJS
	var emailjsConfig = {
    	serviceId: 'service_ilpvcl4',
    	templateIdUpcoming: 'template_upcoming_game',
    	templateIdResults: 'template_game_results',
    	publicKey: 'Lcpl3KzU2V4_mqe9A'
	};

	var notificationLog = [];

	// Noms des mois et jours en franÃƒÂ§ais
	var monthNames = [
    	'Janvier', 'FÃƒÂ©vrier', 'Mars', 'Avril', 'Mai', 'Juin',
    	'Juillet', 'AoÃƒÂ»t', 'Septembre', 'Octobre', 'Novembre', 'DÃƒÂ©cembre'
	];
	var dayNames = ['Dim', 'Lun', 'Mar', 'Mer', 'Jeu', 'Ven', 'Sam'];

	// Fonction principale pour afficher le calendrier
	function showCalendar() {
    	console.log('Ã°Å¸Å¡â‚¬ showCalendar() appelÃƒÂ©e');
    
    	// Masquer toutes les autres sections SAUF le calendrier
    	hideAllSections();
    
    	// Afficher SEULEMENT le calendrier
    	var calendarSection = document.getElementById('calendar');
    	if (calendarSection) {
        	calendarSection.style.display = 'block';
        	calendarSection.style.visibility = 'visible';
        	calendarSection.style.opacity = '1';
        	calendarSection.classList.add('active');
    	}
    
    	setActiveButton('showCalendar');
    
    	// Initialiser les variables
    	if (typeof currentMonth === 'undefined' || currentMonth === null) {
        	currentMonth = new Date().getMonth();
        	currentYear = new Date().getFullYear();
    	}
		
    	if (typeof calendarEvents === 'undefined') {
        	calendarEvents = [];
    	}
    
    	updateMonthTitle();
    	setTimeout(function() {
    	    generateCalendar();
    	}, 100);
	}

	// Charger les donnÃƒÂ©es du calendrier depuis Firebase
	function loadCalendarData() {
    	// Cette fonction sera utilisÃƒÂ©e plus tard pour charger depuis Firebase
    	return database.ref('calendarEvents').once('value').then(function(snapshot) {
        	if (snapshot.exists()) {
            	calendarEvents = snapshot.val() || [];
        	}
    	}).catch(function(error) {
        	console.log('Pas de donnÃƒÂ©es calendrier dans Firebase, utilisation tableau vide');
        	calendarEvents = [];
    	});
	}

	// Sauvegarder les ÃƒÂ©vÃƒÂ©nements dans Firebase
	function saveCalendarToFirebase() {
    	return database.ref('calendarEvents').set(calendarEvents);
	}

	// Afficher la vue mensuelle
	function showMonthView() {
    	// S'assurer que les ÃƒÂ©lÃƒÂ©ments existent
    	var calendarView = document.getElementById('calendarView');
    	var listView = document.getElementById('listView');
    
    	if (calendarView) {
        	calendarView.style.display = 'block';
    	}
    	if (listView) {
        	listView.style.display = 'none';
    	}
    
    	updateMonthTitle();
    	generateCalendar();
	}

	// Mettre ÃƒÂ  jour le titre du mois
	function updateMonthTitle() {
    	var monthTitleElement = document.getElementById('monthTitle');
    	if (monthTitleElement && monthNames && currentMonth !== undefined && currentYear !== undefined) {
        	monthTitleElement.textContent = monthNames[currentMonth] + ' ' + currentYear;
        	console.log('Titre mis ÃƒÂ  jour:', monthNames[currentMonth] + ' ' + currentYear);
    	}
	}

	// 3. FONCTION generateCalendar ULTRA-SÃƒâ€°CURISÃƒâ€°E
	function generateCalendar() {
    	console.log('=== generateCalendar() CORRIGÃƒâ€°E ===');
    
    	var calendarViewElement = document.getElementById('calendarView');
    	if (!calendarViewElement) {
        	console.error('Ã¢ÂÅ’ Element calendarView non trouvÃƒÂ©!');
        	return;
    	}
    
    	// Nettoyer complÃƒÂ¨tement l'ÃƒÂ©lÃƒÂ©ment
    	calendarViewElement.innerHTML = '';
    
    	// Variables sÃƒÂ©curisÃƒÂ©es
    	var today = new Date();
    	var workingMonth = (typeof currentMonth !== 'undefined') ? currentMonth : today.getMonth();
    	var workingYear = (typeof currentYear !== 'undefined') ? currentYear : today.getFullYear();
    
    	console.log('Ã°Å¸â€œâ€¦ GÃƒÂ©nÃƒÂ©ration calendrier pour:', monthNames[workingMonth], workingYear);
    
    	// CrÃƒÂ©er le conteneur principal
    	var container = document.createElement('div');
    	container.className = 'calendar-container';
    
    	// CrÃƒÂ©er la grille du calendrier
    	var grid = document.createElement('div');
    	grid.className = 'calendar-grid';
    
    	// En-tÃƒÂªtes des jours
    	var safeDayNames = ['Dim', 'Lun', 'Mar', 'Mer', 'Jeu', 'Ven', 'Sam'];
    	for (var i = 0; i < safeDayNames.length; i++) {
        	var header = document.createElement('div');
        	header.className = 'calendar-header';
        	header.textContent = safeDayNames[i];
        	grid.appendChild(header);
    	}
    
    	// Calcul des dates
    	var firstDay = new Date(workingYear, workingMonth, 1);
    	var startDate = new Date(firstDay);
    	startDate.setDate(startDate.getDate() - firstDay.getDay());
    
    	// GÃƒÂ©nÃƒÂ©rer 42 jours (6 semaines)
    	for (var i = 0; i < 42; i++) {
        	var cellDate = new Date(startDate);
        	cellDate.setDate(startDate.getDate() + i);
        
        	var isCurrentMonth = cellDate.getMonth() === workingMonth;
        	var isToday = (cellDate.getDate() === today.getDate() && 
            	          cellDate.getMonth() === today.getMonth() && 
                	      cellDate.getFullYear() === today.getFullYear());
        
        	// CrÃƒÂ©er la cellule du jour
        	var dayCell = document.createElement('div');
        	dayCell.className = 'calendar-day';
        	if (!isCurrentMonth) dayCell.className += ' other-month';
        	if (isToday) dayCell.className += ' today';
        
        	// NumÃƒÂ©ro du jour
        	var dayNumber = document.createElement('div');
        	dayNumber.className = 'calendar-day-number';
        	dayNumber.textContent = cellDate.getDate();
        	dayCell.appendChild(dayNumber);
        
        	// Ãƒâ€°vÃƒÂ©nements du jour (si applicable)
        	var dateStr = formatDateForInput(cellDate);
        	var dayEvents = getEventsForDate(cellDate);
        
        	for (var j = 0; j < Math.min(dayEvents.length, 3); j++) {
            	var eventDiv = document.createElement('div');
            	eventDiv.className = 'calendar-event';
            	eventDiv.textContent = getEventIcon(dayEvents[j].type) + ' ' + dayEvents[j].course.substring(0, 15);
            	eventDiv.onclick = (function(eventId) {
                	return function(e) {
                    	e.stopPropagation();
                    	showEventDetail(eventId);
                	};
            	})(dayEvents[j].id);
            	dayCell.appendChild(eventDiv);
        	}
        
        	// Click handler pour la cellule
        	dayCell.onclick = (function(date) {
            	return function() {
                	selectDate(date);
            	};
        	})(dateStr);
        
        	grid.appendChild(dayCell);
    	}
    
    	container.appendChild(grid);
    	calendarViewElement.appendChild(container);
    
    	console.log('Ã¢Å“â€¦ Calendrier gÃƒÂ©nÃƒÂ©rÃƒÂ© avec succÃƒÂ¨s');
	}

	// Changer de mois
	function changeMonth(direction) {
    	console.log('changeMonth:', direction);
    
    	currentMonth += direction;
    
    	if (currentMonth > 11) {
        	currentMonth = 0;
        	currentYear++;
    	} else if (currentMonth < 0) {
        	currentMonth = 11;
        	currentYear--;
    	}
    
    	console.log('Nouveau mois:', currentMonth, currentYear);
    
    	updateMonthTitle();
    	generateCalendar();
	}

	// Fonctions utilitaires
	function isDateToday(date) {
    	var today = new Date();
    	return date.getDate() === today.getDate() && 
        	   date.getMonth() === today.getMonth() && 
        	   date.getFullYear() === today.getFullYear();
	}

	function getEventsForDate(date) {
    	var dateStr = formatDateForInput(date);
    	if (!calendarEvents || !Array.isArray(calendarEvents)) {
        	return [];
    	}
    	return calendarEvents.filter(function(event) {
        	return event && event.date === dateStr;
    	});
	}

	// 1. FONCTION formatDateForInput CORRIGÃƒâ€°E (sans padStart)
	function formatDateForInput(date) {
    	var year = date.getFullYear();
    	var month = date.getMonth() + 1;
    	var day = date.getDate();
    
    	// Fonction de padding manuelle (compatible tous navigateurs)
    	function pad(num) {
        	return num < 10 ? '0' + num : num.toString();
    	}
    
    	return year + '-' + pad(month) + '-' + pad(day);
	}

	function selectDate(dateStr) {
    	var eventDateInput = document.getElementById('eventDate');
    	if (eventDateInput) {
        	eventDateInput.value = dateStr;
    	}
    	showAddEvent();
	}

	// Afficher le formulaire d'ajout
	function showAddEvent() {
    	var form = document.getElementById('addEventForm');
    	if (!form) {
        	console.error('Formulaire addEventForm non trouvÃƒÂ©!');
        	return;
    	}
    
    	form.style.display = form.style.display === 'none' ? 'block' : 'none';
    
    	if (form.style.display === 'block') {
        	// Initialiser le formulaire
        	var eventDate = document.getElementById('eventDate');
        	var eventComments = document.getElementById('eventComments');
        
        	if (eventDate && !eventDate.value) {
            	eventDate.value = formatDateForInput(new Date());
        	}
        	if (eventComments) {
            	eventComments.value = '';
        	}
        
        	// Charger les terrains et organisateurs
        	loadEventCourseOptions();
        	loadOrganizerOptions();
        
        	// RÃƒÂ©initialiser les heures de dÃƒÂ©part
        	teeTimeCounter = 1;
        	var teeTimesList = document.getElementById('teeTimesList');
        	if (teeTimesList) {
            	teeTimesList.innerHTML = '';
            	addTeeTime(); // Ajouter une premiÃƒÂ¨re heure par dÃƒÂ©faut
        	}
    	}
	}

	// Charger les options de terrains
	function loadEventCourseOptions() {
    	var select = document.getElementById('eventCourse');
    	if (!select) return;
    
    	select.innerHTML = '<option value="">-- SÃƒÂ©lectionner un terrain --</option>';
    
    	var courseNames = Object.keys(coursesDatabase).sort();
    	for (var i = 0; i < courseNames.length; i++) {
        	var option = document.createElement('option');
        	option.value = courseNames[i];
        	option.textContent = courseNames[i];
        	select.appendChild(option);
    	}
	}

	// Charger les options d'organisateurs
	function loadOrganizerOptions() {
    	var select = document.getElementById('eventOrganizer');
    	if (!select) return;
    
    	select.innerHTML = '<option value="">-- SÃƒÂ©lectionner --</option>';
    
    	for (var i = 0; i < players.length; i++) {
        	var player = players[i];
        	if (player.active) {
            	var option = document.createElement('option');
            	option.value = player.id;
            	option.textContent = player.name || (player.firstName + ' ' + player.lastName);
            	select.appendChild(option);
        	}
    	}
	}

	// Ajouter une heure de dÃƒÂ©part
	function addTeeTime() {
    	var container = document.getElementById('teeTimesList');
    	if (!container) return;
    
    	var teeTimeId = 'teeTime_' + teeTimeCounter;
    
    	var html = '<div class="tee-time-item" id="' + teeTimeId + '">' +
        	       '<div style="flex: 1;">' +
            	   '<label style="font-weight: bold;">DÃƒÂ©part #' + teeTimeCounter + ':</label>' +
            	   '<input type="time" id="time_' + teeTimeId + '" style="margin: 0 10px;">' +
            	   '<button class="btn-danger" onclick="removeTeeTime(\'' + teeTimeId + '\')">Ã¢ÂÅ’</button>' +
            	   '</div>' +
            	   '</div>' +
            	   '<div class="foursome-slot" id="foursome_' + teeTimeId + '">' +
            	   '<select class="player-slot" id="p1_' + teeTimeId + '">' +
            	   '<option value="">Joueur 1</option>' +
            	   '</select>' +
            	   '<select class="player-slot" id="p2_' + teeTimeId + '">' +
            	   '<option value="">Joueur 2</option>' +
            	   '</select>' +
            	   '<select class="player-slot" id="p3_' + teeTimeId + '">' +
            	   '<option value="">Joueur 3</option>' +
            	   '</select>' +
            	   '<select class="player-slot" id="p4_' + teeTimeId + '">' +
            	   '<option value="">Joueur 4</option>' +
            	   '</select>' +
            	   '</div>';
    
    	// CrÃƒÂ©er un div temporaire
    	var tempDiv = document.createElement('div');
    	tempDiv.innerHTML = html;
    	container.appendChild(tempDiv);
    
    	// Remplir les selects avec les joueurs
    	for (var slot = 1; slot <= 4; slot++) {
        	var select = document.getElementById('p' + slot + '_' + teeTimeId);
        	if (select) {
            	for (var i = 0; i < players.length; i++) {
                	var player = players[i];
                	if (player.active) {
                    	var option = document.createElement('option');
                    	option.value = player.id;
                    	option.textContent = player.name || (player.firstName + ' ' + player.lastName);
                    	select.appendChild(option);
                	}
            	}
        	}
    	}
    
    	teeTimeCounter++;
	}

	// Supprimer une heure de dÃƒÂ©part
	function removeTeeTime(teeTimeId) {
    	var element = document.getElementById(teeTimeId);
    	if (element && element.parentElement) {
        	element.parentElement.remove();
    	}
	}

	// Ã°Å¸â€Â§ FONCTION saveEvent() - Version originale avec corrections minimales
	async function saveEvent() {
    	await ensurePlayersDataLoaded(); // Ã¢â€ Â SEULE LIGNE AJOUTÃƒâ€°E
    
    	var date = document.getElementById('eventDate').value;
    	var course = document.getElementById('eventCourse').value;
    	var type = document.getElementById('eventType').value;
    	var organizerId = document.getElementById('eventOrganizer').value;
    	var comments = document.getElementById('eventComments').value;

    	if (!date || !course) {
        	alert('Veuillez remplir au moins la date et le terrain.');
        	return;
    	}

    	console.log('=== DEBUG SAVE EVENT ===');
    	console.log('Date:', date);
    	console.log('Course:', course);
    	console.log('Type:', type);

    	// Collecter les heures de dÃƒÂ©part
    	var teeTimes = [];
    	var teeTimeElements = document.querySelectorAll('[id^="teeTime_"]');
    
    	console.log('TeeTime elements trouvÃƒÂ©s:', teeTimeElements.length);

    	for (var i = 0; i < teeTimeElements.length; i++) {
        	var teeTimeId = teeTimeElements[i].id;
        	var timeInput = document.getElementById('time_' + teeTimeId);
        	var time = timeInput ? timeInput.value : '';

        	console.log('Processing teeTime:', teeTimeId, 'Time:', time);

        	if (time) {
            	var foursome = [];
            	for (var slot = 1; slot <= 4; slot++) {
                	var playerSelect = document.getElementById('p' + slot + '_' + teeTimeId);
                	var playerId = playerSelect ? playerSelect.value : '';
                	if (playerId) {
                	    foursome.push(parseInt(playerId));
                	}
            	}

            	console.log('Foursome pour', time, ':', foursome);

            	teeTimes.push({
                	time: time,
                	players: foursome
            	});
        	}
    	}

    	console.log('TeeTimes collectÃƒÂ©s:', teeTimes);

    	// CrÃƒÂ©er l'ÃƒÂ©vÃƒÂ©nement
    	var newEvent = {
        	id: Date.now(), // ID unique basÃƒÂ© sur timestamp
        	date: date,
        	course: course,
        	type: type,
        	organizerId: organizerId ? parseInt(organizerId) : null,
        	organizerName: organizerId ? getPlayerName(parseInt(organizerId)) : 'Non dÃƒÂ©fini',
        	teeTimes: teeTimes,
        	comments: comments,
        	createdAt: new Date().toISOString(),
        	createdBy: 'current_user'
    	};

    	console.log('Nouvel ÃƒÂ©vÃƒÂ©nement crÃƒÂ©ÃƒÂ©:', newEvent);

    	calendarEvents.push(newEvent);

    	// Sauvegarder dans Firebase
    	saveCalendarToFirebase().then(function() {
        	console.log('Ãƒâ€°vÃƒÂ©nement sauvegardÃƒÂ© dans Firebase');
        
        	// Ã°Å¸â€Â¥ NOTIFICATION: Partie planifiÃƒÂ©e
        	console.log('=== DÃƒâ€°BUT NOTIFICATIONS ===');
        
        	if (newEvent.teeTimes && newEvent.teeTimes.length > 0) {
            	console.log('TeeTimes disponibles:', newEvent.teeTimes.length);
            
            	var participants = [];
            
            	// Collecter tous les participants
            	for (var i = 0; i < newEvent.teeTimes.length; i++) {
                	var teeTime = newEvent.teeTimes[i];
                	console.log('TeeTime', i, ':', teeTime);
                
                	if (teeTime.players && teeTime.players.length > 0) {
                    	for (var j = 0; j < teeTime.players.length; j++) {
                        	var playerId = teeTime.players[j];
                        	if (participants.indexOf(playerId) === -1) {
                            	participants.push(playerId);
                        	}
                    	}
                	}
            	}
            
            	console.log('Participants uniques:', participants);

            	var emailsSent = 0;
            	var emailsToSend = 0;
            
            	for (var p = 0; p < participants.length; p++) {
                	var playerId = participants[p];
                	// Ã°Å¸â€Â§ SEULE LIGNE MODIFIÃƒâ€°E - recherche plus robuste
                	var player = players.find(function(pl) { return pl.id === playerId || pl.id === parseInt(playerId); });
                
                	console.log('Processing player ID:', playerId, 'Player found:', player);
                
                	if (player) {
                	    console.log('Player email:', player.email);
                    
                    	if (player.email && player.email.trim() !== '') {
                        	emailsToSend++;
                        
                        	// Trouver le teeTime de ce joueur
                        	var playerTeeTime = null;
                        	for (var i = 0; i < newEvent.teeTimes.length; i++) {
                        	    var teeTime = newEvent.teeTimes[i];
                            	if (teeTime.players && teeTime.players.indexOf(playerId) !== -1) {
                                	playerTeeTime = teeTime;
                                	break;
                            	}
                        	}

                        	console.log('TeeTime pour joueur', player.name, ':', playerTeeTime);

                        	var notificationData = {
                            	event: newEvent,
                            	teeTime: playerTeeTime
                        	};

                        	// VÃƒÂ©rifier que EmailJS est disponible
                        	if (typeof emailjs !== 'undefined' && typeof sendEmailNotification === 'function') {
                            	console.log('Envoi notification ÃƒÂ :', player.name, player.email);
                            
                            	try {
                                	sendEmailNotification('upcoming', [player], notificationData);
                                	emailsSent++;
                            	} catch (error) {
                                	console.error('Erreur envoi notification:', error);
                            	}
                        	} else {
                            	console.error('EmailJS ou sendEmailNotification non disponible');
                        	}
                    	} else {
                        	console.log('Pas d\'email pour', player.name || 'Player #' + playerId);
                    	}
                	} else {
                    	console.log('Joueur non trouvÃƒÂ© pour ID:', playerId);
                	}
            	}

            	console.log('Emails ÃƒÂ  envoyer:', emailsToSend, 'Emails envoyÃƒÂ©s:', emailsSent);

            	if (emailsToSend > 0) {
                	alert('Ã¢Å“â€¦ Partie planifiÃƒÂ©e avec succÃƒÂ¨s !\nÃ°Å¸â€œÂ§ ' + emailsSent + ' notification(s) envoyÃƒÂ©e(s) sur ' + emailsToSend + ' participant(s) avec email.');
            	} else {
                	alert('Ã¢Å“â€¦ Partie planifiÃƒÂ©e avec succÃƒÂ¨s !\nAucun email configurÃƒÂ© pour les participants.');
            	}
        	} else {
        	    console.log('Aucun teeTime dÃƒÂ©fini');
            	alert('Ã¢Å“â€¦ Partie planifiÃƒÂ©e avec succÃƒÂ¨s !');
        	}

        	console.log('=== FIN NOTIFICATIONS ===');

        	showAddEvent(); // Fermer le formulaire
        	refreshCalendarView();
        
    	}).catch(function(error) {
        	console.error('Erreur sauvegarde Firebase:', error);
        	alert('Ã¢ÂÅ’ Erreur: ' + error.message);
    	});
	}

	// Ã°Å¸â€Â§ AJOUTEZ D'ABORD CETTE FONCTION
	async function ensurePlayersDataLoaded() {
    	console.log('Ã°Å¸â€â€ VÃƒÂ©rification des donnÃƒÂ©es joueurs...');
    
    	if (!players || players.length === 0) {
        	console.log('Ã¢Å¡Â Ã¯Â¸Â DonnÃƒÂ©es joueurs manquantes, rechargement depuis Firebase...');
        	await loadDataFromFirebase();
    	}
    
    	console.log('Ã¢Å“â€¦ DonnÃƒÂ©es joueurs disponibles:', players.length, 'joueurs');
    	return players;
	}

	// Vue liste
	function showListView() {
    	console.log('Ã°Å¸â€œâ€¹ Affichage vue liste...');
    
    	var calendarView = document.getElementById('calendarView');
    	var listView = document.getElementById('listView');
    
    	if (calendarView) calendarView.style.display = 'none';
    	if (listView) listView.style.display = 'block';
    
    	console.log('Ãƒâ€°vÃƒÂ©nements disponibles:', calendarEvents.length);
    
		// SÃƒÂ©parer les ÃƒÂ©vÃƒÂ©nements futurs et passÃƒÂ©s
		var today = new Date();
 		today.setHours(0, 0, 0, 0); // DÃƒÂ©but de journÃƒÂ©e
    
    	var futureEvents = calendarEvents.filter(function(e) {
    		var eventDate = new Date(e.date);
    		return eventDate >= today;
    	}).sort(function(a, b) {
        	return new Date(a.date) - new Date(b.date);
    	});
    
    	var pastEvents = calendarEvents.filter(function(e) {
        	var eventDate = new Date(e.date);
        	return eventDate < today;
    	}).sort(function(a, b) {
        	return new Date(b.date) - new Date(a.date); // Plus rÃƒÂ©cents en premier
    	});
    
    	var html = '';
    
    	// Section ÃƒÂ©vÃƒÂ©nements futurs
    	html += '<h3>Ã°Å¸â€œâ€¦ Prochaines Parties (' + futureEvents.length + ')</h3>';
    
    	if (futureEvents.length === 0) {
        	html += '<div style="text-align: center; padding: 30px; background: #f8f9fa; border-radius: 8px; margin: 15px 0;">' +
            		'<p style="color: #666; margin: 0;">Aucune partie planifiÃƒÂ©e pour l\'avenir</p>' +
                	'<button class="btn" onclick="showAddEvent()" style="margin-top: 10px;">Ã¢Å¾â€¢ Planifier une partie</button>' +
                	'</div>';
    	} else {
        	html += '<div style="max-height: 400px; overflow-y: auto; margin-bottom: 30px;">';
        
        	for (var i = 0; i < futureEvents.length; i++) {
            	html += generateEventCard(futureEvents[i], false);
        	}
        
        	html += '</div>';
    	}
    
    	// Section ÃƒÂ©vÃƒÂ©nements passÃƒÂ©s (si il y en a)
    	if (pastEvents.length > 0) {
        	html += '<h3>Ã°Å¸â€œâ€¹ Parties PassÃƒÂ©es (' + pastEvents.length + ')</h3>';
        	html += '<div style="max-height: 300px; overflow-y: auto;">';
        
        	for (var i = 0; i < Math.min(pastEvents.length, 10); i++) { // Limiter ÃƒÂ  10
            	html += generateEventCard(pastEvents[i], true);
        	}
        
        	if (pastEvents.length > 10) {
            	html += '<div style="text-align: center; padding: 15px; color: #666;">' +
                		'... et ' + (pastEvents.length - 10) + ' autres parties passÃƒÂ©es' +
                    	'</div>';
        	}
        
        	html += '</div>';
    	}
    
    	if (listView) {
        	listView.innerHTML = html;
    	}
    
    	console.log('Ã¢Å“â€¦ Vue liste gÃƒÂ©nÃƒÂ©rÃƒÂ©e');
	}

	// Fonction helper pour gÃƒÂ©nÃƒÂ©rer une carte d'ÃƒÂ©vÃƒÂ©nement
	function generateEventCard(event, isPast) {
    	var eventDate = new Date(event.date);
    	var dateStr = eventDate.toLocaleDateString('fr-FR', {
        	weekday: 'long',
        	year: 'numeric',
        	month: 'long',
        	day: 'numeric'
    	});
    
    	var cardStyle = isPast ? 
        	'margin: 10px 0; cursor: pointer; opacity: 0.8; border-left: 4px solid #ccc;' :
        	'margin: 10px 0; cursor: pointer; border-left: 4px solid #4a7c59;';
    
    	var html = '<div class="card" style="' + cardStyle + '" onclick="showEventDetail(' + event.id + ')">' +
        	       '<div style="display: flex; justify-content: space-between; align-items: center;">' +
            	   '<div>' +
            	   '<h4 style="margin: 0;">' + getEventIcon(event.type) + ' ' + dateStr;
    
    	if (isPast) {
        	html += ' <span style="background: #6c757d; color: white; padding: 2px 6px; border-radius: 10px; font-size: 10px;">PASSÃƒâ€°E</span>';
    	}
    
    	html += '</h4>' +
        	    '<p style="margin: 5px 0;"><strong>' + event.course + '</strong></p>' +
        	    '<small>OrganisÃƒÂ© par: ' + (event.organizerName || 'Non dÃƒÂ©fini') + '</small>' +
            	'</div>' +
            	'<div style="text-align: right;">' +
            	'<strong>' + (event.teeTimes ? event.teeTimes.length : 0) + ' dÃƒÂ©part(s)</strong><br>';
    
    	if (event.teeTimes && event.teeTimes.length > 0) {
        	html += '<small>Premier: ' + event.teeTimes[0].time + '</small>';
    	} else {
    	    html += '<small>Heures ÃƒÂ  dÃƒÂ©finir</small>';
    	}
    
    	html += '</div></div>';
    
    	if (event.comments) {
        	html += '<div style="margin-top: 10px; padding: 10px; background: #f8f9fa; border-radius: 5px;">' +
            	    '<small><strong>Notes:</strong> ' + event.comments + '</small>' +
                	'</div>';
    	}
    
    	html += '</div>';
    
    	return html;
	}

	// Afficher les dÃƒÂ©tails d'un ÃƒÂ©vÃƒÂ©nement
	function showEventDetail(eventId) {
    	console.log('Affichage dÃƒÂ©tails ÃƒÂ©vÃƒÂ©nement ID:', eventId);
    
    	var event = calendarEvents.find(function(e) { return e.id == eventId; });
    	if (!event) {
        	alert('Ãƒâ€°vÃƒÂ©nement non trouvÃƒÂ©!');
        	return;
    	}
		
    	console.log('Ãƒâ€°vÃƒÂ©nement trouvÃƒÂ©:', event);
    
    	var eventDate = new Date(event.date);
    	var dateStr = eventDate.toLocaleDateString('fr-FR', {
        	weekday: 'long',
        	year: 'numeric',
        	month: 'long',
        	day: 'numeric'
    	});
    
    	var html = '<div class="event-detail-overlay" onclick="closeEventDetail()"></div>' +
        	       '<div class="event-detail-popup">' +
            	   '<h3>' + getEventIcon(event.type) + ' ' + dateStr + '</h3>' +
            	   '<p><strong>Terrain:</strong> ' + event.course + '</p>' +
            	   '<p><strong>Type:</strong> ' + getEventTypeName(event.type) + '</p>' +
            	   '<p><strong>Organisateur:</strong> ' + (event.organizerName || 'Non dÃƒÂ©fini') + '</p>';
    
    	if (event.comments) {
        	html += '<div style="background: #f8f9fa; padding: 10px; border-radius: 5px; margin: 15px 0;">' +
            	    '<strong>Notes:</strong><br>' + event.comments +
                	'</div>';
    	}
    
    	html += '<h4>Ã¢ÂÂ° Heures de DÃƒÂ©part</h4>';
    
    	// VÃƒÂ©rifier si teeTimes existe et n'est pas vide
    	if (event.teeTimes && event.teeTimes.length > 0) {
        	for (var i = 0; i < event.teeTimes.length; i++) {
            	var teeTime = event.teeTimes[i];
            	html += '<div style="margin: 10px 0; padding: 10px; background: #e8f5e8; border-radius: 5px;">' +
                	    '<strong>Ã°Å¸â€¢â€™ ' + teeTime.time + '</strong>';
            
            	if (teeTime.players && teeTime.players.length > 0) {
                	html += '<div style="display: grid; grid-template-columns: repeat(2, 1fr); gap: 10px; margin-top: 10px;">';
                
                	for (var j = 0; j < teeTime.players.length; j++) {
                    	var player = players.find(function(p) { return p.id === teeTime.players[j]; });
                    	var playerName = player ? (player.name || (player.firstName + ' ' + player.lastName)) : 'Joueur #' + teeTime.players[j];
                    	html += '<div style="background: white; padding: 5px 10px; border-radius: 3px;">' +
                        	    (j + 1) + '. ' + playerName +
                        	    '</div>';
                	}
                
                	html += '</div>';
            	} else {
            	    html += '<div style="color: #666; font-style: italic; margin-top: 5px;">Aucun joueur assignÃƒÂ©</div>';
            	}
            
            	html += '</div>';
        	}
    	} else {
    	    html += '<div style="color: #666; font-style: italic; padding: 20px; text-align: center; background: #f8f9fa; border-radius: 5px;">' +
        	        'Aucune heure de dÃƒÂ©part dÃƒÂ©finie' +
            	    '</div>';
    	}
    
    	html += '<div style="text-align: center; margin-top: 20px;">' +
        	    '<button class="btn" onclick="editEvent(' + eventId + ')">Ã¢Å“ÂÃ¯Â¸Â Modifier</button>' +
        	    '<button class="btn-danger" onclick="deleteEvent(' + eventId + ')">Ã°Å¸â€”â€˜Ã¯Â¸Â Supprimer</button>' +
        	    '<button class="btn-secondary" onclick="closeEventDetail()">Ã¢ÂÅ’ Fermer</button>' +
        	    '</div>' +
            	'</div>';
    
    	// Ajouter ÃƒÂ  la page
    	var detailDiv = document.createElement('div');
    	detailDiv.id = 'eventDetailPopup';
    	detailDiv.innerHTML = html;
    	document.body.appendChild(detailDiv);
	}

	// Fonction helper pour obtenir le nom du type d'ÃƒÂ©vÃƒÂ©nement
	function getEventTypeName(type) {
    	switch(type) {
        	case 'gpr': return 'Ã°Å¸Å½Â¯ Coupe GPR';
        	case 'diablo': return 'Ã°Å¸Ââ€  Coupe Diablo';
        	case 'felton': return 'Ã°Å¸Ââ€  Coupe FelTon';
        	case 'doubled': return 'Ã°Å¸Å½Â¯ Double D\'s Cup';
        	case 'amicale': return 'Ã¢â€ºÂ³ Partie Amicale';
        	default: return 'Ã¢â€ºÂ³ Autre';
    	}
	}

	// Fermer les dÃƒÂ©tails
	function closeEventDetail() {
    	var popup = document.getElementById('eventDetailPopup');
    	if (popup) {
    	    popup.remove();
    	}
	}

	// Fonctions utilitaires
	function getEventIcon(type) {
    	switch(type) {
        	case 'gpr': return 'Ã°Å¸Å½Â¯';
        	case 'diablo': return 'Ã°Å¸Ââ€ ';
        	case 'felton': return 'Ã°Å¸Ââ€ ';
        	case 'doubled': return 'Ã°Å¸Å½Â¯';
        	default: return 'Ã¢â€ºÂ³';
    	}
	}

	function editEvent(eventId) {
    	var event = calendarEvents.find(function(e) { return e.id == eventId; });
    	if (!event) {
        	alert('Ãƒâ€°vÃƒÂ©nement non trouvÃƒÂ©!');
        	return;
    	}
    
    	// Fermer le popup de dÃƒÂ©tails
    	closeEventDetail();
    
    	// PrÃƒÂ©-remplir le formulaire avec les donnÃƒÂ©es existantes
    	showAddEvent();
    
    	// Remplir les champs
    	document.getElementById('eventDate').value = event.date;
    	document.getElementById('eventCourse').value = event.course || '';
    	document.getElementById('eventType').value = event.type || 'amicale';
    	document.getElementById('eventOrganizer').value = event.organizerId || '';
    	document.getElementById('eventComments').value = event.comments || '';
    
    	// Marquer qu'on ÃƒÂ©dite (pas qu'on crÃƒÂ©e)
    	window.editingEventId = eventId;
    
    	// Changer le titre et le bouton
    	var formTitle = document.querySelector('#addEventForm h3');
    	if (formTitle) {
    	    formTitle.textContent = 'Ã¢Å“ÂÃ¯Â¸Â Modifier la Partie';
    	}
    
    	// Changer le bouton de sauvegarde
    	var saveButton = document.querySelector('#addEventForm button[onclick="saveEvent()"]');
    	if (saveButton) {
    	    saveButton.textContent = 'Ã°Å¸â€™Â¾ Sauvegarder Modifications';
        	saveButton.onclick = function() { updateEvent(); };
    	}
    
    	// RecrÃƒÂ©er les heures de dÃƒÂ©part
    	var teeTimesList = document.getElementById('teeTimesList');
    	if (teeTimesList) {
        	teeTimesList.innerHTML = '';
        	teeTimeCounter = 1;
        
        	if (event.teeTimes && event.teeTimes.length > 0) {
            	for (var i = 0; i < event.teeTimes.length; i++) {
                	addTeeTime();
                	var teeTime = event.teeTimes[i];
                	var timeInput = document.getElementById('time_teeTime_' + teeTimeCounter);
                	if (timeInput) {
                	    timeInput.value = teeTime.time;
                	}
                
                	// Remplir les joueurs
                	if (teeTime.players) {
                    	for (var j = 0; j < Math.min(teeTime.players.length, 4); j++) {
                        	var playerSelect = document.getElementById('p' + (j + 1) + '_teeTime_' + teeTimeCounter);
                        	if (playerSelect) {
                            	playerSelect.value = teeTime.players[j];
                        	}
                    	}
                	}
                	teeTimeCounter++;
            	}
        	} else {
            	addTeeTime(); // Au moins une heure par dÃƒÂ©faut
        	}
    	}
	}

	function updateEvent() {
    	var eventId = window.editingEventId;
    	if (!eventId) {
        	alert('Erreur: ID d\'ÃƒÂ©vÃƒÂ©nement manquant');
        	return;
    	}
    
    	var eventIndex = calendarEvents.findIndex(function(e) { return e.id == eventId; });
    	if (eventIndex === -1) {
    	    alert('Ãƒâ€°vÃƒÂ©nement non trouvÃƒÂ©!');
        	return;
    	}
    
    	// RÃƒÂ©cupÃƒÂ©rer les nouvelles donnÃƒÂ©es (mÃƒÂªme logique que saveEvent)
    	var date = document.getElementById('eventDate').value;
    	var course = document.getElementById('eventCourse').value;
    	var type = document.getElementById('eventType').value;
    	var organizerId = document.getElementById('eventOrganizer').value;
    	var comments = document.getElementById('eventComments').value;
    
    	if (!date || !course) {
    	    alert('Veuillez remplir au moins la date et le terrain.');
        	return;
    	}
    
    	// Collecter les heures de dÃƒÂ©part
    	var teeTimes = [];
    	var teeTimeElements = document.querySelectorAll('[id^="teeTime_"]');
    
    	for (var i = 0; i < teeTimeElements.length; i++) {
    	    var teeTimeId = teeTimeElements[i].id;
        	var timeInput = document.getElementById('time_' + teeTimeId);
        	var time = timeInput ? timeInput.value : '';
        
        	if (time) {
            	var foursome = [];
            	for (var slot = 1; slot <= 4; slot++) {
                	var playerSelect = document.getElementById('p' + slot + '_' + teeTimeId);
                	var playerId = playerSelect ? playerSelect.value : '';
                	if (playerId) {
                	    foursome.push(parseInt(playerId));
                	}
            	}
            
            	teeTimes.push({
            	    time: time,
                	players: foursome
            	});
        	}
    	}
    
    	// Mettre ÃƒÂ  jour l'ÃƒÂ©vÃƒÂ©nement
    	calendarEvents[eventIndex] = {
    	    id: eventId, // Garder le mÃƒÂªme ID
        	date: date,
        	course: course,
        	type: type,
        	organizerId: organizerId ? parseInt(organizerId) : null,
        	organizerName: organizerId ? getPlayerName(parseInt(organizerId)) : 'Non dÃƒÂ©fini',
        	teeTimes: teeTimes,
        	comments: comments,
        	createdAt: calendarEvents[eventIndex].createdAt, // Garder la date de crÃƒÂ©ation
        	updatedAt: new Date().toISOString() // Ajouter date de modification
    	};
    
    	// Sauvegarder dans Firebase
    	saveCalendarToFirebase().then(function() {
    	    alert('Ã¢Å“â€¦ Ãƒâ€°vÃƒÂ©nement modifiÃƒÂ© avec succÃƒÂ¨s!');
        
    	    // Nettoyer
    	    delete window.editingEventId;
        	showAddEvent(); // Fermer le formulaire
        	refreshCalendarView();
        
    	}).catch(function(error) {
        	alert('Ã¢ÂÅ’ Erreur: ' + error.message);
    	});
	}

	function deleteEvent(eventId) {
    	if (!confirm('Voulez-vous vraiment supprimer cet ÃƒÂ©vÃƒÂ©nement ?')) {
        	return;
    	}
    
    	var eventIndex = calendarEvents.findIndex(function(e) { return e.id == eventId; });
    	if (eventIndex !== -1) {
        	calendarEvents.splice(eventIndex, 1);
        
        	saveCalendarToFirebase().then(function() {
            	alert('Ã¢Å“â€¦ Ãƒâ€°vÃƒÂ©nement supprimÃƒÂ©!');
            	closeEventDetail();
            	refreshCalendarView();
        	}).catch(function(error) {
        	    alert('Ã¢ÂÅ’ Erreur: ' + error.message);
        	});
    	}
	}

	function getPlayerName(playerId) {
    	var player = players.find(function(p) { return p.id === playerId; });
    	return player ? (player.name || (player.firstName + ' ' + player.lastName)) : 'Inconnu';
	}

	function cancelAddEvent() {
    	showAddEvent();
	}

	function refreshCalendarView() {
    	// RafraÃƒÂ®chir la vue actuelle
    	if (document.querySelector('.calendar-grid')) {
        	showMonthView();
    	} else {
        	showListView();
    	}
	}

	function debugCalendar() {
    	console.log('=== DEBUG CALENDRIER ===');
    	console.log('currentMonth:', window.currentMonth);
    	console.log('currentYear:', window.currentYear);
    	console.log('calendarEvents:', window.calendarEvents);
    	console.log('Section calendar:', document.getElementById('calendar'));
    	console.log('CalendarView:', document.getElementById('calendarView'));
    	console.log('MonthTitle:', document.getElementById('monthTitle'));
	}

	function testCalendar() {
    	console.log('=== TEST CALENDRIER ===');
    
    	// Forcer l'initialisation
    	window.currentMonth = new Date().getMonth();
    	window.currentYear = new Date().getFullYear();
    	window.calendarEvents = [];
    
    	// VÃƒÂ©rifier les ÃƒÂ©lÃƒÂ©ments
    	console.log('Section calendar:', document.getElementById('calendar'));
    	console.log('CalendarView:', document.getElementById('calendarView'));
    	console.log('MonthTitle:', document.getElementById('monthTitle'));
    
    	// Forcer l'affichage
    	var calendarSection = document.getElementById('calendar');
    	if (calendarSection) {
        	calendarSection.style.display = 'block';
        	calendarSection.style.visibility = 'visible';
        	calendarSection.style.opacity = '1';
    	}
    
    	// GÃƒÂ©nÃƒÂ©rer le calendrier
    	updateMonthTitle();
    	generateCalendar();
	}

	// Ajouter ÃƒÂ  hideAllSections
	function hideAllSections() {
    	var sections = ['overview', 'playerScores', 'courses', 'diablo', 'gpr', 'progress', 'details', 'handicapEvolution', 'playerManagement', 'addRound', 'calendar', 'notifications'];
    	for (var i = 0; i < sections.length; i++) {
        	var element = document.getElementById(sections[i]);
        	if (element) {
            	element.style.display = 'none';
				element.classList.remove('active');
        	}
    	}
	}
																
	console.log("4. La mÃƒÂ©thode rÃƒÂ©aliste donnera des variations plus visibles");

	// === FONCTIONS NOTIFICATIONS MINIMALISTES ===
	function showNotifications() {
    	hideAllSections();
    	document.getElementById('notifications').style.display = 'block';
    	setActiveButton('showNotifications');
    	updateNotificationStats();
	}

	function updateNotificationStats() {
    	if (!notificationLog) notificationLog = [];
    
    	var totalEmails = notificationLog.length;
    	var totalSuccessful = notificationLog.filter(entry => entry.status === 'success').length;
    	var totalErrors = notificationLog.filter(entry => entry.status === 'error').length;
    
    	var lastSent = 'Jamais';
    	if (notificationLog.length > 0) {
        	var latest = notificationLog[notificationLog.length - 1];
        	lastSent = new Date(latest.timestamp).toLocaleDateString('fr-FR');
    	}
    
    	if (document.getElementById('totalEmailsSent')) {
        	document.getElementById('totalEmailsSent').textContent = totalEmails;
        	document.getElementById('totalSuccessful').textContent = totalSuccessful;
        	document.getElementById('totalErrors').textContent = totalErrors;
        	document.getElementById('lastSent').textContent = lastSent;
    	}
	}

	function loadSavedEmailjsConfig() {
    	var saved = localStorage.getItem('emailjsConfig');
    	if (saved) {
        	try {
            	var config = JSON.parse(saved);
            	emailjsConfig.templateIdUpcoming = config.templateIdUpcoming || emailjsConfig.templateIdUpcoming;
            	emailjsConfig.templateIdResults = config.templateIdResults || emailjsConfig.templateIdResults;
            
            	if (document.getElementById('emailTemplateUpcoming')) {
                	document.getElementById('emailTemplateUpcoming').value = emailjsConfig.templateIdUpcoming;
                	document.getElementById('emailTemplateResults').value = emailjsConfig.templateIdResults;
            	}
        	} catch (e) {
            	console.log('Configuration EmailJS non trouvÃƒÂ©e');
        	}
    	}
	}

	// Ã°Å¸Â§Âª FONCTION DE TEST AMÃƒâ€°LIORÃƒâ€°E
	function testEmailjsService() {
    	console.log('Ã°Å¸â€Â Test EmailJS dÃƒÂ©marrÃƒÂ©...');
    
    	// VÃƒÂ©rifications prÃƒÂ©liminaires
    	if (typeof emailjs === 'undefined') {
        	alert('Ã¢ÂÅ’ EmailJS non chargÃƒÂ©. VÃƒÂ©rifiez que la librairie est incluse.');
        	return;
    	}
    
    	if (!emailjsConfig.serviceId || emailjsConfig.serviceId === 'YOUR_SERVICE_ID') {
        	alert('Ã¢ÂÅ’ Service ID manquant. Configurez emailjsConfig.serviceId');
        	return;
    	}
    
    	// DonnÃƒÂ©es de test avec VOTRE email
    	var testData = {
        	to_email: 'VOTRE_EMAIL@exemple.com',  // Ã¢Å¡Â Ã¯Â¸Â Remplacez par votre email
        	to_name: 'Test Utilisateur',
        	subject: 'Ã°Å¸Â§Âª Test EmailJS Golf Club',
        	message: 'Si vous recevez ce message, EmailJS fonctionne correctement !',
        	from_name: 'Golf Club Management'
    	};
    
    	console.log('Ã°Å¸â€œÂ§ Envoi test vers:', testData.to_email);
    	console.log('Ã°Å¸â€Â§ Configuration:', emailjsConfig);
    
    	// Test avec gestion d'erreur dÃƒÂ©taillÃƒÂ©e
    	emailjs.send(emailjsConfig.serviceId, emailjsConfig.templateIdResults, testData, emailjsConfig.publicKey)
    	.then(function(response) {
    	    console.log('Ã¢Å“â€¦ SuccÃƒÂ¨s EmailJS:', response);
        	alert('Ã¢Å“â€¦ Test rÃƒÂ©ussi ! Code: ' + response.status + '\n\nVÃƒÂ©rifiez votre boÃƒÂ®te email.');
    	}).catch(function(error) {
        	console.error('Ã¢ÂÅ’ Erreur EmailJS complÃƒÂ¨te:', error);
        	alert('Ã¢ÂÅ’ Erreur EmailJS:\n' + 
            	  'Status: ' + (error.status || 'inconnu') + '\n' +
            	  'Text: ' + (error.text || error.message || 'Erreur inconnue') + '\n\n' +
            	  'VÃƒÂ©rifiez votre configuration sur emailjs.com');
    	});
	}

	// Ã°Å¸â€œÂ§ FONCTION D'ENVOI AMÃƒâ€°LIORÃƒâ€°E AVEC DÃƒâ€°LAIS
	async function sendEmailNotification(type, recipients, data) {
    	console.log('Ã°Å¸â€œÂ§ Envoi notification', type, 'vers', recipients.length, 'destinataires');
    
    	if (!emailjsConfig.serviceId || emailjsConfig.serviceId === 'YOUR_SERVICE_ID') {
        	console.error('Ã¢ÂÅ’ Service ID manquant');
        	alert('Ã¢ÂÅ’ Configuration EmailJS incomplÃƒÂ¨te. Configurez le Service ID.');
        	return;
    	}
    
    	var successCount = 0;
    	var errorCount = 0;
    
    	// Envoyer un email ÃƒÂ  la fois avec dÃƒÂ©lai
    	for (var i = 0; i < recipients.length; i++) {
    	    var recipient = recipients[i];
        
        	if (!recipient.email || recipient.email.trim() === '') {
            	console.log('Ã¢ÂÅ’ Pas d\'email pour', recipient.name);
            	continue;
        	}
        
        	try {
            	var emailContent;
            	if (type === 'upcoming') {
                	emailContent = generateUpcomingGameEmail(recipient, data);
            	} else if (type === 'results') {
            	    emailContent = generateGameResultsEmail(recipient, data);
            	}
            
            	var templateId = type === 'upcoming' ? emailjsConfig.templateIdUpcoming : emailjsConfig.templateIdResults;
            
            	var templateParams = {
                	to_email: recipient.email,
                	to_name: recipient.name,
                	subject: emailContent.subject,
                	message: emailContent.body,
                	from_name: 'Golf Club Management'
            	};
            
            	console.log('Ã°Å¸â€œÂ¤ Envoi ÃƒÂ :', recipient.name, '(' + recipient.email + ')');
            
            	// Attendre la rÃƒÂ©ponse avant de continuer
            	await emailjs.send(emailjsConfig.serviceId, templateId, templateParams, emailjsConfig.publicKey)
            	.then(function(response) {
                	console.log('Ã¢Å“â€¦ Email envoyÃƒÂ© ÃƒÂ ', recipient.name, '- Status:', response.status);
                	successCount++;
                
                	// Ajouter au log
                	if (!window.notificationLog) window.notificationLog = [];
                	notificationLog.push({
                	    timestamp: new Date().toISOString(),
                    	type: type,
                    	recipient: { id: recipient.id, name: recipient.name, email: recipient.email },
                    	status: 'success'
                	});
            	}).catch(function(error) {
                	console.error('Ã¢ÂÅ’ Erreur envoi ÃƒÂ ', recipient.name, ':', error);
                	errorCount++;
                
                	// Ajouter au log d'erreur
                	if (!window.notificationLog) window.notificationLog = [];
                	notificationLog.push({
                	    timestamp: new Date().toISOString(),
                    	type: type,
                    	recipient: { id: recipient.id, name: recipient.name, email: recipient.email },
                    	status: 'error',
                    	error: error.text || error.message
                	});
            	});
            
            	// DÃƒÂ©lai entre les emails pour ÃƒÂ©viter la surcharge
            	if (i < recipients.length - 1) {
                	await new Promise(resolve => setTimeout(resolve, 1000)); // 1 seconde de dÃƒÂ©lai
            	}
            
        	} catch (error) {
            	console.error('Ã¢ÂÅ’ Erreur inattendue pour', recipient.name, ':', error);
            	errorCount++;
        	}
    	}
    
    	// RÃƒÂ©sumÃƒÂ© final
    	console.log('Ã°Å¸â€œÅ  RÃƒÂ©sumÃƒÂ© envoi - SuccÃƒÂ¨s:', successCount, 'Erreurs:', errorCount);
    	alert('Ã°Å¸â€œÂ§ Envoi terminÃƒÂ©:\nÃ¢Å“â€¦ ' + successCount + ' succÃƒÂ¨s\nÃ¢ÂÅ’ ' + errorCount + ' erreurs');
    
    	// Mettre ÃƒÂ  jour les statistiques
    	if (typeof updateNotificationStats === 'function') {
    	    updateNotificationStats();
    	}
	}

	// Ã°Å¸â€Â FONCTION DE DIAGNOSTIC COMPLÃƒË†TE
	function debugEmailConfig() {
    	console.log('=== Ã°Å¸â€Â DIAGNOSTIC EMAILJS ===');
    	console.log('EmailJS chargÃƒÂ©:', typeof emailjs !== 'undefined');
    	console.log('Version EmailJS:', emailjs ? emailjs.version : 'N/A');
    	console.log('Configuration:', emailjsConfig);
    	console.log('Service ID configurÃƒÂ©:', emailjsConfig.serviceId !== 'YOUR_SERVICE_ID');
    
    	// VÃƒÂ©rifier les templates
    	console.log('Templates configurÃƒÂ©s:');
    	console.log(' - Upcoming:', emailjsConfig.templateIdUpcoming);
    	console.log(' - Results:', emailjsConfig.templateIdResults);
    
    	// VÃƒÂ©rifier les joueurs avec email
    	if (typeof players !== 'undefined') {
        	var playersWithEmail = players.filter(p => p.email && p.email.trim() !== '');
        	console.log('Joueurs avec email (' + playersWithEmail.length + '/' + players.length + '):');
        	playersWithEmail.forEach(p => console.log(' -', p.name, ':', p.email));
    	}
    
    	console.log('=== FIN DIAGNOSTIC ===');
	}

	// === NOTIFICATIONS AUTOMATIQUES ===

	// Fonction utilitaire pour crÃƒÂ©er une date locale sans dÃƒÂ©calage de fuseau horaire
	function createLocalDate(dateString) {
		// dateString format: "YYYY-MM-DD"
		var parts = dateString.split('-');
		var year = parseInt(parts[0]);
		var month = parseInt(parts[1]) - 1; // Les mois sont 0-indexÃƒÂ©s en JavaScript
		var day = parseInt(parts[2]);
		return new Date(year, month, day);
	}

	// Fonction pour gÃƒÂ©nÃƒÂ©rer les emails
	function generateUpcomingGameEmail(recipient, data) {
	    var event = data.event;
    	var teeTime = data.teeTime;
    
    	var eventDate = createLocalDate(event.date);
    	var dateStr = eventDate.toLocaleDateString('fr-FR', {
        	weekday: 'long',
        	year: 'numeric',
        	month: 'long',
        	day: 'numeric'
    	});
    
    	var subject = 'Ã¢â€ºÂ³ Partie de golf planifiÃƒÂ©e - ' + dateStr;
    
    	var body = `Bonjour ${recipient.name},

	Ã°Å¸â€œâ€¦ PARTIE PLANIFIÃƒâ€°E
	Ã¢â€ÂÃ¢â€ÂÃ¢â€ÂÃ¢â€ÂÃ¢â€ÂÃ¢â€ÂÃ¢â€ÂÃ¢â€ÂÃ¢â€ÂÃ¢â€ÂÃ¢â€ÂÃ¢â€ÂÃ¢â€ÂÃ¢â€ÂÃ¢â€ÂÃ¢â€ÂÃ¢â€ÂÃ¢â€ÂÃ¢â€ÂÃ¢â€ÂÃ¢â€ÂÃ¢â€ÂÃ¢â€ÂÃ¢â€ÂÃ¢â€ÂÃ¢â€ÂÃ¢â€ÂÃ¢â€ÂÃ¢â€ÂÃ¢â€ÂÃ¢â€ÂÃ¢â€ÂÃ¢â€ÂÃ¢â€ÂÃ¢â€ÂÃ¢â€ÂÃ¢â€ÂÃ¢â€ÂÃ¢â€ÂÃ¢â€ÂÃ¢â€ÂÃ¢â€ÂÃ¢â€ÂÃ¢â€Â

	Ã°Å¸â€œâ€  Date: ${dateStr}
	Ã°Å¸ÂÅ’Ã¯Â¸Â Terrain: ${event.course}
	Ã°Å¸Ââ€  Type: ${getEventTypeName(event.type)}
	Ã°Å¸â€˜Â¤ Organisateur: ${event.organizerName || 'Non dÃƒÂ©fini'}

	Ã¢ÂÂ° VOTRE HEURE DE DÃƒâ€°PART: ${teeTime ? teeTime.time : 'Ãƒâ‚¬ confirmer'}

	${teeTime && teeTime.players && teeTime.players.length > 0 ? 
	`Ã°Å¸â€˜Â¥ VOTRE GROUPE:
	${teeTime.players.map((playerId, index) => {
	    var player = players.find(p => p.id === playerId);
    	var playerName = player ? (player.name || (player.firstName + ' ' + player.lastName)) : 'Joueur #' + playerId;
    	return `   ${index + 1}. ${playerName}`;
	}).join('\n')}` : ''}

	${event.comments ? `Ã°Å¸â€œÂ NOTES: ${event.comments}` : ''}

	Ãƒâ‚¬ bientÃƒÂ´t sur le terrain !
	Pour plus de dÃƒÂ©tails, visitez le site https://azume7.github.io/Golf_Diablo_GPR/

	Sportivement,
	L'ÃƒÂ©quipe Guever Golf Club`;

	    return { subject: subject, body: body };
	}

	// Fonction pour gÃƒÂ©nÃƒÂ©rer les emails de rÃƒÂ©sultats - VERSION AMÃƒâ€°LIORÃƒâ€°E
	function generateGameResultsEmail(recipient, data) {
    	var round = data.round;
    	var playerScore = data.playerScore;
    	var roundRanking = data.roundRanking;
    
    	var gameDate = createLocalDate(round.date);
    	var formattedDate = gameDate.toLocaleDateString('fr-CA'); // Format YYYY-MM-DD
    	var monthNames = ['janvier', 'fÃƒÂ©vrier', 'mars', 'avril', 'mai', 'juin', 'juillet', 'aoÃƒÂ»t', 'septembre', 'octobre', 'novembre', 'dÃƒÂ©cembre'];
    	var displayDate = gameDate.getDate() + ' ' + monthNames[gameDate.getMonth()] + ' ' + gameDate.getFullYear();
    
    	var subject = 'Ã°Å¸ÂÅ’Ã¯Â¸Â RÃƒÂ©sultats partie du ' + displayDate;
    
    	// SECTION COMMUNE
    	var commonSection = `Bonjour ${recipient.name},

	Ã°Å¸â€œÅ  VOS RÃƒâ€°SULTATS
	Ã¢â€ÂÃ¢â€ÂÃ¢â€ÂÃ¢â€ÂÃ¢â€ÂÃ¢â€ÂÃ¢â€ÂÃ¢â€ÂÃ¢â€ÂÃ¢â€ÂÃ¢â€ÂÃ¢â€ÂÃ¢â€ÂÃ¢â€ÂÃ¢â€ÂÃ¢â€ÂÃ¢â€ÂÃ¢â€ÂÃ¢â€ÂÃ¢â€ÂÃ¢â€ÂÃ¢â€ÂÃ¢â€ÂÃ¢â€ÂÃ¢â€ÂÃ¢â€ÂÃ¢â€ÂÃ¢â€ÂÃ¢â€ÂÃ¢â€ÂÃ¢â€ÂÃ¢â€ÂÃ¢â€ÂÃ¢â€ÂÃ¢â€ÂÃ¢â€ÂÃ¢â€ÂÃ¢â€ÂÃ¢â€ÂÃ¢â€ÂÃ¢â€ÂÃ¢â€ÂÃ¢â€ÂÃ¢â€Â

	Ã°Å¸ÂÅ’Ã¯Â¸Â Terrain: ${round.course}
	Ã°Å¸Ââ€  Type: ${round.type === 'gpr' ? 'Coupe GPR' : round.type === 'diablo' ? 'Coupe Diablo' : 'Partie amicale'}

	- Score brut: ${playerScore.score}
	- Handicap parcours: ${playerScore.courseHandicap.toFixed(1)}
	- Score net: ${playerScore.net.toFixed(1)}
	- Position: ${data.playerPosition}e sur ${roundRanking.length} joueurs

	${data.playerPosition <= 3 ? 'Ã°Å¸Å½â€° FÃƒâ€°LICITATIONS ! Excellente performance ! Ã°Å¸Å½â€°' : 
	  data.playerPosition <= Math.ceil(roundRanking.length / 2) ? 'Ã°Å¸â€˜Â Bonne partie !' : 
	  'Ã°Å¸â€™Âª Continuez vos efforts !'}`;

	    var body = commonSection;
    
	    // SECTION SPÃƒâ€°CIFIQUE SELON LE TYPE
	    if (round.type === 'gpr') {
	        body += generateGPRSpecificSection(recipient, data, round, playerScore, roundRanking);
	    } else if (round.type === 'diablo') {
	        body += generateDiabloSpecificSection(recipient, data, round, roundRanking);
    	}
    
    	// SECTION FINALE COMMUNE
    	body += `

	Merci d'avoir participÃƒÂ© !
	Pour plus de dÃƒÂ©tails, visitez le site https://azume7.github.io/Golf_Diablo_GPR/

	Sportivement,
	L'ÃƒÂ©quipe Guever Golf Club`;

	    return { subject: subject, body: body };
	}

	// NOUVELLE FONCTION: Section spÃƒÂ©cifique GPR
	function generateGPRSpecificSection(recipient, data, round, playerScore, roundRanking) {
    	var gprSection = '';
    
    	// Calculer les points GPR de cette partie
    	var brutPosition = roundRanking.findIndex(r => r.playerId === recipient.id) + 1;
    	var netPosition = data.playerPosition;
    
    	// Points selon les barÃƒÂ¨mes
    	var isFinale = (round.gprPhase === 'finale');
    	var brutPointsScale = isFinale ? 
        	[175, 140, 120, 100, 85, 70, 60, 50, 40, 30, 20, 10] : 
        	[80, 68, 60, 52, 45, 40, 35, 30, 25, 20, 15, 10];
    	var netPointsScale = isFinale ? 
        	[225, 190, 165, 140, 125, 110, 90, 75, 60, 45, 35, 25] : 
        	[120, 105, 90, 78, 70, 62, 54, 46, 38, 30, 22, 15];
    
    	var brutPoints = brutPointsScale[Math.min(brutPosition - 1, brutPointsScale.length - 1)];
    	var netPoints = netPointsScale[Math.min(netPosition - 1, netPointsScale.length - 1)];
    	var totalRoundPoints = brutPoints + netPoints;
    
    	gprSection += `

	Ã°Å¸Å½Â¯ POINTS GPR CETTE PARTIE
	Ã¢â€ÂÃ¢â€ÂÃ¢â€ÂÃ¢â€ÂÃ¢â€ÂÃ¢â€ÂÃ¢â€ÂÃ¢â€ÂÃ¢â€ÂÃ¢â€ÂÃ¢â€ÂÃ¢â€ÂÃ¢â€ÂÃ¢â€ÂÃ¢â€ÂÃ¢â€ÂÃ¢â€ÂÃ¢â€ÂÃ¢â€ÂÃ¢â€ÂÃ¢â€ÂÃ¢â€ÂÃ¢â€ÂÃ¢â€ÂÃ¢â€ÂÃ¢â€ÂÃ¢â€ÂÃ¢â€ÂÃ¢â€ÂÃ¢â€ÂÃ¢â€ÂÃ¢â€ÂÃ¢â€ÂÃ¢â€ÂÃ¢â€ÂÃ¢â€ÂÃ¢â€ÂÃ¢â€ÂÃ¢â€ÂÃ¢â€ÂÃ¢â€ÂÃ¢â€ÂÃ¢â€ÂÃ¢â€Â

	Ã°Å¸â€œÅ  Position brut: ${brutPosition}e Ã¢â€ â€™ ${brutPoints} points
	Ã°Å¸Ââ€  Position net: ${netPosition}e Ã¢â€ â€™ ${netPoints} points
	Ã¢Â­Â TOTAL PARTIE: ${totalRoundPoints} points

	${isFinale ? 'Ã°Å¸Ââ€  PARTIE FINALE - Points majorÃƒÂ©s!' : 'Ã°Å¸â€œÅ  Partie d\'exhibition'}`;

	    // Calculer le total de points de la saison
    	try {
        	var playerTotalPoints = calculatePlayerSeasonTotal(recipient.id, round.year);
        	var seasonRanking = calculateSeasonRanking(round.year);
        	var playerSeasonPosition = seasonRanking.findIndex(p => p.playerId === recipient.id) + 1;
        
        	gprSection += `

	Ã°Å¸â€œË† TOTAL SAISON GPR ${round.year}
	Ã¢â€ÂÃ¢â€ÂÃ¢â€ÂÃ¢â€ÂÃ¢â€ÂÃ¢â€ÂÃ¢â€ÂÃ¢â€ÂÃ¢â€ÂÃ¢â€ÂÃ¢â€ÂÃ¢â€ÂÃ¢â€ÂÃ¢â€ÂÃ¢â€ÂÃ¢â€ÂÃ¢â€ÂÃ¢â€ÂÃ¢â€ÂÃ¢â€ÂÃ¢â€ÂÃ¢â€ÂÃ¢â€ÂÃ¢â€ÂÃ¢â€ÂÃ¢â€ÂÃ¢â€ÂÃ¢â€ÂÃ¢â€ÂÃ¢â€ÂÃ¢â€ÂÃ¢â€ÂÃ¢â€ÂÃ¢â€ÂÃ¢â€ÂÃ¢â€ÂÃ¢â€ÂÃ¢â€ÂÃ¢â€ÂÃ¢â€ÂÃ¢â€ÂÃ¢â€ÂÃ¢â€ÂÃ¢â€Â

	Ã°Å¸Ââ€  Total points: ${playerTotalPoints} points
	Ã°Å¸â€œÅ  Position saison: ${playerSeasonPosition}e sur ${seasonRanking.length} joueurs

	${playerSeasonPosition <= 3 ? 'Ã°Å¸Å½Â¯ EXCELLENT ! Vous ÃƒÂªtes dans le TOP 3 !' : 
	  playerSeasonPosition <= 6 ? 'Ã°Å¸â€˜Â TrÃƒÂ¨s bien ! Vous ÃƒÂªtes dans le TOP 6 !' : 
	  'Ã°Å¸â€™Âª Continuez, chaque point compte !'}`;
  
	        // Afficher le TOP 5 actuel
	        gprSection += `

	Ã°Å¸Ââ€  TOP 5 SAISON ACTUEL
	Ã¢â€ÂÃ¢â€ÂÃ¢â€ÂÃ¢â€ÂÃ¢â€ÂÃ¢â€ÂÃ¢â€ÂÃ¢â€ÂÃ¢â€ÂÃ¢â€ÂÃ¢â€ÂÃ¢â€ÂÃ¢â€ÂÃ¢â€ÂÃ¢â€ÂÃ¢â€ÂÃ¢â€ÂÃ¢â€ÂÃ¢â€ÂÃ¢â€ÂÃ¢â€ÂÃ¢â€ÂÃ¢â€ÂÃ¢â€ÂÃ¢â€ÂÃ¢â€ÂÃ¢â€ÂÃ¢â€ÂÃ¢â€ÂÃ¢â€ÂÃ¢â€ÂÃ¢â€ÂÃ¢â€ÂÃ¢â€ÂÃ¢â€ÂÃ¢â€ÂÃ¢â€ÂÃ¢â€ÂÃ¢â€ÂÃ¢â€ÂÃ¢â€ÂÃ¢â€ÂÃ¢â€ÂÃ¢â€Â

	${seasonRanking.slice(0, 5).map((player, index) => {
    	var medal = index === 0 ? 'Ã°Å¸Â¥â€¡' : index === 1 ? 'Ã°Å¸Â¥Ë†' : index === 2 ? 'Ã°Å¸Â¥â€°' : index === 3 ? '4Ã¯Â¸ÂÃ¢Æ’Â£' : '5Ã¯Â¸ÂÃ¢Æ’Â£';
    	return `${medal} ${(index + 1)}. ${player.playerName} - ${player.totalPoints} pts`;
	}).join('\n')}`;

	    } catch (error) {
    	    console.log('Erreur calcul saison GPR:', error);
        	gprSection += `

	Ã°Å¸â€œË† SAISON GPR ${round.year}: Calcul en cours...`;
    	}
    
    	return gprSection;
	}

	// NOUVELLE FONCTION: Section spÃƒÂ©cifique Diablo  
	function generateDiabloSpecificSection(recipient, data, round, roundRanking) {
    	var diabloSection = `

	Ã°Å¸Ââ€  CLASSEMENT COMPLET
	Ã¢â€ÂÃ¢â€ÂÃ¢â€ÂÃ¢â€ÂÃ¢â€ÂÃ¢â€ÂÃ¢â€ÂÃ¢â€ÂÃ¢â€ÂÃ¢â€ÂÃ¢â€ÂÃ¢â€ÂÃ¢â€ÂÃ¢â€ÂÃ¢â€ÂÃ¢â€ÂÃ¢â€ÂÃ¢â€ÂÃ¢â€ÂÃ¢â€ÂÃ¢â€ÂÃ¢â€ÂÃ¢â€ÂÃ¢â€ÂÃ¢â€ÂÃ¢â€ÂÃ¢â€ÂÃ¢â€ÂÃ¢â€ÂÃ¢â€ÂÃ¢â€ÂÃ¢â€ÂÃ¢â€ÂÃ¢â€ÂÃ¢â€ÂÃ¢â€ÂÃ¢â€ÂÃ¢â€ÂÃ¢â€ÂÃ¢â€ÂÃ¢â€ÂÃ¢â€ÂÃ¢â€ÂÃ¢â€Â

	${roundRanking.map((player, index) => {
	    var medal = index === 0 ? 'Ã°Å¸Â¥â€¡' : index === 1 ? 'Ã°Å¸Â¥Ë†' : index === 2 ? 'Ã°Å¸Â¥â€°' : '  ';
    	return `${medal} ${(index + 1).toString().padStart(2)}. ${player.playerName.padEnd(20)} ${player.net.toFixed(1)}`;
	}).join('\n')}`;

    	// Ajouter info tournoi Diablo si plusieurs parties
    	try {
        	var diabloRounds = rounds.filter(r => r.type === 'diablo' && r.year === round.year);
        	if (diabloRounds.length > 1) {
            	diabloSection += `

	Ã°Å¸Ââ€  TOURNOI DIABLO ${round.year}
	Ã¢â€ÂÃ¢â€ÂÃ¢â€ÂÃ¢â€ÂÃ¢â€ÂÃ¢â€ÂÃ¢â€ÂÃ¢â€ÂÃ¢â€ÂÃ¢â€ÂÃ¢â€ÂÃ¢â€ÂÃ¢â€ÂÃ¢â€ÂÃ¢â€ÂÃ¢â€ÂÃ¢â€ÂÃ¢â€ÂÃ¢â€ÂÃ¢â€ÂÃ¢â€ÂÃ¢â€ÂÃ¢â€ÂÃ¢â€ÂÃ¢â€ÂÃ¢â€ÂÃ¢â€ÂÃ¢â€ÂÃ¢â€ÂÃ¢â€ÂÃ¢â€ÂÃ¢â€ÂÃ¢â€ÂÃ¢â€ÂÃ¢â€ÂÃ¢â€ÂÃ¢â€ÂÃ¢â€ÂÃ¢â€ÂÃ¢â€ÂÃ¢â€ÂÃ¢â€ÂÃ¢â€ÂÃ¢â€Â

	Ã°Å¸â€œÅ  Partie ${diabloRounds.findIndex(r => r.id === round.id) + 1} sur ${diabloRounds.length}
	Ã¢Â­Â Votre moyenne actuelle sera calculÃƒÂ©e aprÃƒÂ¨s toutes les parties`;
	        }
	    } catch (error) {
    	    console.log('Erreur calcul Diablo:', error);
    	}
    
    	return diabloSection;
	}

	// NOUVELLES FONCTIONS: Calculs GPR pour les emails

	// Calculer le total de points d'un joueur pour une saison
	function calculatePlayerSeasonTotal(playerId, year) {
    	try {
        	// Filtrer les scores GPR de l'annÃƒÂ©e pour ce joueur
        	var playerGPRScores = scores.filter(s => 
            	s.playerId === playerId && 
            	s.type === 'gpr' && 
            	s.year == year &&
            	s.playerId !== 13 // Exclure Ãƒâ€°ric Gosselin
        	);
        
        	if (playerGPRScores.length === 0) {
            	return 0;
        	}
        
        	var totalPoints = 0;
        	var brutPointsScale = [80, 68, 60, 52, 45, 40, 35, 30, 25, 20, 15, 10];
        	var netPointsScale = [120, 105, 90, 78, 70, 62, 54, 46, 38, 30, 22, 15];
        
        	// Points finale (si applicable)
        	var finaleBrutPoints = [175, 140, 120, 100, 85, 70, 60, 50, 40, 30, 20, 10];
        	var finaleNetPoints = [225, 190, 165, 140, 125, 110, 90, 75, 60, 45, 35, 25];
        
        	// Calculer les points pour chaque partie
        	var gprRounds = rounds.filter(r => r.type === 'gpr' && r.year == year);
        
        	for (var i = 0; i < gprRounds.length; i++) {
        	    var round = gprRounds[i];
            	var roundScores = scores.filter(s => s.roundId === round.id && s.playerId !== 13);
            
            	// Trouver le score du joueur pour cette partie
            	var playerScore = roundScores.find(s => s.playerId === playerId);
            
            	if (playerScore) {
                	// Classements pour cette partie
                	var brutRanking = [...roundScores].sort((a, b) => a.score - b.score);
                	var netRanking = [...roundScores].sort((a, b) => a.net - b.net);
                
                	var brutPosition = brutRanking.findIndex(s => s.playerId === playerId) + 1;
                	var netPosition = netRanking.findIndex(s => s.playerId === playerId) + 1;
                
                	// DÃƒÂ©terminer si c'est une finale
                	var isFinale = (round.gprPhase === 'finale');
                
                	// Calculer les points
                	var pointsScaleBrut = isFinale ? finaleBrutPoints : brutPointsScale;
                	var pointsScaleNet = isFinale ? finaleNetPoints : netPointsScale;
                
                	var brutPoints = pointsScaleBrut[Math.min(brutPosition - 1, pointsScaleBrut.length - 1)];
                	var netPoints = pointsScaleNet[Math.min(netPosition - 1, pointsScaleNet.length - 1)];
                
                	totalPoints += brutPoints + netPoints;
            	}
        	}
        
        	return totalPoints;
        
    	} catch (error) {
        	console.error('Erreur calculatePlayerSeasonTotal:', error);
        	return 0;
    	}
	}

	// Calculer le classement de la saison
	function calculateSeasonRanking(year) {
    	try {
        	var seasonRanking = [];
        
        	// Obtenir tous les joueurs qui ont jouÃƒÂ© du GPR cette annÃƒÂ©e
        	var gprPlayersThisYear = scores.filter(s => 
            	s.type === 'gpr' && 
            	s.year == year && 
            	s.playerId !== 13
        	).map(s => s.playerId).filter((v, i, a) => a.indexOf(v) === i);
        
        	// Calculer les points pour chaque joueur
        	for (var i = 0; i < gprPlayersThisYear.length; i++) {
            	var playerId = gprPlayersThisYear[i];
            	var player = players.find(p => p.id === playerId);
            
            	if (player) {
            	    var totalPoints = calculatePlayerSeasonTotal(playerId, year);
                	var playerName = player.name || (player.firstName + ' ' + player.lastName);
                
                	seasonRanking.push({
                	    playerId: playerId,
                    	playerName: playerName,
                    	totalPoints: totalPoints
                	});
            	}
        	}
        
        	// Trier par points dÃƒÂ©croissants
        	seasonRanking.sort((a, b) => b.totalPoints - a.totalPoints);
        
        	return seasonRanking;
        
    	} catch (error) {
    	    console.error('Erreur calculateSeasonRanking:', error);
        	return [];
    	}
	}

	// Calculer les points d'une partie spÃƒÂ©cifique
	function calculateRoundPoints(playerId, roundId) {
	    try {
    	    var round = rounds.find(r => r.id === roundId);
        	if (!round || round.type !== 'gpr') {
            	return { brutPoints: 0, netPoints: 0, totalPoints: 0 };
        	}
        
        	var roundScores = scores.filter(s => s.roundId === roundId && s.playerId !== 13);
        	var playerScore = roundScores.find(s => s.playerId === playerId);
        
        	if (!playerScore) {
        	    return { brutPoints: 0, netPoints: 0, totalPoints: 0 };
        	}
        
        	// Classements
        	var brutRanking = [...roundScores].sort((a, b) => a.score - b.score);
        	var netRanking = [...roundScores].sort((a, b) => a.net - b.net);
        
        	var brutPosition = brutRanking.findIndex(s => s.playerId === playerId) + 1;
        	var netPosition = netRanking.findIndex(s => s.playerId === playerId) + 1;
        
        	// Points selon le type de partie
        	var isFinale = (round.gprPhase === 'finale');
        
        	var brutPointsScale = isFinale ? 
        	    [175, 140, 120, 100, 85, 70, 60, 50, 40, 30, 20, 10] : 
        	    [80, 68, 60, 52, 45, 40, 35, 30, 25, 20, 15, 10];
        	var netPointsScale = isFinale ? 
        	    [225, 190, 165, 140, 125, 110, 90, 75, 60, 45, 35, 25] : 
            	[120, 105, 90, 78, 70, 62, 54, 46, 38, 30, 22, 15];
        
        	var brutPoints = brutPointsScale[Math.min(brutPosition - 1, brutPointsScale.length - 1)];
        	var netPoints = netPointsScale[Math.min(netPosition - 1, netPointsScale.length - 1)];
        	var totalPoints = brutPoints + netPoints;
        
        	return {
        	    brutPoints: brutPoints,
        	    netPoints: netPoints,
            	totalPoints: totalPoints,
            	brutPosition: brutPosition,
            	netPosition: netPosition
        	};
        
    	} catch (error) {
        	console.error('Erreur calculateRoundPoints:', error);
        	return { brutPoints: 0, netPoints: 0, totalPoints: 0 };
    	}
	}

	// Envoyer notification email
	function sendEmailNotification(type, recipients, data) {
    	console.log('Ã°Å¸â€œÂ§ Envoi notification', type, 'vers', recipients.length, 'destinataires');
    
    	for (var i = 0; i < recipients.length; i++) {
        	var recipient = recipients[i];
        
        	if (!recipient.email) {
        	    console.log('Ã¢ÂÅ’ Pas d\'email pour', recipient.name);
            	continue;
        	}

        	var emailContent;
        	if (type === 'upcoming') {
            	emailContent = generateUpcomingGameEmail(recipient, data);
        	} else if (type === 'results') {
            	emailContent = generateGameResultsEmail(recipient, data);
        	}
        
        	var templateId = type === 'upcoming' ? emailjsConfig.templateIdUpcoming : emailjsConfig.templateIdResults;
        
        	var templateParams = {
            	to_email: recipient.email,
            	to_name: recipient.name,
            	subject: emailContent.subject,
            	message: emailContent.body,
            	from_name: 'Golf Club Management'
        	};

        	emailjs.send(emailjsConfig.serviceId, templateId, templateParams, emailjsConfig.publicKey)
        	.then(function(response) {
        	    console.log('Ã¢Å“â€¦ Email envoyÃƒÂ© ÃƒÂ ', recipient.name);
            	notificationLog.push({
                	timestamp: new Date().toISOString(),
                	type: type,
                	recipient: { id: recipient.id, name: recipient.name, email: recipient.email },
                	status: 'success'
            	});
        	}).catch(function(error) {
            	console.error('Ã¢ÂÅ’ Erreur envoi email:', error);
            	notificationLog.push({
            	    timestamp: new Date().toISOString(),
                	type: type,
                	recipient: { id: recipient.id, name: recipient.name, email: recipient.email },
                	status: 'error',
                	error: error.text
            	});
        	});
    	}
	}

	// Ã°Å¸â€Â§ FONCTION POUR VÃƒâ€°RIFIER ET RECHARGER LES DONNÃƒâ€°ES JOUEURS
	async function ensurePlayersDataLoaded() {
    	console.log('Ã°Å¸â€â€ VÃƒÂ©rification des donnÃƒÂ©es joueurs...');
    
    	if (!players || players.length === 0) {
        	console.log('Ã¢Å¡Â Ã¯Â¸Â DonnÃƒÂ©es joueurs manquantes, rechargement depuis Firebase...');
        	await loadDataFromFirebase();
    	}
    
    	console.log('Ã¢Å“â€¦ DonnÃƒÂ©es joueurs disponibles:', players.length, 'joueurs');
    
    	// Debug: afficher tous les emails disponibles
    	var playersWithEmails = players.filter(p => p.email && p.email.trim() !== '');
    	console.log('Ã°Å¸â€œÂ§ Joueurs avec email:', playersWithEmails.length);
    	playersWithEmails.forEach(p => {
        	console.log(' -', p.name || (p.firstName + ' ' + p.lastName), ':', p.email);
    	});
    
    	return players;
	}

	// Ã°Å¸â€Â§ FONCTION DE DEBUG AMÃƒâ€°LIORÃƒâ€°E
	function debugPlayersAndEmails() {
    	console.log('=== Ã°Å¸â€Â DEBUG COMPLET JOUEURS ET EMAILS ===');
    
    	console.log('Ã°Å¸â€œÅ  Ãƒâ€°tat des donnÃƒÂ©es:');
    	console.log(' - players dÃƒÂ©fini:', typeof players !== 'undefined');
    	console.log(' - Nombre de joueurs:', players ? players.length : 0);
    	console.log(' - isDataLoaded:', typeof isDataLoaded !== 'undefined' ? isDataLoaded : 'undefined');
    
    	if (players && players.length > 0) {
        	console.log('\nÃ°Å¸â€˜Â¥ TOUS LES JOUEURS:');
        	players.forEach(function(player, index) {
            	var name = player.name || (player.firstName + ' ' + player.lastName) || 'Joueur sans nom';
            	var email = player.email || 'AUCUN';
            	var hasEmail = player.email && player.email.trim() !== '';
            
            	console.log(`${index + 1}. ID: ${player.id} | ${name} | Email: ${email} | Valide: ${hasEmail ? 'OUI' : 'NON'}`);
        	});
        
        	var withEmails = players.filter(p => p.email && p.email.trim() !== '');
        	console.log(`\nÃ°Å¸â€œÂ§ RÃƒâ€°SUMÃƒâ€°: ${withEmails.length}/${players.length} joueurs ont un email`);
        
    	} else {
    	    console.log('Ã¢ÂÅ’ Aucun joueur trouvÃƒÂ© - les donnÃƒÂ©es ne sont peut-ÃƒÂªtre pas chargÃƒÂ©es');
        	console.log('Ã°Å¸â€™Â¡ Essayez d\'exÃƒÂ©cuter: loadDataFromFirebase()');
    	}
    
    	console.log('=== FIN DEBUG ===');
	}

	// Ã°Å¸â€Â§ FONCTION POUR RECHARGER LES DONNÃƒâ€°ES MANUELLEMENT
	async function reloadPlayersData() {
	    console.log('Ã°Å¸â€â€ Rechargement manuel des donnÃƒÂ©es...');
    	try {
        	await loadDataFromFirebase();
        	console.log('Ã¢Å“â€¦ DonnÃƒÂ©es rechargÃƒÂ©es avec succÃƒÂ¨s');
        	debugPlayersAndEmails();
        	alert('Ã¢Å“â€¦ DonnÃƒÂ©es joueurs rechargÃƒÂ©es!\nVÃƒÂ©rifiez la console pour les dÃƒÂ©tails.');
    	} catch (error) {
        	console.error('Ã¢ÂÅ’ Erreur rechargement:', error);
        	alert('Ã¢ÂÅ’ Erreur lors du rechargement: ' + error.message);
    	}
	}

	window.onload = function() {
    	console.log('Ã°Å¸Å¡â‚¬ Initialisation de l\'application...');
    	showLoading('Chargement des donnÃƒÂ©es...');
    
    	// Charger les donnÃƒÂ©es depuis Firebase
    	loadDataFromFirebase().then(function() {
        	console.log('Ã¢Å“â€¦ DonnÃƒÂ©es chargÃƒÂ©es depuis Firebase');
        
        	// Charger la configuration EmailJS sauvegardÃƒÂ©e
        	loadSavedEmailjsConfig();
        
        	// VÃƒÂ©rifier que les joueurs sont bien chargÃƒÂ©s
        	console.log('Ã°Å¸â€˜Â¥ Joueurs chargÃƒÂ©s:', players ? players.length : 0);
        
        	hideLoading();
        
        	// Configurer les listeners temps rÃ©el
        	setupRealtimeListeners();
        
        	// Debug automatique au dÃƒÂ©marrage (optionnel)
        	setTimeout(function() {
            	console.log('Ã°Å¸â€Â VÃƒÂ©rification automatique des donnÃƒÂ©es...');
            	if (!players || players.length === 0) {
            	    console.warn('Ã¢Å¡Â Ã¯Â¸Â Aucun joueur chargÃƒÂ© au dÃƒÂ©marrage');
            	} else {
            	    var withEmails = players.filter(p => p.email && p.email.trim() !== '');
                	console.log('Ã°Å¸â€œÂ§ Joueurs avec email:', withEmails.length + '/' + players.length);
            	}
        	}, 2000);
        
    	}).catch(function(error) {
        	console.error('Ã¢ÂÅ’ Erreur chargement initial:', error);
        	hideLoading();
        	alert('Ã¢ÂÅ’ Erreur lors du chargement des donnÃƒÂ©es: ' + error.message);
    	});
	}
	
</script>
</body>
</html>