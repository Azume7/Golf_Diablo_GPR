<!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Gestion Tournois Golf - Scores Détaillés</title>
    <!-- Firebase SDKs -->
	<script src="https://www.gstatic.com/firebasejs/9.22.0/firebase-app-compat.js"></script>
	<script src="https://www.gstatic.com/firebasejs/9.22.0/firebase-database-compat.js"></script>
	<style>
        body {
            font-family: Arial, sans-serif;
            background: #f0f0f0;
            margin: 0;
            padding: 20px;
        }
        .container {
            max-width: 1400px;
            margin: 0 auto;
            background: white;
            border-radius: 10px;
            padding: 30px;
            box-shadow: 0 4px 8px rgba(0,0,0,0.1);
        }
        h1 { color: #2c5530; text-align: center; margin-bottom: 30px; }
        .nav { text-align: center; margin-bottom: 30px; }
		.nav-row {
    		display: flex;
    		justify-content: center;
    		gap: 10px;
    		margin-bottom: 10px;
    		flex-wrap: wrap;
		}
		.nav-save {
    		display: flex;
    		justify-content: center;
    		margin-top: 15px;
		}
		.nav button {
    		color: white; border: none;
    		padding: 10px 20px; margin: 5px; border-radius: 5px; cursor: pointer;
    		font-size: 14px;
    		transition: all 0.3s ease;
		}
		.nav button:hover { 
    		transform: translateY(-2px);
    		box-shadow: 0 4px 8px rgba(0,0,0,0.2);
		}
		.nav button.active { 
    		box-shadow: 0 0 15px rgba(255,255,255,0.5);
    		font-weight: bold;
		}

		/* Couleurs des boutons */
		.nav-yellow { background: #f39c12; }
		.nav-yellow:hover { background: #e67e22; }
		.nav-purple { background: #9b59b6; }
		.nav-purple:hover { background: #8e44ad; }
		.nav-green { background: #27ae60; }
		.nav-green:hover { background: #229954; }
		.nav-blue { background: #3498db; }
		.nav-blue:hover { background: #2980b9; }
		.nav-save-btn { 
    		background: #e74c3c; 
    		font-weight: bold;
    		padding: 12px 30px;
    		font-size: 16px;
		}
		.nav-save-btn:hover { background: #c0392b; }
        .section { display: none; }
        .section.active { display: block; }
        .btn {
            background: #4a7c59; color: white; border: none;
            padding: 10px 15px; border-radius: 5px; cursor: pointer; margin: 5px;
        }
        .btn:hover { background: #2c5530; }
        .btn-secondary {
            background: #6c757d; color: white; border: none;
            padding: 10px 15px; border-radius: 5px; cursor: pointer; margin: 5px;
        }
        .btn-danger {
            background: #dc3545; color: white; border: none;
            padding: 8px 12px; border-radius: 5px; cursor: pointer; margin: 5px;
        }
        .card {
            background: #f9f9f9; padding: 20px; margin: 15px 0;
            border-radius: 8px; border-left: 4px solid #4a7c59;
        }
        .table {
            width: 100%; border-collapse: collapse; margin: 20px 0;
        }
        .table th, .table td {
            border: 1px solid #ddd; padding: 8px; text-align: left;
        }
        .table th { background: #4a7c59; color: white; }
        .table tr:nth-child(even) { background: #f2f2f2; }
        .alert-success {
            background: #d4edda; color: #155724; border: 1px solid #c3e6cb;
            padding: 15px; margin: 15px 0; border-radius: 5px;
        }
        .alert-danger {
            background: #f8d7da; color: #721c24; border: 1px solid #f5c6cb;
            padding: 15px; margin: 15px 0; border-radius: 5px;
        }
        .form-row {
            margin: 10px 0;
        }
        .form-row label {
            display: inline-block;
            width: 150px;
            font-weight: bold;
        }
        .form-row input, .form-row select {
            padding: 8px;
            border: 1px solid #ddd;
            border-radius: 4px;
        }
        .player-card {
            background: #fff;
            border: 2px solid #4a7c59;
            border-radius: 10px;
            padding: 20px;
            margin: 15px 0;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }
        .player-stats {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 15px;
            margin-top: 15px;
        }
        .stat-box {
            background: #f8f9fa;
            padding: 15px;
            border-radius: 8px;
            text-align: center;
            border: 1px solid #e9ecef;
        }
        .stat-value {
            font-size: 24px;
            font-weight: bold;
            color: #2c5530;
        }
        .stat-label {
            font-size: 14px;
            color: #666;
            margin-top: 5px;
        }
        .score-history {
            max-height: 400px;
            overflow-y: auto;
            margin-top: 20px;
        }
        .score-row {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 10px;
            border-bottom: 1px solid #eee;
        }
        .score-row:nth-child(even) {
            background: #f8f9fa;
        }
        .best-score {
            color: #28a745;
            font-weight: bold;
        }
        .worst-score {
            color: #dc3545;
            font-weight: bold;
        }
        .tournament-badge {
            padding: 3px 8px;
            border-radius: 12px;
            font-size: 12px;
            font-weight: bold;
        }
        .badge-diablo {
            background: #ff6b6b;
            color: white;
        }
        .badge-gpr {
            background: #4ecdc4;
            color: white;
        }
        .course-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(350px, 1fr));
            gap: 20px;
            margin-top: 20px;
        }
        .course-card {
            background: white;
            border: 1px solid #ddd;
            border-radius: 8px;
            padding: 15px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }
        .course-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 10px;
        }
        .course-name {
            font-weight: bold;
            color: #2c5530;
            font-size: 16px;
        }
        .tee-info {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 8px;
            margin: 5px 0;
            background: #f8f9fa;
            border-radius: 5px;
            border-left: 4px solid #4a7c59;
        }
        .tee-color {
            font-weight: bold;
            padding: 2px 8px;
            border-radius: 10px;
            color: white;
            font-size: 12px;
        }
        .tee-blanc { background: #666; }
        .tee-bleu { background: #007bff; }
        .tee-vert { background: #28a745; }
        .tee-jaune { background: #ffc107; color: black; }
        .tee-noir { background: #000; }
        .add-course-form {
            background: #f8f9fa;
            padding: 20px;
            border-radius: 8px;
            border: 2px dashed #4a7c59;
            margin-top: 20px;
        }
        .tee-form-row {
            display: grid;
            grid-template-columns: 1fr 1fr 1fr 1fr auto;
            gap: 10px;
            align-items: center;
            margin: 10px 0;
        }
        .handicap-info {
            background: #e7f3ff;
            padding: 10px;
            border-radius: 5px;
            margin: 10px 0;
            font-size: 14px;
        }
		/* REMPLACEZ VOS STYLES CALENDRIER PAR CEUX-CI */

		.calendar-grid {
    		display: grid !important;
    		grid-template-columns: repeat(7, 1fr) !important;
    		gap: 2px !important;
    		border: 2px solid #333 !important;
    		background: #f8f9fa !important;
    		margin: 20px 0 !important;
    		padding: 5px !important;
    		min-height: 420px !important;
    		width: 100% !important;
    		box-sizing: border-box !important;
		}

		.calendar-header {
    		background: #2c5530 !important;
    		color: white !important;
    		padding: 12px 8px !important;
    		text-align: center !important;
    		font-weight: bold !important;
    		font-size: 14px !important;
    		border: 1px solid white !important;
    		min-height: 40px !important;
    		display: flex !important;
    		align-items: center !important;
    		justify-content: center !important;
		}

		.calendar-day {
    		background: white !important;
    		border: 1px solid #ddd !important;
    		min-height: 80px !important;
    		padding: 8px !important;
    		cursor: pointer !important;
    		position: relative !important;
    		display: block !important;
    		box-sizing: border-box !important;
		}

		.calendar-day:hover {
    		background: #f0f8ff !important;
		}

		.calendar-day-number {
    		font-weight: bold !important;
    		font-size: 16px !important;
    		color: #333 !important;
    		margin-bottom: 5px !important;
    		line-height: 1 !important;
		}

		.today {
    		background: #e8f5e8 !important;
    		border: 2px solid #4a7c59 !important;
		}

		.other-month {
    		background: #f9f9f9 !important;
    		color: #999 !important;
		}

		.other-month .calendar-day-number {
    		color: #999 !important;
		}

		.calendar-event {
    		background: #4a7c59 !important;
    		color: white !important;
    		padding: 2px 5px !important;
    		margin: 2px 0 !important;
    		border-radius: 3px !important;
    		font-size: 11px !important;
    		cursor: pointer !important;
    		overflow: hidden !important;
    		text-overflow: ellipsis !important;
    		white-space: nowrap !important;
		}

		.calendar-event:hover {
    		background: #2c5530 !important;
		}

		/* S'assurer que le conteneur parent ne limite pas la taille */
		#calendarView {
    		display: block !important;
    		width: 100% !important;
    		min-height: 500px !important;
    		overflow: visible !important;
		}

		#calendar {
    		display: none;
    		width: 100% !important;
		}

		#calendar.active {
    		display: block !important;
		}

        .nav-controls {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 20px;
            padding: 15px;
            background: #f8f9fa;
            border-radius: 8px;
        }

        .month-nav {
            display: flex;
            align-items: center;
            gap: 20px;
        }

        .month-nav button {
            background: #4a7c59;
            color: white;
            border: none;
            padding: 8px 15px;
            border-radius: 5px;
            cursor: pointer;
            font-size: 16px;
        }

        .month-nav button:hover {
            background: #2c5530;
        }

        .month-title {
            font-size: 24px;
            font-weight: bold;
            color: #2c5530;
            min-width: 200px;
            text-align: center;
        }

        .view-buttons {
            display: flex;
            gap: 10px;
        }

        .btn {
            background: #4a7c59;
            color: white;
            border: none;
            padding: 8px 15px;
            border-radius: 5px;
            cursor: pointer;
        }

        .btn:hover {
            background: #2c5530;
        }

        .btn-secondary {
            background: #6c757d;
        }

        .btn-secondary:hover {
            background: #5a6268;
        }

        .card {
            background: white;
            padding: 20px;
            margin: 15px 0;
            border-radius: 8px;
            border: 1px solid #ddd;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }

        .today {
            background: #e8f5e8 !important;
            border: 2px solid #4a7c59;
        }

        .other-month {
            background: #f9f9f9;
            color: #999;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>🏌️ GOLF DIABLO et GPR - Scores Détaillés 🏌️</h1>
        
        <div class="nav">
            <!-- Première ligne -->
            <div class="nav-row">
                <button onclick="showAddRound()" class="nav-yellow">➕ Nouvelle Partie</button>
                <button onclick="showDiablo()" class="nav-purple">🏆 Coupe Diablo</button>
                <button onclick="showOverview()" class="active nav-green">Vue d'ensemble</button>
                <button onclick="showPlayerScores()" class="nav-green">Scores par Joueur</button>
                <button onclick="showCourses()" class="nav-blue">🏌️ Terrains</button>
            </div>
            <!-- Deuxième ligne -->
            <div class="nav-row">
                <button onclick="showProgress()" class="nav-yellow">📊 Progression</button>
                <button onclick="showGPR()" class="nav-purple">🎯 Coupe GPR</button>
                <button onclick="showHandicapEvolution()" class="nav-green">📈 Évolution Handicaps</button>
                <button onclick="showDetails()" class="nav-green">📋 Détails</button>
                <button onclick="showPlayerManagement()" class="nav-blue">👥 Joueurs</button>
            </div>
            <!-- Bouton de sauvegarde centré -->
            <div class="nav-save">
                <button onclick="saveAllToFirebase()" class="nav-save-btn">💾 Sauvegarder</button>
				<button onclick="showCalendar()" class="nav-blue">📅 Calendrier</button>
            </div>
        </div>

        <!-- Section Vue d'ensemble -->
        <div id="overview" class="section active">
            <div class="card">
                <h2>📊 Statistiques Générales</h2>
                <div id="overviewStats"></div>
            </div>
        </div>

        <!-- Section Scores par Joueur -->
        <div id="playerScores" class="section">
            <div class="card">
                <h2>👥 Sélectionner un Joueur</h2>
                <select id="playerSelect" style="width: 300px; padding: 10px;" onchange="showPlayerDetail()">
                    <option value="">-- Choisir un joueur --</option>
                </select>
            </div>
            <div id="playerDetail"></div>
        </div>

        <!-- Section Terrains -->
        <div id="courses" class="section">
            <div class="card">
                <h2>🏌️ Gestion des Terrains</h2>
                <p>Base de données complète avec ratings et slopes pour le calcul des handicaps</p>
                <div class="handicap-info">
                    <strong>ℹ️ Calcul des Handicaps:</strong> Les handicaps de parcours sont calculés avec la formule officielle complète : 
                    <em>(Handicap Index × Slope Rating) ÷ 113 + (Course Rating - Par)</em>. 
                    <br>Rating = difficulté pour un scratch, Slope = difficulté relative, Par = nombre de coups de référence.
                </div>
                <button class="btn" onclick="toggleAddCourseForm()">➕ Ajouter un Terrain</button>
                <button class="btn-secondary" onclick="exportCourses()">📁 Exporter Terrains</button>
            </div>
            
            <div id="addCourseForm" class="add-course-form" style="display: none;">
                <h3>➕ Ajouter un Nouveau Terrain</h3>
                <div class="form-row">
                    <label>Nom du terrain:</label>
                    <input type="text" id="newCourseName" placeholder="Ex: Club de Golf Exemple" style="width: 300px;">
                </div>
                
                <h4>Départs disponibles:</h4>
                <div id="teeInputs">
                    <div class="tee-form-row">
                        <select>
                            <option value="blanc">Blanc</option>
                            <option value="bleu">Bleu</option>
                            <option value="vert">Vert</option>
                            <option value="jaune">Jaune</option>
                            <option value="noir">Noir</option>
                        </select>
                        <input type="number" placeholder="Rating (ex: 69.5)" step="0.1" min="60" max="80">
                        <input type="number" placeholder="Slope (ex: 123)" min="85" max="155">
                        <button type="button" class="btn-danger" onclick="removeTeeInput(this)">❌</button>
                    </div>
                </div>
                
                <button class="btn-secondary" onclick="addTeeInput()">➕ Ajouter un Départ</button>
                <br><br>
                <button class="btn" onclick="saveCourse()">💾 Sauvegarder le Terrain</button>
                <button class="btn-secondary" onclick="cancelAddCourse()">❌ Annuler</button>
            </div>
            
            <div id="coursesList"></div>
        </div>

        <!-- Section Diablo -->
        <div id="diablo" class="section">
            <h2>🏆 Coupe Diablo </h2>
            <div class="card">
                <label><strong>Sélectionner l'année:</strong></label>
                <select id="diabloYearSelect" style="width: 150px; padding: 8px; margin: 0 10px;" onchange="loadDiablo()">
                    <option value="">-- Toutes les années --</option>
                </select>
                <span id="diabloStatus" style="margin-left: 20px; padding: 5px 10px; border-radius: 15px;"></span>
            </div>
            <div id="diabloContent"></div>
        </div>

        <!-- Section GPR -->
        <div id="gpr" class="section">
            <h2>🎯 Coupe GPR (Mai à Juillet)</h2>
            <div class="card">
                <label><strong>Sélectionner l'année:</strong></label>
                <select id="gprYearSelect" style="width: 150px; padding: 8px; margin: 0 10px;" onchange="loadGPR()">
                    <option value="">-- Toutes les années --</option>
                </select>
                <span id="gprStatus" style="margin-left: 20px; padding: 5px 10px; border-radius: 15px;"></span>
            </div>
            <div id="gprContent"></div>
        </div>

        <!-- Section Progression -->
        <div id="progress" class="section">
            <h2>📈 Progression des Coupes En Cours</h2>
            <div id="progressContent"></div>
        </div>

        <!-- Section Détails -->
        <div id="details" class="section">
            <h2>📊 Détails par Partie</h2>
            <div class="card">
                <select id="roundSelect" style="width: 100%; padding: 8px;" onchange="showRoundDetail()">
                    <button class="btn" onclick="generateTestRound()" style="margin-left: 10px;">🎲 Générer Partie Test</button>
					<option value="">-- Sélectionner une partie --</option>
                </select>
            </div>
            <div id="detailsContent"></div>
        </div>
	
	<!-- Section Évolution Handicaps -->
	<div id="handicapEvolution" class="section">
    	    <div class="card">
        	<h2>📈 Évolution des Handicaps</h2>
        	<p>Suivez la progression des handicaps de chaque joueur au fil des parties</p>
        
        	<div style="margin: 20px 0;">
            	    <label><strong>Sélectionner les joueurs à comparer:</strong></label>
            	    <div id="playerCheckboxes" style="display: grid; grid-template-columns: repeat(auto-fit, minmax(200px, 1fr)); gap: 10px; margin: 15px 0;"></div>
            	    <button class="btn" onclick="updateHandicapChart()">🔄 Mettre à jour le graphique</button>
            	    <button class="btn-secondary" onclick="selectAllPlayers()">✅ Tous</button>
            	    <button class="btn-secondary" onclick="clearAllPlayers()">❌ Aucun</button>
            	    <button class="btn-secondary" onclick="exportHandicapData()">📊 Exporter Données</button>
        	</div>
        
        	<div style="background: #f8f9fa; padding: 15px; border-radius: 8px; margin: 15px 0;">
            	    <strong>Légende:</strong>
            	    <span style="color: #28a745;">🟢 Amélioration</span> |
            	    <span style="color: #dc3545;">🔴 Dégradation</span> |
            	    <span style="color: #6c757d;">⚪ Stable</span>
        	</div>
    	    </div>
    
    	    <div id="handicapChart" class="card">
        	<canvas id="handicapCanvas" width="1000" height="500" style="max-width: 100%; border: 1px solid #ddd; border-radius: 8px;"></canvas>
    	    </div>
    
    	    <div id="handicapStats" class="card"></div>
	</div>

	<!-- Section Gestion des Joueurs -->
	<div id="playerManagement" class="section">
    	    <div class="card">
        	<h2>👥 Gestion des Joueurs</h2>
        	<p>Ajouter, modifier et gérer les informations des joueurs</p>
        
        	<div style="margin: 20px 0;">
            	    <button class="btn" onclick="showAddPlayerForm()">➕ Ajouter un Joueur</button>
            	    <button class="btn-secondary" onclick="exportPlayersData()">📁 Exporter Liste</button>
            	    <button class="btn-secondary" onclick="importPlayersData()">📥 Importer Liste</button>
            	    <input type="file" id="importFile" accept=".json,.csv" style="display: none;" onchange="handleFileImport(event)">
        	</div>
        
        	<div id="addPlayerForm" class="add-course-form" style="display: none;">
            	    <h3>➕ Ajouter un Nouveau Joueur</h3>
            	    <div class="form-row">
                	<label>Prénom:</label>
                	<input type="text" id="newPlayerFirstName" placeholder="Ex: Jean" style="width: 200px;">
            	    </div>
            	    <div class="form-row">
                	<label>Nom:</label>
                	<input type="text" id="newPlayerLastName" placeholder="Ex: Dupont" style="width: 200px;">
            	    </div>
            	    <div class="form-row">
                	<label>Téléphone:</label>
                	<input type="tel" id="newPlayerPhone" placeholder="Ex: 514-555-1234" style="width: 200px;">
            	    </div>
            	    <div class="form-row">
                	<label>Courriel:</label>
                	<input type="email" id="newPlayerEmail" placeholder="Ex: jean.dupont@example.com" style="width: 300px;">
            	    </div>
            	    <div class="form-row">
                	<label>Handicap Initial:</label>
                	<input type="number" id="newPlayerHandicap" placeholder="Ex: 15.5" step="0.1" min="0" max="36.4" style="width: 100px;">
            	    </div>
            	    <div class="form-row">
                	<label>Date d'adhésion:</label>
                	<input type="date" id="newPlayerDateJoined" style="width: 200px;">
            	    </div>
            	    <br>
            	    <button class="btn" onclick="saveNewPlayer()">💾 Sauvegarder</button>
            	    <button class="btn-secondary" onclick="cancelAddPlayer()">❌ Annuler</button>
        	</div>
    	    </div>
    
    	    <div id="playersGrid" class="course-grid"></div>
	</div>

	<!-- Section Ajouter une Partie -->
	<div id="addRound" class="section">
    	    <div class="card">
        	<h2>➕ Ajouter une Nouvelle Partie</h2>
        	<p>Enregistrer les scores d'une nouvelle partie de golf</p>
        
        	<!-- Informations de base de la partie -->
        	<div class="card" style="background: #f8f9fa;">
            	    <h3>📅 Informations de la Partie</h3>
            
            	    <div class="form-row">
                	<label>Date de la partie:</label>
                	<input type="date" id="newRoundDate" style="width: 200px;">
            	    </div>
            
            	    <div class="form-row">
                	<label>Terrain:</label>
                	<select id="newRoundCourse" style="width: 300px;" onchange="updateAvailableTees()">
                    	    <option value="">-- Sélectionner un terrain --</option>
                	</select>
            	    </div>
            
            	    <div class="form-row">
                	<label>Départ par défaut:</label>
                	<select id="newRoundDefaultTee" style="width: 150px;">
                    	    <option value="">-- Choisir --</option>
                	</select>
                	<small style="margin-left: 10px; color: #666;">Les joueurs peuvent avoir des départs individuels</small>
            	    </div>
            
            	    <div class="form-row">
    					<label>Type de partie:</label>
    					<select id="newRoundType" style="width: 200px;" onchange="updateGPROptions()">
        					<option value="gpr">🎯 GPR (Mai-Juillet)</option>
        					<option value="diablo">🏆 Diablo (Septembre)</option>
        					<option value="amicale">⛳ Partie Amicale</option>
    					</select>
					</div>

					<!-- Nouvelles options GPR -->
					<div id="gprOptions" style="display: block; margin-top: 15px; padding: 15px; background: #e7f3ff; border-radius: 8px;">
    					<h4 style="margin-top: 0; color: #2c5530;">⚙️ Configuration GPR</h4>
    
    					<div class="form-row">
        					<label>Phase GPR:</label>
        					<select id="gprPhase" style="width: 200px;" onchange="updateFinaleOptions()">
            					<option value="exhibition">📊 Partie d'Exhibition</option>
            					<option value="finale">🏆 Partie de Finale</option>
        						</select>
    						</div>
    
    					<div id="finaleOptions" style="display: none; margin-top: 10px;">
        					<div class="form-row">
            					<label>Format finale:</label>
            					<select id="finaleFormat" style="width: 200px;">
                					<option value="2days">📅 Finale 2 jours (points répartis)</option>
                					<option value="1day">⚡ Finale 1 jour (tous les points)</option>
            					</select>
        					</div>
    					</div>
    
    					<div style="margin-top: 15px; padding: 10px; background: #fff3cd; border-radius: 5px;">
        					<strong>ℹ️ Rappel :</strong> Si votre handicap est de 12 et moins, vous partez des bleus
    					</div>
					</div>
        	</div>
			<!-- Sélection des joueurs et scores -->
        	<div class="card">
            	    <h3>👥 Joueurs et Scores</h3>
            	    <p>Sélectionnez les joueurs présents et saisissez leurs scores</p>
            
            	    <div style="margin: 15px 0;">
                	<button class="btn-secondary" onclick="selectAllPlayersForRound()">✅ Tous les joueurs</button>
                	<button class="btn-secondary" onclick="clearAllPlayersForRound()">❌ Aucun joueur</button>
                	<button class="btn-secondary" onclick="selectFrequentPlayers()">⭐ Joueurs fréquents</button>
            	    </div>
            
            	    <div id="playersScoreGrid" style="display: grid; grid-template-columns: repeat(auto-fit, minmax(350px, 1fr)); gap: 15px; margin-top: 20px;"></div>
        	</div>
        
        	<!-- Boutons d'action -->
        	<div class="card" style="text-align: center;">
            	    <button class="btn" onclick="saveNewRound()">💾 Enregistrer la Partie</button>
            	    <button class="btn-secondary" onclick="previewNewRound()">👁️ Aperçu</button>
            	    <button class="btn-secondary" onclick="resetNewRoundForm()">🔄 Réinitialiser</button>
        	</div>
        
        	<!-- Aperçu de la partie -->
        	<div id="newRoundPreview" class="card" style="display: none;">
            	    <h3>👁️ Aperçu de la Partie</h3>
            	    <div id="previewContent"></div>
        	</div>
    	    
	<!-- Section Calendrier - À ajouter après la section addRound dans votre HTML -->
	<div id="calendar" class="section">
    	<div class="card">
    		<h2>📅 Calendrier des Parties</h2>
    		<p>Planifiez vos parties de golf et consultez les prochains événements</p>
        
    		<!-- Navigation et contrôles -->
    		<div style="display: flex; justify-content: space-between; align-items: center; margin: 20px 0; padding: 15px; background: #f8f9fa; border-radius: 8px;">
       			<div style="display: flex; gap: 10px;">
           			<button class="btn" onclick="showAddEvent()">➕ Planifier une Partie</button>
           			<button class="btn-secondary" onclick="showListView()">📋 Vue Liste</button>
           			<button class="btn-secondary" onclick="showMonthView()">📅 Vue Calendrier</button>
       			</div>
            
       			<!-- Navigation mensuelle -->
       			<div style="display: flex; align-items: center; gap: 20px;">
           			<button class="btn-secondary" onclick="changeMonth(-1)">◀ Précédent</button>
           			<div id="monthTitle" style="font-size: 20px; font-weight: bold; color: #2c5530; min-width: 180px; text-align: center;">
               			Décembre 2024
           			</div>
           			<button class="btn-secondary" onclick="changeMonth(1)">Suivant ▶</button>
       			</div>
    		</div>

    		<!-- Formulaire d'ajout d'événement -->
    		<div id="addEventForm" class="add-course-form" style="display: none;">
       			<h3>➕ Planifier une Nouvelle Partie</h3>
            
       			<div style="display: grid; grid-template-columns: 1fr 1fr; gap: 20px;">
           			<div>
               			<div class="form-row">
                   			<label>Date de la partie:</label>
                   			<input type="date" id="eventDate" style="width: 100%; padding: 8px;">
               			</div>
                    
               			<div class="form-row">
                   			<label>Terrain:</label>
                   			<select id="eventCourse" style="width: 100%; padding: 8px;">
                       			<option value="">-- Sélectionner un terrain --</option>
                   			</select>
               			</div>
                    
               			<div class="form-row">
                   			<label>Type de partie:</label>
                   			<select id="eventType" style="width: 100%; padding: 8px;">
                       			<option value="amicale">⛳ Partie Amicale</option>
                       			<option value="gpr">🎯 Coupe GPR</option>
                       			<option value="diablo">🏆 Coupe Diablo</option>
                       			<option value="felton">🏆 Coupe FelTon</option>
                       			<option value="doubled">🎯 Double D's Cup</option>
                   			</select>
               			</div>
                    
               			<div class="form-row">
                   			<label>Organisateur:</label>
                   			<select id="eventOrganizer" style="width: 100%; padding: 8px;">
                       			<option value="">-- Sélectionner --</option>
                   			</select>
               			</div>
           			</div>
                
           			<div>
               			<div class="form-row">
                   			<label>Heures de départ:</label>
                   			<div id="teeTimesList" style="max-height: 200px; overflow-y: auto; border: 1px solid #ddd; padding: 10px; border-radius: 5px; background: white;">
                       			<!-- Les heures de départ seront ajoutées ici -->
                   			</div>
                   			<button class="btn-secondary" onclick="addTeeTime()" style="margin-top: 10px;">➕ Ajouter une heure</button>
               			</div>
                    
               			<div class="form-row">
                   			<label>Commentaires/Notes:</label>
                   			<textarea id="eventComments" rows="4" style="width: 100%; padding: 8px;" 
                           			placeholder="Ex: Apportez vos balles, terrain difficile, souper après la partie..."></textarea>
               			</div>
           			</div>
       			</div>
            
       			<div style="text-align: center; margin-top: 20px;">
           			<button class="btn" onclick="saveEvent()">💾 Enregistrer</button>
           			<button class="btn-secondary" onclick="cancelAddEvent()">❌ Annuler</button>
           			<button class="btn" onclick="saveAndNotify()" style="background: #e74c3c;">📢 Enregistrer et Notifier</button>
       			</div>
    		</div>
    	</div>
    
    	<!-- Vue du calendrier -->
    	<div id="calendarView" class="card">
    		<!-- Vide - sera rempli par JavaScript -->
		</div>
    
    	<!-- Vue liste -->
    	<div id="listView" class="card" style="display: none;">
        	<div style="text-align: center; padding: 50px; color: #666;">
        		<h3>📋 Vue Liste</h3>
        		<p>La liste des événements va s'afficher ici</p>
        	</div>
    	</div>
	</div>

    <script>
		// Configuration Firebase
		const firebaseConfig = {
    		apiKey: "AIzaSyCHh6Fb-m18O-_1Ei6sTEdfnJMyNrSl590",
    		authDomain: "golf-scores-app-bba13.firebaseapp.com",
    		databaseURL: "https://golf-scores-app-bba13-default-rtdb.firebaseio.com",
    		projectId: "golf-scores-app-bba13",
    		storageBucket: "golf-scores-app-bba13.firebasestorage.app",
    		messagingSenderId: "170312505084",
    		appId: "1:170312505084:web:074ae5e6d9d74c70efa979"
		};

		// Initialiser Firebase
		firebase.initializeApp(firebaseConfig);
		const database = firebase.database();

		// État de chargement
		var isDataLoaded = false;
		var loadingElement = null;

		// Fonction pour afficher le statut de chargement
		function showLoading(message) {
    		if (!loadingElement) {
        		loadingElement = document.createElement('div');
        		loadingElement.style.cssText = 'position: fixed; top: 50%; left: 50%; transform: translate(-50%, -50%); background: rgba(0,0,0,0.8); color: white; padding: 20px; border-radius: 10px; z-index: 9999;';
        		document.body.appendChild(loadingElement);
    		}
    		loadingElement.innerHTML = '<div style="text-align: center;"><div style="margin-bottom: 10px;">🔄</div>' + message + '</div>';
    		loadingElement.style.display = 'block';
		}

		function hideLoading() {
    		if (loadingElement) {
        		loadingElement.style.display = 'none';
    		}
		}

        // Base de données des terrains avec ratings, slopes et pars
        var coursesDatabase = {
            "Parcours de l'île": [
                {tee: "blanc", rating: 68.6, slope: 122, par: 70},
                {tee: "bleu", rating: 70.9, slope: 127, par: 70}
            ],
            "Parcours de l'Irlande": [
                {tee: "blanc", rating: 69.4, slope: 126, par: 71},
                {tee: "bleu", rating: 72.2, slope: 131, par: 71}
            ],
            "Parcours Atlantide": [
                {tee: "blanc", rating: 68.6, slope: 126, par: 72},
                {tee: "bleu", rating: 70.2, slope: 132, par: 72}
            ],
            "Parcours Don Quichotte": [
                {tee: "blanc", rating: 65.9, slope: 113, par: 71},
                {tee: "bleu", rating: 68.4, slope: 117, par: 71}
            ],
            "Triangle D'Or": [
                {tee: "blanc", rating: 69.8, slope: 123, par: 72},
                {tee: "bleu", rating: 70.8, slope: 127, par: 72}
            ],
            "Hemmingford Parcours Frontière": [
                {tee: "blanc", rating: 70.3, slope: 123, par: 71},
                {tee: "bleu", rating: 71.1, slope: 125, par: 71}
            ],
            "Vallée des Forts": [
                {tee: "blanc", rating: 70.2, slope: 127, par: 72},
                {tee: "bleu", rating: 71.9, slope: 135, par: 72}
            ],
            "St-Zotique": [
                {tee: "blanc", rating: 68, slope: 114, par: 72},
                {tee: "bleu", rating: 70.1, slope: 118, par: 72}
            ],
            "Parcours Le Présidentiel": [
                {tee: "blanc", rating: 69.7, slope: 118, par: 72},
                {tee: "bleu", rating: 71.5, slope: 123, par: 72}
            ],
            "Parcours Le Doral": [
                {tee: "blanc", rating: 70, slope: 124, par: 72},
                {tee: "bleu", rating: 71.7, slope: 128, par: 72}
            ],
            "Parcours Woodlands": [
                {tee: "blanc", rating: 68.7, slope: 116, par: 72},
                {tee: "bleu", rating: 70.1, slope: 119, par: 72}
            ],
            "Parcours Bellevue": [
                {tee: "blanc", rating: 69, slope: 115, par: 72},
                {tee: "bleu", rating: 70.3, slope: 118, par: 72}
            ],
            "Rivière-Rouge": [
                {tee: "blanc", rating: 68.8, slope: 123, par: 71},
                {tee: "bleu", rating: 70.5, slope: 124, par: 71}
            ],
            "Les Légendes": [
                {tee: "blanc", rating: 70.8, slope: 118, par: 72},
                {tee: "bleu", rating: 72.3, slope: 126, par: 72}
            ],
            "La Seigneurie": [
                {tee: "blanc", rating: 68.5, slope: 123, par: 70},
                {tee: "bleu", rating: 69.5, slope: 126, par: 70}
            ],
            "Napierville": [
                {tee: "blanc", rating: 68.2, slope: 125, par: 72},
                {tee: "bleu", rating: 70.7, slope: 129, par: 72}
            ],
            "St-Polycarpe": [
                {tee: "blanc", rating: 66.8, slope: 118, par: 72},
                {tee: "bleu", rating: 71, slope: 125, par: 72}
            ],
            "Rive-Sud": [
                {tee: "blanc", rating: 71.2, slope: 124, par: 72},
                {tee: "bleu", rating: 72.4, slope: 127, par: 72}
            ],
            "Rivière-Beaudette": [
                {tee: "blanc", rating: 69.2, slope: 117, par: 72},
                {tee: "bleu", rating: 70.6, slope: 120, par: 72}
            ],
            "Vaudreuil": [
                {tee: "blanc", rating: 66.5, slope: 108, par: 70},
                {tee: "bleu", rating: 68.2, slope: 112, par: 70}
            ],
            "Brocart": [
                {tee: "blanc", rating: 68, slope: 115, par: 72},
                {tee: "vert", rating: 69.4, slope: 118, par: 72},
                {tee: "jaune", rating: 69.4, slope: 118, par: 72}
            ],
            "Faon": [
                {tee: "vert", rating: 70.7, slope: 122, par: 71},
                {tee: "jaune", rating: 69.2, slope: 123, par: 71}
            ],
            "Beloeil": [
                {tee: "blanc", rating: 67.2, slope: 123, par: 71},
                {tee: "bleu", rating: 70, slope: 132, par: 71}
            ],
            "GolfdesÎles": [
                {tee: "blanc", rating: 66.5, slope: 110, par: 70},
                {tee: "bleu", rating: 68.5, slope: 115, par: 70}
            ],
            "St-Césaire": [
                {tee: "blanc", rating: 70, slope: 122, par: 72},
                {tee: "bleu", rating: 70, slope: 122, par: 72}
            ],
            "Golf Cowansville": [
                {tee: "blanc", rating: 69.6, slope: 118, par: 72},
                {tee: "bleu", rating: 71, slope: 123, par: 72}
            ],
            "Château Bromont": [
                {tee: "blanc", rating: 69.3, slope: 123, par: 72},
                {tee: "bleu", rating: 69.8, slope: 116, par: 72}
            ],
            "Golf Coaticook": [
                {tee: "blanc", rating: 66.4, slope: 114, par: 71},
                {tee: "bleu", rating: 68, slope: 119, par: 71}
            ],
            "Golf Farnham": [
                {tee: "blanc", rating: 67.8, slope: 121, par: 71},
                {tee: "bleu", rating: 69.4, slope: 124, par: 71}
            ],
            "Milby": [
                {tee: "blanc", rating: 69.5, slope: 123, par: 73},
                {tee: "bleu", rating: 71.1, slope: 131, par: 73}
            ],
            "Manoir des Sables": [
                {tee: "blanc", rating: 69, slope: 118, par: 71},
                {tee: "bleu", rating: 69, slope: 123, par: 71}
            ],
            "Mont Orford": [
                {tee: "blanc", rating: 69, slope: 118, par: 72},
                {tee: "bleu", rating: 69, slope: 126, par: 72}
            ],
            "Royal Bromont": [
                {tee: "blanc", rating: 67, slope: 114, par: 72},
                {tee: "bleu", rating: 69.3, slope: 120, par: 72}
            ],
            "Parcours du Vieux Village": [
                {tee: "blanc", rating: 68.2, slope: 114, par: 72},
                {tee: "bleu", rating: 70.3, slope: 124, par: 72}
            ],
            "Royal Laurentien": [
                {tee: "blanc", rating: 66.2, slope: 115, par: 71},
                {tee: "bleu", rating: 68.6, slope: 121, par: 71}
            ],
            "Le Diable": [
                {tee: "blanc", rating: 69.9, slope: 126, par: 70},
                {tee: "bleu", rating: 72, slope: 131, par: 70}
            ],
            "Le Géant": [
                {tee: "vert", rating: 68, slope: 123, par: 72},
                {tee: "noir", rating: 70.4, slope: 125, par: 72}
            ],
            "Arundel": [
                {tee: "blanc", rating: 69.7, slope: 126, par: 72},
                {tee: "bleu", rating: 70.7, slope: 128, par: 72}
            ],
            "La Belle": [
                {tee: "blanc", rating: 68, slope: 121, par: 73},
                {tee: "bleu", rating: 69, slope: 124, par: 73}
            ],
            "Le Maître": [
                {tee: "blanc", rating: 68.7, slope: 121, par: 72},
                {tee: "bleu", rating: 70.2, slope: 125, par: 72}
            ],
            "La Bête": [
                {tee: "blanc", rating: 68.7, slope: 124, par: 72},
                {tee: "bleu", rating: 71.4, slope: 128, par: 72}
            ],
            "Lorraine": [
                {tee: "blanc", rating: 69.5, slope: 123, par: 72},
                {tee: "bleu", rating: 70.4, slope: 124, par: 72}
            ],
            "St-Jean limité": [
                {tee: "blanc", rating: 69.3, slope: 120, par: 72},
                {tee: "bleu", rating: 71.4, slope: 123, par: 72}
            ]
        };

        // 1. MODIFIER LE TABLEAU PLAYERS pour ajouter la propriété 'name' (REMPLACER VOTRE TABLEAU ACTUEL)
		var rounds = [];
		
		var players = [];

        // Données des parties avec départs spécifiques
        var dates = [
            '2023-06-03', '2023-06-10', '2023-07-01', '2023-07-02', '2023-09-01', '2023-09-02', '2023-09-03',
            '2024-05-04', '2024-05-18', '2024-05-25', '2024-06-08', '2024-06-15', '2024-06-29', '2024-06-30',
            '2024-09-06', '2024-09-07', '2024-09-08', '2025-05-03', '2025-05-17', '2025-06-07', '2025-06-14', '2025-06-21'
        ];

        var courses = [
            'Rivière-Rouge', 'Hemmingford Parcours Frontière', 'Parcours Don Quichotte', 'Parcours Don Quichotte',
            'Le Diable', 'Le Géant', 'Le Géant', 'Vaudreuil', 'Hemmingford Parcours Frontière', 'Vallée des Forts',
            'Parcours Bellevue', 'Rivière-Rouge', 'Parcours Don Quichotte', 'Parcours Don Quichotte',
            'Manoir des Sables', 'Manoir des Sables', 'Manoir des Sables', 'Vaudreuil', 'Hemmingford Parcours Frontière',
            'Lorraine', 'Parcours Bellevue', 'St-Jean limité'
        ];

        // Départs utilisés pour chaque partie (Antonio = bleu pour certaines parties, sinon blanc pour tous)
        var teeUsed = [
            'blanc', 'blanc', 'blanc', 'bleu', 'blanc', 'blanc', 'blanc', 'bleu', 'bleu', 'bleu', 'bleu', 'bleu', 'bleu', 'bleu',
            'blanc', 'blanc', 'bleu', 'bleu', 'bleu', 'bleu', 'blanc', 'bleu'
        ];

        // Fonction pour calculer le handicap de parcours avec la formule complète
        function calculateCourseHandicap(playerHandicapIndex, courseName, teeColor) {
            if (!coursesDatabase[courseName]) {
                console.warn('Terrain non trouvé:', courseName);
                return playerHandicapIndex; // Fallback vers handicap fixe
            }
            
            var courseData = coursesDatabase[courseName];
            var teeData = courseData.find(t => t.tee === teeColor);
            
            if (!teeData) {
                // Si le départ spécifique n'existe pas, prendre le premier disponible
                teeData = courseData[0];
                console.warn('Départ', teeColor, 'non trouvé pour', courseName, ', utilisation de', teeData.tee);
            }
            
            // Formule complète: (Handicap Index × Slope Rating) ÷ 113 + (Course Rating - Par)
            var slopeAdjustment = (playerHandicapIndex * teeData.slope) / 113;
            var ratingAdjustment = teeData.rating - teeData.par;
            var courseHandicap = slopeAdjustment + ratingAdjustment;
            
            return Math.round(courseHandicap * 10) / 10; // Arrondir à 1 décimale
        }

	// Cache pour éviter les recalculs répétés
	var handicapCache = {};

    // Fonctions Firebase
    function savePlayersToFirebase() {
        return database.ref('players').set(players);
    }

    function saveScoresToFirebase() {
        return database.ref('allScores').set(allScores);
    }

    function saveCoursesToFirebase() {
        return database.ref('coursesDatabase').set(coursesDatabase);
    }

    function saveDatesToFirebase() {
        return database.ref('gameData').set({
            dates: dates,
            courses: courses,
            teeUsed: teeUsed
	    });
    }

	function saveRoundsToFirebase() {
    	// Nettoyer les propriétés undefined avant de sauvegarder
    	var cleanedRounds = rounds.map(function(round) {
        	var cleanRound = {
            	id: round.id,
            	date: round.date,
            	course: round.course,
            	tee: round.tee,
            	type: round.type,
            	year: round.year,
            	month: round.month
        	};
        
        	// Ajouter les propriétés GPR seulement si elles existent
        	if (round.gprPhase) {
            	cleanRound.gprPhase = round.gprPhase;
        	}
        	if (round.gprFinaleFormat) {
            	cleanRound.gprFinaleFormat = round.gprFinaleFormat;
        	}
        
        	return cleanRound;
   		});
    
    	return database.ref('rounds').set(cleanedRounds);
	}

    function loadDataFromFirebase() {
    	showLoading('Chargement des données...');

    	return Promise.all([
        	database.ref('players').once('value'),
        	database.ref('allScores').once('value'),
        	database.ref('coursesDatabase').once('value'),
        	database.ref('gameData').once('value')
    	]).then(function(snapshots) {
        	// Charger les joueurs
        	if (snapshots[0].exists()) {
            	players = snapshots[0].val();
        	}
    
        	// Charger les scores
        	if (snapshots[1].exists()) {
            	allScores = snapshots[1].val();
        	}
    
        	// Charger les terrains
        	if (snapshots[2].exists()) {
            	coursesDatabase = snapshots[2].val();
        	}
    
        	// Charger les données de parties
        	if (snapshots[3].exists()) {
            	var gameData = snapshots[3].val();
            	if (gameData.dates) dates = gameData.dates;
            	if (gameData.courses) courses = gameData.courses;
            	if (gameData.teeUsed) teeUsed = gameData.teeUsed;
        	}
        
        	// Charger les rounds
        	return database.ref('rounds').once('value');
        
    		}).then(function(snapshot) {
        		if (snapshot.exists()) {
            		rounds = snapshot.val();
            		console.log('Rounds chargés:', rounds.length);
            
            		// Vérifier les métadonnées GPR
            		var gprRounds = rounds.filter(r => r.type === 'gpr');
            		console.log('Parties GPR trouvées:', gprRounds.length);
            		var finaleRounds = gprRounds.filter(r => r.gprPhase === 'finale');
            		console.log('Parties finale trouvées:', finaleRounds.length);
        		}

        		console.log('Données chargées:', players.length, 'joueurs,', dates.length, 'parties');
        		isDataLoaded = true;
        		hideLoading();
    
        		// Initialiser l'interface après chargement
        		fixAllPlayerNames();
        		initializeData();
        		loadOverview();
        
    	}).catch(function(error) {
        	console.error('Erreur de chargement:', error);
        	hideLoading();
        	alert('Erreur de chargement des données: ' + error.message);
    	});
	}

	// Fonction pour calculer le différentiel de score
	function calculateScoreDifferentialReal(grossScore, courseName, teeColor) {
    	    if (grossScore <= 0) {
    			return null;
			}
			if (!coursesDatabase[courseName]) {
        	console.warn('Terrain non trouvé:', courseName);
        	return null;
    	    }
    
    	    var courseData = coursesDatabase[courseName];
    	    var teeData = courseData.find(t => t.tee === teeColor);
    
    	    if (!teeData) {
        	teeData = courseData[0];
        	console.warn('Départ', teeColor, 'non trouvé pour', courseName, ', utilisation de', teeData.tee);
    	    }
    
    	    // Score Differential = (Gross Score - Course Rating) × 113 / Slope Rating
    	    var differential = (grossScore - teeData.rating) * 113 / teeData.slope;
    	    return Math.round(differential * 10) / 10;
	}

	// 3. FONCTION POUR CALCULER LE NOUVEAU HANDICAP BASÉ SUR LES DIFFÉRENTIELS
	function calculateNewHandicapFromDifferentials(differentials, initialHandicap) {
    	    if (differentials.length < 5) {
        	// Pas assez de scores, garder le handicap initial
        	return initialHandicap;
    	    }
    
    	    // Trier les différentiels (meilleurs en premier)
    	    var sortedDifferentials = [...differentials].sort((a, b) => a - b);
    
    	    // Déterminer combien de scores utiliser
    	    var scoresToUse = 1;
    	    if (differentials.length >= 20) {
        	scoresToUse = 8;
    	    } else if (differentials.length >= 15) {
        	scoresToUse = 5;
    	    } else if (differentials.length >= 10) {
        	scoresToUse = 3;
    	    } else if (differentials.length >= 7) {
        	scoresToUse = 2;
    	    }
    
    	    // Prendre les meilleurs différentiels
    	    var bestDifferentials = sortedDifferentials.slice(0, scoresToUse);
    
    	    // Calculer la moyenne
    	    var average = bestDifferentials.reduce((sum, d) => sum + d, 0) / scoresToUse;
    
    	    // Appliquer le facteur 0.96 et arrondir
    	    var newHandicap = average * 0.96;
    
    	    // Limiter entre 0 et 36.4
    	    newHandicap = Math.max(0, Math.min(36.4, newHandicap));
    
    	    return Math.round(newHandicap * 10) / 10;
	}

	// 4. FONCTION POUR FORCER LA MISE À JOUR COMPLÈTE
	function forceHandicapEvolutionUpdate() {
    	    console.log("🚀 FORCE MISE À JOUR ÉVOLUTION HANDICAPS");
    	    console.log("=========================================");
    
    	    // Recalculer toutes les données
    	    prepareHandicapEvolutionData();
    
    	    // Mettre à jour l'affichage immédiatement
    	    if (typeof displayHandicapStats === 'function') {
        	displayHandicapStats();
    	    }
    
    	    // Mettre à jour le graphique si des joueurs sont sélectionnés
    	    if (typeof selectedPlayers !== 'undefined' && selectedPlayers.length > 0) {
        	if (typeof drawHandicapChart === 'function') {
            	    drawHandicapChart();
        	}
    	    }
    
    	    // Afficher un résumé des changements
    	    console.log("\n📊 RÉSUMÉ DES ÉVOLUTIONS:");
    	    console.log("========================");
    
    	    for (var playerId in handicapEvolutionData) {
        	var playerData = handicapEvolutionData[playerId];
        	var evolution = playerData.evolution;
        
        	if (evolution.length >= 2) {
            	    var initial = evolution[0].handicap;
            	    var final = evolution[evolution.length - 1].handicap;
            	    var change = final - initial;
            	    var totalGames = evolution.length - 1;
            
            	    var status = '';
            	    if (change < -1) status = '📈 AMÉLIORATION';
            	    else if (change > 1) status = '📉 DÉGRADATION';
            	    else status = '➡️ STABLE';
            
            	    console.log(`${playerData.playerName}:`);
            	    console.log(`  ${initial.toFixed(1)} → ${final.toFixed(1)} (${change > 0 ? '+' : ''}${change.toFixed(1)}) ${status}`);
            	    console.log(`  ${totalGames} parties jouées`);
        	}
    	    }
    
    	    console.log("\n✅ MISE À JOUR TERMINÉE - Vérifiez le tableau des statistiques!");
	}

	// Fonction pour recalculer le handicap d'un joueur basé sur ses scores jusqu'à une date donnée
	function calculateHandicapAtDate(playerId, upToDate) {
    	    var player = players.find(p => p.id === playerId);
    	    if (!player) return null;
    
    	    var playerIndex = players.findIndex(p => p.id === playerId);
    	    if (playerIndex === -1) return player.handicap;
    
    	    var playerScores = [];
    
    	    // Collecter tous les scores du joueur jusqu'à la date spécifiée
    	    for (var i = 0; i < dates.length; i++) {
        	if (new Date(dates[i]) <= new Date(upToDate)) {
            	    var grossScore = allScores[playerIndex][i];
            
            	    if (grossScore > 0) {
                	var courseName = courses[i];
                	var teeForPlayer = (playerId === 1) ? teeUsed[i] : 'blanc';
                	var differential = calculateScoreDifferential(grossScore, courseName, teeForPlayer);
                
                	if (differential > 0) {
                    	    playerScores.push({
                        	date: dates[i],
                        	differential: differential
                    	    });
                	}
            	    }
        	}
    	    }
    
    	    // Calculer le handicap selon les règles officielles
    	    if (playerScores.length < 5) {
        	// Pas assez de scores, garder le handicap initial
        	return player.handicap;
    	    }
    
    	    var differentials = playerScores.map(s => s.differential);
    	    differentials.sort((a, b) => a - b);
    
    	    var scoresToUse = 1;
    	    if (playerScores.length >= 20) scoresToUse = 8;
    	    else if (playerScores.length >= 15) scoresToUse = 5;
    	    else if (playerScores.length >= 10) scoresToUse = 3;
    	    else if (playerScores.length >= 7) scoresToUse = 2;
    
    	    var bestDifferentials = differentials.slice(0, scoresToUse);
    	    var average = bestDifferentials.reduce((sum, d) => sum + d, 0) / scoresToUse;
    
    	    return Math.round(average * 0.96 * 10) / 10;
	}

	// Fonction pour obtenir le handicap d'un joueur à une date donnée
	function getPlayerHandicapAtDate(playerId, gameDate) {
    	    // Chercher dans le cache first
    	    var cacheKey = playerId + '_' + gameDate;
    	    if (handicapCache[cacheKey]) {
        	return handicapCache[cacheKey];
    	    }
    
    	    // Calculer et mettre en cache
    	    var handicap = calculateHandicapAtDate(playerId, gameDate);
    	    handicapCache[cacheKey] = handicap;
    
    	    return handicap;
	}

	// Fonction pour forcer la recalculation de l'évolution des handicaps
	function fixHandicapEvolution() {
    	    console.log("🔄 Correction de l'évolution des handicaps...");
    
    	    // Vider le cache
    	    handicapCache = {};
    
    	    // Recalculer les données d'évolution avec les vrais handicaps
    	    handicapEvolutionData = {};
    
    	    for (var i = 0; i < players.length; i++) {
        	var player = players[i];
        	var evolution = [];
        	var playerName = player.name || (player.firstName + ' ' + player.lastName);
        
        	// Handicap initial (avant toute partie)
        	var initialHandicap = player.handicap;
        
        	evolution.push({
            	    date: dates[0] || '2023-01-01',
            	    handicap: initialHandicap,
            	    gameNumber: 0,
            	    change: 0
        	});
        
        	// Calculer l'évolution après chaque partie
        	for (var j = 0; j < dates.length; j++) {
            	    if (allScores[i][j] > 0) {
                	// Calculer le handicap à cette date
                	var newHandicap = getPlayerHandicapAtDate(player.id, dates[j]);
                	var previousHandicap = j === 0 ? initialHandicap : evolution[evolution.length - 1].handicap;
                	var change = newHandicap - previousHandicap;
                
                	evolution.push({
                    	    date: dates[j],
                    	    handicap: newHandicap,
                    	    gameNumber: j + 1,
                    	    change: change,
                    	    score: allScores[i][j],
                    	    course: courses[j]
                	});
            	    }
        	}
        
        	handicapEvolutionData[player.id] = {
            	    player: player,
            	    playerName: playerName,
            	    evolution: evolution
        	};
    	    }
    
    	    console.log("✅ Évolution des handicaps corrigée!");
    
    	    // Vérifier les résultats
    	    console.log("📊 Nouveaux résultats:");
    	    for (var playerId in handicapEvolutionData) {
        	var playerData = handicapEvolutionData[playerId];
        	var evolution = playerData.evolution;
        
        	if (evolution.length >= 2) {
            	    var initial = evolution[0].handicap;
            	    var final = evolution[evolution.length - 1].handicap;
            	    var change = final - initial;
            
            	    console.log(playerData.playerName + ": " + initial.toFixed(1) + " → " + final.toFixed(1) + " (" + (change > 0 ? "+" : "") + change.toFixed(1) + ")");
        	}
    	    }
    
    	    // Recharger l'affichage
    	    displayHandicapStats();
    	    if (selectedPlayers && selectedPlayers.length > 0) {
        	drawHandicapChart();
    	    }
	}

        // Scores réels pour chaque joueur
        var allScores = [];
           
        var rounds = [];
        var scores = [];
		var gprRoundsData = [];
		var handicapCache = {};
		// Système GPR : tracking des finales
		var gprFinaleData = {};
		var GPR_TOTAL_PLAYERS = 12; // Base de calcul pour les absences
		var gprBest4Data = {}; // Stockage des 4 meilleures parties par joueur
		// Variables globales pour le calcul GPR
		var playerPoints = {};
		var playerBest4Points = {};
		var roundDetails = [];
		// Nouvelles constantes pour le système GPR
		var GPR_TOTAL_PLAYERS = 12; // Base de calcul pour les absences
		var GPR_FINALE_TOTAL_POINTS = 400; // Points fixes pour la finale

		// Fonction pour calculer les points d'absence (dernière place)
		function calculateAbsenteePoints(presentPlayers, isNet, isFinale, finaleFormat) {
		    var totalPlayers = GPR_TOTAL_PLAYERS;
		    var absentees = totalPlayers - presentPlayers;
		    
		    if (absentees <= 0) return 0;
		    
		    // Points selon le type de partie
		    var pointsScale = isFinale ? 
    			(isNet ? [225, 190, 165, 140, 125, 110, 90, 75, 60, 45, 35, 25] : 
            			 [175, 140, 120, 100, 85, 70, 60, 50, 40, 30, 20, 10]) :
    			(isNet ? [120, 105, 90, 78, 70, 62, 54, 46, 38, 30, 22, 15] : 
            			 [80, 68, 60, 52, 45, 40, 35, 30, 25, 20, 15, 10]);

			// Calculer la moyenne des points des dernières places
			var totalAbsenteePoints = 0;
			for (var i = 0; i < absentees; i++) {
    			var position = presentPlayers + i + 1;
    			totalAbsenteePoints += pointsScale[Math.min(position - 1, pointsScale.length - 1)];
			}

			return Math.round(totalAbsenteePoints / absentees);
		}

		// Fonction pour identifier les parties finale
		function isFinaleRound(round) {
    		return round.type === 'gpr' && round.gprPhase === 'finale';
		}

		// Fonction pour calculer les points d'absence (règle des 12 joueurs)
		function calculateAbsenteePoints(presentPlayers, isNet, isFinale) {
    		var absentees = GPR_TOTAL_PLAYERS - presentPlayers;
    		if (absentees <= 0) return 0;
    
    		var pointsScale = isFinale ? 
        		(isNet ? [225, 190, 165, 140, 125, 110, 90, 75, 60, 45, 35, 25] : 
                		 [175, 140, 120, 100, 85, 70, 60, 50, 40, 30, 20, 10]) :
        		(isNet ? [120, 105, 90, 78, 70, 62, 54, 46, 38, 30, 22, 15] : 
                		 [80, 68, 60, 52, 45, 40, 35, 30, 25, 20, 15, 10]);
    
    		// Calculer la moyenne des points des dernières places
    		var totalAbsenteePoints = 0;
    		for (var i = 0; i < absentees; i++) {
        		var position = presentPlayers + i + 1;
        		totalAbsenteePoints += pointsScale[Math.min(position - 1, pointsScale.length - 1)];
    		}
    
    		return Math.round(totalAbsenteePoints / absentees);
		}
		
		// Fonction pour calculer les 4 meilleures parties d'exhibition
		function calculateBest4Exhibition(playerId, year) {
		    console.log('=== calculateBest4Exhibition ===');
    		console.log('Joueur ID:', playerId, 'Année:', year);
			
			// Obtenir toutes les parties exhibition de l'année (pas les finales)
			var exhibitionRounds = rounds.filter(r => 
		        r.type === 'gpr' && 
		        r.year === year && 
		        (!r.gprPhase || r.gprPhase === 'exhibition')
		    );

			console.log('Rounds exhibition de l\'année:', exhibitionRounds.length);
		    
		    // Calculer les points pour chaque partie (même si le joueur était absent)
		    var partiesWithPoints = [];
		    
		    for (var i = 0; i < exhibitionRounds.length; i++) {
		        var round = exhibitionRounds[i];
		        var roundScores = scores.filter(s => s.roundId === round.id && s.playerId !== 13);
		        
		        // Vérifier si le joueur a participé
		        var playerScore = roundScores.find(s => s.playerId === playerId);
		        
		        var brutPos, netPos, brutPoints, netPoints;
		        
		        if (playerScore) {
		            // Joueur présent - calculer sa position réelle
		            var brutRanking = [...roundScores].sort((a, b) => a.score - b.score);
		            var netRanking = [...roundScores].sort((a, b) => a.net - b.net);
		            
		            brutPos = brutRanking.findIndex(s => s.playerId === playerId) + 1;
		            netPos = netRanking.findIndex(s => s.playerId === playerId) + 1;
		            
		            brutPoints = [80, 68, 60, 52, 45, 40, 35, 30, 25, 20, 15, 10][Math.min(brutPos - 1, 11)];
		            netPoints = [120, 105, 90, 78, 70, 62, 54, 46, 38, 30, 22, 15][Math.min(netPos - 1, 11)];
		        } else {
		            // Joueur absent - calculer les points d'absence
		            var presentPlayers = roundScores.length;
		            brutPoints = calculateAbsenteePoints(presentPlayers, false, false);
		            netPoints = calculateAbsenteePoints(presentPlayers, true, false);
		            brutPos = presentPlayers + 1;
		            netPos = presentPlayers + 1;
		            
		            // Créer un score fictif pour l'absent
		            playerScore = {
		                playerId: playerId,
		                score: 999,
		                net: 999,
		                absent: true
		            };
		        }
		        
		        partiesWithPoints.push({
		            roundId: round.id,
		            date: round.date,
		            course: round.course,
		            totalPoints: brutPoints + netPoints,
		            brutPoints: brutPoints,
		            netPoints: netPoints,
		            brutPos: brutPos,
		            netPos: netPos,
		            score: playerScore,
		            absent: !roundScores.find(s => s.playerId === playerId)
		        });
		    }
		    
		    console.log('Parties avec points calculées:', partiesWithPoints.length);
		    
		    // Trier par points décroissants et prendre les 4 meilleures (ou toutes si moins de 5)
		    partiesWithPoints.sort((a, b) => b.totalPoints - a.totalPoints);
		    var result = partiesWithPoints.length >= 5 ? partiesWithPoints.slice(0, 4) : partiesWithPoints;
		    
		    console.log('Best 4 pour joueur', playerId, ':', result.length, 'parties sélectionnées');
		    return result;
		}

		// Fonction pour cumuler les scores de finale
		function calculateFinaleScores(year) {
    		console.log('=== calculateFinaleScores appelée pour année:', year);
    		var finaleRounds = rounds.filter(r => {
    			var yearMatch = !year || r.year == year;
    			return yearMatch && r.type === 'gpr' && r.gprPhase === 'finale';
			});

    		console.log('Rounds finale trouvés:', finaleRounds);
    		if (finaleRounds.length > 0) {
        		console.log('Format finale:', finaleRounds[0].gprFinaleFormat);
    		}
    
    		var finaleResults = {};
    
    		if (finaleRounds.length === 0) {
        		console.log('Aucune finale trouvée');
        		return {};
    		}
    
    		// Identifier les joueurs participants (exclure Éric Gosselin ID 12)
    		for (var i = 0; i < finaleRounds.length; i++) {
        		var round = finaleRounds[i];
        		var roundScores = scores.filter(s => s.roundId === round.id && s.playerId !== 13);
        
        		for (var j = 0; j < roundScores.length; j++) {
            		var score = roundScores[j];
            
            		if (!finaleResults[score.playerId]) {
                		finaleResults[score.playerId] = {
                    		player: players.find(p => p.id === score.playerId),
                    		totalBrut: 0,
                    		totalNet: 0,
                    		daysPlayed: 0
                		};
            		}
            
            		finaleResults[score.playerId].totalBrut += score.score;
            		finaleResults[score.playerId].totalNet += score.net;
            		finaleResults[score.playerId].daysPlayed++;
        		}
    		}
    
			// === AJOUT DES ABSENTS ===
			console.log('=== AJOUT ABSENTS FINALE ' + year + ' ===');

			// Obtenir tous les joueurs GPR de l'année
			var allGPRScores = scores.filter(s => 
    			s.year == year && 
    			s.type === 'gpr' && 
    			s.playerId !== 13
			);

			var gprPlayerIds = [];
			for (var i = 0; i < allGPRScores.length; i++) {
    			if (gprPlayerIds.indexOf(allGPRScores[i].playerId) === -1) {
        			gprPlayerIds.push(allGPRScores[i].playerId);
    			}
			}

			console.log('Joueurs GPR trouvés:', gprPlayerIds.length, 'joueurs');
			console.log('IDs:', gprPlayerIds);

			// Ajouter ceux qui manquent
			for (var i = 0; i < gprPlayerIds.length; i++) {
    			var playerId = gprPlayerIds[i];
    			if (!finaleResults[playerId]) {
        			var player = players.find(p => p.id === playerId);
        			finaleResults[playerId] = {
            			player: player,
            			totalBrut: 999,
            			totalNet: 999,
            			daysPlayed: 0,
            			absent: true
        			};
        			console.log('AJOUT ABSENT:', player.name || (player.firstName + ' ' + player.lastName));
    			}
			}

    		// Distribuer les 400 points fixes de finale
    		var playersArray = [];
    		for (var playerId in finaleResults) {
        		playersArray.push({
            		playerId: parseInt(playerId),
            		data: finaleResults[playerId]
        		});
    		}

    		// Classement finale par score brut cumulé
    		playersArray.sort((a, b) => {
        		if (a.data.daysPlayed === 0 && b.data.daysPlayed === 0) return 0;
        		if (a.data.daysPlayed === 0) return 1;
        		if (b.data.daysPlayed === 0) return -1;
        		return a.data.totalBrut - b.data.totalBrut;
    		});

    		// Vérifier si c'est une finale 1 jour ou 2 jours
    		var isFinale1Day = false;
    		if (finaleRounds.length > 0 && finaleRounds[0].gprFinaleFormat === '1day') {
        		isFinale1Day = true;
    		}

    		// Points finale FIXES - toujours 400 points au total
			var finaleBrutPoints = [175, 140, 120, 100, 85, 70, 60, 50, 40, 30, 20, 10];
			var finaleNetPoints = [225, 190, 165, 140, 125, 110, 90, 75, 60, 45, 35, 25];

			console.log('Format finale:', isFinale1Day ? '1 jour' : '2 jours');
			console.log('Nombre de jours de finale:', finaleRounds.length);
			console.log('Points brut à distribuer:', finaleBrutPoints.reduce((a,b) => a+b, 0));
			console.log('Points net à distribuer:', finaleNetPoints.reduce((a,b) => a+b, 0));

			// Distribution des points brut
			for (var i = 0; i < playersArray.length; i++) {
    			var pointsBrut = finaleBrutPoints[Math.min(i, finaleBrutPoints.length - 1)];
    			playersArray[i].data.pointsBrut = pointsBrut;
    			playersArray[i].data.positionBrut = i + 1;
			}

			// Classement finale par score net cumulé
			playersArray.sort((a, b) => {
    			if (a.data.daysPlayed === 0 && b.data.daysPlayed === 0) return 0;
    			if (a.data.daysPlayed === 0) return 1;
    			if (b.data.daysPlayed === 0) return -1;
    			return a.data.totalNet - b.data.totalNet;
			});

			// Distribution des points net
			for (var i = 0; i < playersArray.length; i++) {
    			var pointsNet = finaleNetPoints[Math.min(i, finaleNetPoints.length - 1)];
    			playersArray[i].data.pointsNet = pointsNet;
    			playersArray[i].data.positionNet = i + 1;
    			playersArray[i].data.totalPointsFinale = playersArray[i].data.pointsBrut + pointsNet;
			}

    		// Debug - Vérifier le total des points
    		var totalBrutDistribue = 0;
    		var totalNetDistribue = 0;
    		for (var i = 0; i < playersArray.length; i++) {
        		totalBrutDistribue += playersArray[i].data.pointsBrut || 0;
        		totalNetDistribue += playersArray[i].data.pointsNet || 0;
    		}
    		console.log('=== DEBUG FINALE ===');
    		console.log('Total points brut distribués:', totalBrutDistribue);
    		console.log('Total points net distribués:', totalNetDistribue);
    		console.log('TOTAL GÉNÉRAL:', totalBrutDistribue + totalNetDistribue);

    		// Remettre dans l'objet finaleResults
    		for (var i = 0; i < playersArray.length; i++) {
        		var playerId = playersArray[i].playerId;
        		finaleResults[playerId] = playersArray[i].data;
    		}

    		return finaleResults;
		}

	// Fonction pour recalculer le handicap d'un joueur basé sur ses scores jusqu'à une date donnée
	function calculateHandicapAtDate(playerId, upToDate) {
    	    var playerScores = [];
    
    	    // Collecter tous les scores du joueur jusqu'à la date spécifiée
    	    for (var i = 0; i < dates.length; i++) {
        	if (new Date(dates[i]) <= new Date(upToDate)) {
            	    if (grossScore > 0) {
    					var courseName = courses[i];
    					var teeForPlayer = (playerId === 1) ? teeUsed[i] : 'blanc';
    					var differential = calculateScoreDifferential(grossScore, courseName, teeForPlayer);
    
    					if (differential !== null) {
        					playerScores.push({
            					date: dates[i],
            					differential: differential
        					});
    					}
					}
            
            	if (grossScore > 0) {
                    var courseName = courses[i];
                    var teeForPlayer = (playerId === 1) ? teeUsed[i] : 'blanc';
                    var differential = calculateScoreDifferential(grossScore, courseName, teeForPlayer);
                
                    if (differential > 0) {
                        playerScores.push({
                            date: dates[i],
                            differential: differential
                        });
                    }
                }
            }
        }
    
    	// Trier par date (plus récent en premier)
    	playerScores.sort((a, b) => new Date(b.date) - new Date(a.date));
    
    	// Calculer le handicap selon les règles officielles
    	if (playerScores.length < 5) {
            // Pas assez de scores, garder le handicap initial
            var initialPlayer = players.find(p => p.id === playerId);
            return initialPlayer ? initialPlayer.handicap : null;
        }
    
    	var differentials = playerScores.map(s => s.differential);
    	differentials.sort((a, b) => a - b);
    
    	var scoresToUse = 1;
    	if (playerScores.length >= 20) scoresToUse = 8;
    	else if (playerScores.length >= 15) scoresToUse = 5;
    	else if (playerScores.length >= 10) scoresToUse = 3;
    	else if (playerScores.length >= 7) scoresToUse = 2;
    
    	var bestDifferentials = differentials.slice(0, scoresToUse);
    	var average = bestDifferentials.reduce((sum, d) => sum + d, 0) / scoresToUse;
    
    	return Math.round(average * 0.96 * 10) / 10;
    }

    // Fonction pour obtenir le handicap d'un joueur à une date donnée
    function getPlayerHandicapAtDate(playerId, gameDate) {
    	// Chercher dans le cache first
    	var cacheKey = playerId + '_' + gameDate;
    	if (handicapCache[cacheKey]) {
            return handicapCache[cacheKey];
    	}
    
    	// Calculer et mettre en cache
    	var handicap = calculateHandicapAtDate(playerId, gameDate);
    	handicapCache[cacheKey] = handicap;
    
    	return handicap;
    }

    function initializeData() {
    	// Si rounds n'existe pas, le créer
    	if (typeof rounds === 'undefined' || !rounds || rounds.length === 0) {
        	console.log('Pas de rounds chargés, création depuis dates/courses');
        	rounds = [];
        
        	// Construire rounds depuis les anciennes données
        	for (var i = 0; i < dates.length; i++) {
            	var courseName = courses[i];
            	var isDiablo = (courseName === 'Le Diable' || courseName === 'Le Géant' || courseName === 'Manoir des Sables');
            	var gameDate = new Date(dates[i]);
            	var year = gameDate.getFullYear();
            	var month = gameDate.getMonth() + 1;
            
            	rounds.push({
                	id: i + 1,
                	date: dates[i],
                	course: courseName,
                	tee: teeUsed[i],
                	type: isDiablo ? 'diablo' : 'gpr',
                	year: year,
                	month: month
            	});
        	}
    	} else {
        	console.log('Rounds déjà chargés depuis Firebase, conservation complète');
        	console.log('Nombre de rounds:', rounds.length);
        	var gprFinales = rounds.filter(r => r.gprPhase === 'finale');
        	console.log('Dont finales GPR:', gprFinales.length);
    	}
    
    	// Toujours reconstruire scores
    	scores = [];
    	handicapCache = {};
    
    	// Reconstruire les scores basés sur rounds existants
    	for (var i = 0; i < rounds.length; i++) {
        	var round = rounds[i];
        	var roundIndex = i; // L'index dans allScores correspond à l'ordre des rounds
        
        	// Ajouter les scores pour cette partie
        	for (var j = 0; j < players.length; j++) {
            	var grossScore = allScores[j][roundIndex];
            
            	if (grossScore > 0) {
                	var player = players[j];
                	var teeForPlayer = teeUsed[roundIndex];
                
                	// Antonio (id=1) joue des bleus pour certaines parties
                	if (player.id !== 1) {
                    	teeForPlayer = 'blanc';
                	}
                
                	var courseHandicap = calculateCourseHandicap(player.handicap, round.course, teeForPlayer);
                	var netScore = grossScore - courseHandicap;
                
                	scores.push({
                    	roundId: round.id,
                    	playerId: player.id,
                    	playerName: player.name || (player.firstName + ' ' + player.lastName),
                    	score: grossScore,
                    	courseHandicap: courseHandicap,
                    	net: netScore,
                    	tee: teeForPlayer,
                    	type: round.type,
                    	year: round.year,
                    	month: round.month
                	});
            	}
        	}
    	}
    
    	console.log('InitializeData terminé - Scores reconstruits:', scores.length);
	}

	// Fonction pour calculer le différentiel de score (Score Differential)
	function calculateScoreDifferential(grossScore, courseName, teeColor) {
    	    if (!coursesDatabase[courseName]) {
        	console.warn('Terrain non trouvé:', courseName);
        	return null;
    	    }
    
    	    var courseData = coursesDatabase[courseName];
    	    var teeData = courseData.find(t => t.tee === teeColor);
    
    	    if (!teeData) {
        	teeData = courseData[0];
        	console.warn('Départ', teeColor, 'non trouvé pour', courseName, ', utilisation de', teeData.tee);
    	    }
    
    	    // Score Differential = (Gross Score - Course Rating) × 113 / Slope Rating
    	    var differential = (grossScore - teeData.rating) * 113 / teeData.slope;
    	    return Math.round(differential * 10) / 10;
	}

        // Fonctions de navigation
        function showOverview() {
            hideAllSections();
            document.getElementById('overview').style.display = 'block';
            setActiveButton('showOverview');
            loadOverview();
        }

        function showPlayerScores() {
            hideAllSections();
            document.getElementById('playerScores').style.display = 'block';
            setActiveButton('showPlayerScores');
            loadPlayerSelector();
        }

        function showCourses() {
            hideAllSections();
            document.getElementById('courses').style.display = 'block';
            setActiveButton('showCourses');
            loadCoursesList();
        }

        function showDiablo() {
            hideAllSections();
            document.getElementById('diablo').style.display = 'block';
            setActiveButton('showDiablo');
            loadDiablo();
        }

        function showGPR() {
            hideAllSections();
            document.getElementById('gpr').style.display = 'block';
            setActiveButton('showGPR');
            loadGPR();
        }

        function showProgress() {
            hideAllSections();
            document.getElementById('progress').style.display = 'block';
            setActiveButton('showProgress');
            loadProgress();
        }

        function showDetails() {
            hideAllSections();
            document.getElementById('details').style.display = 'block';
            setActiveButton('showDetails');
            loadDetails();
        }

		function showHandicapEvolution() {
            hideAllSections();
            document.getElementById('handicapEvolution').style.display = 'block';
            setActiveButton('showHandicapEvolution');
            loadDetails();
        }

		function showPlayerManagement() {
            hideAllSections();
            document.getElementById('playerManagement').style.display = 'block';
            setActiveButton('showPlayerManagement');
            loadDetails();
        }

		function showAddRound() {
            hideAllSections();
            document.getElementById('addRound').style.display = 'block';
            setActiveButton('showAddRound');
            loadDetails();
        }

        function hideAllSections() {
    		var sections = ['overview', 'playerScores', 'courses', 'diablo', 'gpr', 'progress', 'details', 'handicapEvolution', 'playerManagement', 'addRound', 'calendar'];
    		for (var i = 0; i < sections.length; i++) {
        		var element = document.getElementById(sections[i]);
        		if (element) {
            		element.style.display = 'none';
        		}
    		}
		}

        function setActiveButton(buttonFunction) {
    		var buttons = document.querySelectorAll('.nav button:not(.nav-save-btn)');
    		for (var i = 0; i < buttons.length; i++) {
        		buttons[i].classList.remove('active');
    		}
    
    		// Ajouter active au bon bouton selon la fonction
    		var activeSelector = '';
    		switch(buttonFunction) {
        		case 'showAddRound': activeSelector = 'button[onclick="showAddRound()"]'; break;
        		case 'showProgress': activeSelector = 'button[onclick="showProgress()"]'; break;
        		case 'showDiablo': activeSelector = 'button[onclick="showDiablo()"]'; break;
        		case 'showGPR': activeSelector = 'button[onclick="showGPR()"]'; break;
        		case 'showOverview': activeSelector = 'button[onclick="showOverview()"]'; break;
        		case 'showHandicapEvolution': activeSelector = 'button[onclick="showHandicapEvolution()"]'; break;
        		case 'showPlayerScores': activeSelector = 'button[onclick="showPlayerScores()"]'; break;
        		case 'showDetails': activeSelector = 'button[onclick="showDetails()"]'; break;
        		case 'showCourses': activeSelector = 'button[onclick="showCourses()"]'; break;
        		case 'showPlayerManagement': activeSelector = 'button[onclick="showPlayerManagement()"]'; break;
				case 'showCalendar': activeSelector = 'button[onclick="showCalendar()"]'; break;
    		}
    
    		if (activeSelector) {
        		var activeButton = document.querySelector('.nav ' + activeSelector);
        		if (activeButton) {
            		activeButton.classList.add('active');
        		}
    		}
		}

        // FONCTION loadOverview() - TROUVEZ ET REMPLACEZ CETTE PARTIE :

	function loadOverview() {
    	var totalGames = rounds.length;
    	var totalScores = scores.length;
    	var activePlayers = getUniquePlayersCount(scores);
    	var totalCourses = Object.keys(coursesDatabase).length;

    	var diabloGames = rounds.filter(r => r.type === 'diablo').length;
    	var gprGames = rounds.filter(r => r.type === 'gpr').length;

    	var html = '<div class="player-stats">' +
        	       '<div class="stat-box">' +
            	   '<div class="stat-value">' + totalGames + '</div>' +
                   '<div class="stat-label">Parties Total</div>' +
            	   '</div>' +
            	   '<div class="stat-box">' +
            	   '<div class="stat-value">' + activePlayers + '</div>' +
            	   '<div class="stat-label">Joueurs Actifs</div>' +
            	   '</div>' +
            	   '<div class="stat-box">' +
            	   '<div class="stat-value">' + totalCourses + '</div>' +
            	   '<div class="stat-label">Terrains en Base</div>' +
            	   '</div>' +
            	   '<div class="stat-box">' +
            	   '<div class="stat-value">' + diabloGames + '</div>' +
            	   '<div class="stat-label">Parties Diablo</div>' +
            	   '</div>' +
            	   '<div class="stat-box">' +
            	   '<div class="stat-value">' + gprGames + '</div>' +
            	   '<div class="stat-label">Parties GPR</div>' +
            	   '</div>' +
            	   '</div>';

    	// CLASSEMENT COMPLET DE TOUS LES JOUEURS
    	var allPlayerStats = [];
    	for (var i = 0; i < players.length; i++) {
        	var player = players[i];
        	var playerScores = scores.filter(s => s.playerId === player.id);
        	if (playerScores.length > 0) {
            	var avgGross = playerScores.reduce((sum, s) => sum + s.score, 0) / playerScores.length;
            	var avgNet = playerScores.reduce((sum, s) => sum + s.net, 0) / playerScores.length;
            	var bestGross = Math.min(...playerScores.map(s => s.score));
            	var bestNet = Math.min(...playerScores.map(s => s.net));
            
            	allPlayerStats.push({
                	player: player,
                	playerName: player.name || (player.firstName + ' ' + player.lastName),
                	games: playerScores.length,
                	avgGross: avgGross,
                	avgNet: avgNet,
                	bestGross: bestGross,
                	bestNet: bestNet
            	});
        	}
    	}

    	allPlayerStats.sort((a, b) => a.avgNet - b.avgNet);

    	html += '<h3>🏆 CLASSEMENT COMPLET DE TOUS LES JOUEURS</h3>' +
        	    '<p style="background: #e7f3ff; padding: 10px; border-radius: 5px; margin: 10px 0;">Classé par score net moyen (plus bas = meilleur). Total: ' + allPlayerStats.length + ' joueurs avec au moins 1 partie.</p>' +
        	    '<table class="table">' +
        	    '<thead><tr><th>🏆 Rang</th><th>👤 Joueur</th><th>🎮 Parties</th><th>🏌️ Handicap</th><th>📊 Moy. Brut</th><th>⭐ Moy. Net</th><th>🎯 Meilleur Net</th><th>💪 Meilleur Brut</th></tr></thead>' +
        	    '<tbody>';

    	for (var i = 0; i < allPlayerStats.length; i++) {
        	var stat = allPlayerStats[i];
        	var rowStyle = '';
        	var rankIcon = '';
        
        	// Podium avec icônes
        	if (i === 0) {
            	rowStyle = ' style="background: linear-gradient(45deg, #FFD700, #FFF8DC); font-weight: bold;"';
            	rankIcon = '🥇';
        	} else if (i === 1) {
            	rowStyle = ' style="background: linear-gradient(45deg, #C0C0C0, #F5F5F5); font-weight: bold;"';
            	rankIcon = '🥈';
        	} else if (i === 2) {
            	rowStyle = ' style="background: linear-gradient(45deg, #CD7F32, #F4E4BC); font-weight: bold;"';
            	rankIcon = '🥉';
        	} else if (i < 5) {
            	rowStyle = ' style="background: #e8f4fd; font-weight: 500;"';
            	rankIcon = '⭐';
        	} else if (i >= allPlayerStats.length - 3 && allPlayerStats.length > 5) {
            	rowStyle = ' style="background: #ffe8e8;"';
            	rankIcon = '📈';
        	}
        
        	html += '<tr' + rowStyle + '>' +
            	    '<td><strong>' + rankIcon + ' ' + (i + 1) + '</strong></td>' +
            	    '<td><strong>' + stat.playerName + '</strong></td>' +
            	    '<td>' + stat.games + '</td>' +
            	    '<td>' + stat.player.handicap.toFixed(1) + '</td>' +
            	    '<td>' + stat.avgGross.toFixed(1) + '</td>' +
            	    '<td><strong style="color: ' + (i < 3 ? '#28a745' : '#333') + ';">' + stat.avgNet.toFixed(1) + '</strong></td>' +
            	    '<td>' + stat.bestNet.toFixed(1) + '</td>' +
            	    '<td>' + stat.bestGross + '</td>' +
            	    '</tr>';
    	}

    	html += '</tbody></table>';

    	// ANALYSE STATISTIQUE DÉTAILLÉE
    	if (allPlayerStats.length > 0) {
        	html += '<div class="card" style="background: #f8f9fa; margin-top: 20px;">' +
            	    '<h4>📊 Analyse Statistique Complète</h4>' +
            	    '<div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(250px, 1fr)); gap: 15px;">';
        
        	var bestPlayer = allPlayerStats[0];
        	var worstPlayer = allPlayerStats[allPlayerStats.length - 1];
        	var avgNetAll = allPlayerStats.reduce((sum, stat) => sum + stat.avgNet, 0) / allPlayerStats.length;
        	var medianIndex = Math.floor(allPlayerStats.length / 2);
        	var medianNet = allPlayerStats[medianIndex].avgNet;
        	var spread = worstPlayer.avgNet - bestPlayer.avgNet;
        
        	html += '<div class="stat-box" style="background: #e8f5e8; border-left: 5px solid #28a745;">' +
            	    '<div class="stat-value" style="color: #28a745;">🥇 ' + bestPlayer.avgNet.toFixed(1) + '</div>' +
            	    '<div class="stat-label">Champion<br><strong>' + bestPlayer.playerName + '</strong></div>' +
            	    '</div>' +
                
            	    '<div class="stat-box" style="background: #ffe8e8; border-left: 5px solid #dc3545;">' +
            	    '<div class="stat-value" style="color: #dc3545;">📈 ' + worstPlayer.avgNet.toFixed(1) + '</div>' +
            	    '<div class="stat-label">À Améliorer<br><strong>' + worstPlayer.playerName + '</strong></div>' +
            	    '</div>' +
                
            	    '<div class="stat-box" style="background: #e3f2fd; border-left: 5px solid #2196f3;">' +
            	    '<div class="stat-value" style="color: #2196f3;">📊 ' + avgNetAll.toFixed(1) + '</div>' +
            	    '<div class="stat-label">Moyenne Groupe</div>' +
            	    '</div>' +
                
            	    '<div class="stat-box" style="background: #f3e5f5; border-left: 5px solid #9c27b0;">' +
            	    '<div class="stat-value" style="color: #9c27b0;">📏 ' + medianNet.toFixed(1) + '</div>' +
            	    '<div class="stat-label">Score Médian</div>' +
            	    '</div>' +
                
            	    '<div class="stat-box" style="background: #fff3e0; border-left: 5px solid #ff9800;">' +
            	    '<div class="stat-value" style="color: #ff9800;">📏 ' + spread.toFixed(1) + '</div>' +
            	    '<div class="stat-label">Écart Total</div>' +
            	    '</div>';
        
        	// Distribution par niveau
        	var excellent = allPlayerStats.filter(s => s.avgNet < avgNetAll - 2).length;
        	var good = allPlayerStats.filter(s => s.avgNet >= avgNetAll - 2 && s.avgNet < avgNetAll).length;
        	var average = allPlayerStats.filter(s => s.avgNet >= avgNetAll && s.avgNet < avgNetAll + 2).length;
        	var improving = allPlayerStats.filter(s => s.avgNet >= avgNetAll + 2).length;
        
        	html += '<div class="stat-box" style="background: #f0f0f0; border-left: 5px solid #666;">' +
            	    '<div class="stat-value" style="color: #666; font-size: 16px;">📈 Distribution</div>' +
                	'<div class="stat-label" style="font-size: 12px; line-height: 1.3;">' +
                	'🌟 Excellent: <strong>' + excellent + '</strong><br>' +
                	'👍 Bon: <strong>' + good + '</strong><br>' +
                	'📊 Moyen: <strong>' + average + '</strong><br>' +
                	'🔄 À améliorer: <strong>' + improving + '</strong>' +
                	'</div>' +
                	'</div>';
        
        	html += '</div></div>';
    	}

    	document.getElementById('overviewStats').innerHTML = html;
	}

        // VOIR LES TERRAINS

	function loadCoursesList() {
    	    var html = '';
    	    console.log('=== CHARGEMENT DES TERRAINS ===');
			var courseNames = Object.keys(coursesDatabase).sort();
    
    	    // Afficher les statistiques
    	    var totalTees = 0;
    	    for (var courseName in coursesDatabase) {
        	totalTees += coursesDatabase[courseName].length;
    	    }
    
    	    html += '<div style="background: #f8f9fa; padding: 15px; border-radius: 8px; margin-bottom: 20px;">' +
            	    '<strong>📊 Résumé:</strong> ' + courseNames.length + ' terrains avec ' + totalTees + ' départs au total' +
            	    '</div>';
    
    	    html += '<div class="course-grid">';
    
    	    for (var i = 0; i < courseNames.length; i++) {
        	var courseName = courseNames[i];
        	var tees = coursesDatabase[courseName];
        
        	html += '<div class="course-card">' +
        			'<div class="course-header">' +
        			'<div class="course-name">🏌️ ' + courseName + '</div>' +
        			'<div>' +
        			'<button class="btn-secondary" onclick="editCourse(\'' + courseName + '\')" style="margin-right: 5px;">✏️ Modifier</button>' +
        			'<button class="btn-danger" onclick="deleteCourse(\'' + courseName + '\')">🗑️ Supprimer</button>' +
        			'</div>' +
        			'</div>';
        
        	// Afficher chaque départ avec ses détails
        	for (var j = 0; j < tees.length; j++) {
            	    var tee = tees[j];
            
            	    // Déterminer la couleur du départ
            	    var teeIcon = '';
            	    switch(tee.tee) {
                	case 'blanc': teeIcon = '⚪'; break;
                	case 'bleu': teeIcon = '🔵'; break;
                	case 'vert': teeIcon = '🟢'; break;
                	case 'jaune': teeIcon = '🟡'; break;
                	case 'noir': teeIcon = '⚫'; break;
                	default: teeIcon = '🏌️'; break;
            	    }
            
            	    // Niveau de difficulté basé sur le slope
            	    var difficulty = '';
            	    var difficultyColor = '';
            	    if (tee.slope < 113) {
                	difficulty = 'Facile';
                	difficultyColor = '#28a745';
            	    } else if (tee.slope < 125) {
                	difficulty = 'Moyen';
                	difficultyColor = '#ffc107';
            	    } else if (tee.slope < 135) {
                	difficulty = 'Difficile';
                	difficultyColor = '#fd7e14';
            	    } else {
                	difficulty = 'Très difficile';
                	difficultyColor = '#dc3545';
            	    }
            
            	    html += '<div class="tee-info" style="border-left: 4px solid ' + difficultyColor + ';">' +
                    	    '<div style="display: flex; align-items: center; gap: 10px;">' +
                    	    '<span style="font-size: 18px;">' + teeIcon + '</span>' +
                    	    '<div>' +
                    	    '<span class="tee-color tee-' + tee.tee + '" style="padding: 3px 8px; border-radius: 12px; font-size: 11px; font-weight: bold;">' + 
                    	    tee.tee.toUpperCase() + '</span>' +
                    	    '<br><small style="color: ' + difficultyColor + '; font-weight: bold;">' + difficulty + '</small>' +
                    	    '</div>' +
                    	    '</div>' +
                    	    '<div style="text-align: right; font-family: monospace;">' +
                    	    '<div><strong>Rating:</strong> ' + tee.rating + '</div>' +
                    	    '<div><strong>Slope:</strong> ' + tee.slope + '</div>' +
                    	    '<div><strong>Par:</strong> ' + tee.par + '</div>' +
                    	    '</div>' +
                    	    '</div>';
        	}
        
        	html += '</div>';
    	    }
    
    	    html += '</div>';
    
			console.log('HTML généré:', html.substring(0, 500));
    	    document.getElementById('coursesList').innerHTML = html;
	}

    function toggleAddCourseForm() {
        var form = document.getElementById('addCourseForm');
        if (form.style.display === 'none') {
            form.style.display = 'block';
            document.getElementById('newCourseName').value = '';
            // Reset form with one tee input
            document.getElementById('teeInputs').innerHTML = 
                '<div class="tee-form-row">' +
                '<select>' +
                '<option value="blanc">Blanc</option>' +
                '<option value="bleu">Bleu</option>' +
                '<option value="vert">Vert</option>' +
                '<option value="jaune">Jaune</option>' +
                '<option value="noir">Noir</option>' +
                '</select>' +
                '<input type="number" placeholder="Rating (ex: 69.5)" step="0.1" min="60" max="80">' +
                '<input type="number" placeholder="Slope (ex: 123)" min="85" max="155">' +
                '<input type="number" placeholder="Par (ex: 72)" min="68" max="76">' +
                '<button type="button" class="btn-danger" onclick="removeTeeInput(this)">❌</button>' +
                '</div>';
        } else {
            form.style.display = 'none';
        }
    }

    function addTeeInput() {
        var container = document.getElementById('teeInputs');
        var newRow = document.createElement('div');
        newRow.className = 'tee-form-row';
        newRow.innerHTML = 
            '<select>' +
            '<option value="blanc">Blanc</option>' +
            '<option value="bleu">Bleu</option>' +
            '<option value="vert">Vert</option>' +
            '<option value="jaune">Jaune</option>' +
            '<option value="noir">Noir</option>' +
            '</select>' +
            '<input type="number" placeholder="Rating (ex: 69.5)" step="0.1" min="60" max="80">' +
            '<input type="number" placeholder="Slope (ex: 123)" min="85" max="155">' +
            '<input type="number" placeholder="Par (ex: 72)" min="68" max="76">' +
            '<button type="button" class="btn-danger" onclick="removeTeeInput(this)">❌</button>';
        container.appendChild(newRow);
    }

    function removeTeeInput(button) {
        var container = document.getElementById('teeInputs');
        if (container.children.length > 1) {
            button.parentElement.remove();
        }
    }

    function saveCourse() {
        var courseName = document.getElementById('newCourseName').value.trim();
        if (!courseName) {
            alert('Veuillez saisir le nom du terrain.');
            return;
        }
            
        if (coursesDatabase[courseName]) {
            if (!confirm('Ce terrain existe déjà. Voulez-vous le remplacer?')) {
                return;
            }
        }
            
        var teeRows = document.querySelectorAll('#teeInputs .tee-form-row');
        var tees = [];
            
        for (var i = 0; i < teeRows.length; i++) {
            var row = teeRows[i];
            var select = row.querySelector('select');
            var ratingInput = row.querySelectorAll('input')[0];
            var slopeInput = row.querySelectorAll('input')[1];
            var parInput = row.querySelectorAll('input')[2];
                
            var teeColor = select.value;
            var rating = parseFloat(ratingInput.value);
            var slope = parseInt(slopeInput.value);
            var par = parseInt(parInput.value);
                
            if (!rating || !slope || !par || rating < 60 || rating > 80 || slope < 85 || slope > 155 || par < 68 || par > 76) {
                alert('Veuillez remplir tous les champs avec des valeurs valides (Rating: 60-80, Slope: 85-155, Par: 68-76).');
                return;
            }
                
            tees.push({
                tee: teeColor,
                rating: rating,
                slope: slope,
                par: par
            });
        }
            
        coursesDatabase[courseName] = tees;
        // Sauvegarder dans Firebase
        saveCoursesToFirebase().then(function() {
            console.log('Terrain sauvegardé dans Firebase');
        }).catch(function(error) {
            console.error('Erreur de sauvegarde terrain:', error);
            alert('Erreur de sauvegarde: ' + error.message);
        });
        saveCourseData();
        loadCoursesList();
        toggleAddCourseForm();
            
        document.getElementById('coursesList').insertAdjacentHTML('afterbegin',
            '<div class="alert-success">✅ Terrain "' + courseName + '" ajouté avec succès!</div>'
        );
            
        setTimeout(function() {
            var alert = document.querySelector('#coursesList .alert-success');
            if (alert) alert.remove();
        }, 3000);
    }

    function cancelAddCourse() {
        toggleAddCourseForm();
    }

    function deleteCourse(courseName) {
    	if (confirm('Êtes-vous sûr de vouloir supprimer le terrain "' + courseName + '"?')) {
        	delete coursesDatabase[courseName];
        
        	// Sauvegarder dans Firebase
        	saveCoursesToFirebase().then(function() {
            	console.log('Terrain supprimé de Firebase');
        	}).catch(function(error) {
            	console.error('Erreur de suppression terrain:', error);
            	alert('Erreur de suppression: ' + error.message);
        	});
        
        	saveCourseData();
        	loadCoursesList();
        
        	document.getElementById('coursesList').insertAdjacentHTML('afterbegin',
            	'<div class="alert-danger">🗑️ Terrain "' + courseName + '" supprimé.</div>'
       		);
        
        	setTimeout(function() {
            	var alert = document.querySelector('#coursesList .alert-danger');
            	if (alert) alert.remove();
        	}, 3000);
    	}
	}

	// Nouvelle fonction pour éditer un terrain existant
	function editCourse(courseName) {
    	var courseData = coursesDatabase[courseName];
    	if (!courseData) {
        	alert('Terrain non trouvé!');
        	return;
    	}

    	// Créer le formulaire d'édition
    	var formHtml = 
    		'<div style="position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.5); z-index: 1000; overflow-y: auto;">' +
    		'<div style="background: white; padding: 30px; margin: 50px auto; border-radius: 10px; box-shadow: 0 4px 20px rgba(0,0,0,0.3); max-width: 700px; width: 90%;">' +
        	'<h3 style="margin-top: 0; color: #2c5530;">✏️ Modifier le Terrain</h3>' +
    
    		'<div style="margin: 15px 0;">' +
        	'<label style="display: block; font-weight: bold; margin-bottom: 5px;">Nom du terrain:</label>' +
        	'<input type="text" id="editCourseName" value="' + courseName.replace(/"/g, '&quot;') + '" style="width: 100%; padding: 8px; border: 1px solid #ddd; border-radius: 4px;">' +
    		'</div>' +
        
    		'<h4>Départs disponibles:</h4>' +
        	'<div id="editTeeInputs">';

    	// Ajouter les départs existants
    	for (var i = 0; i < courseData.length; i++) {
        	var tee = courseData[i];
        	formHtml += '<div class="tee-form-row">' +
            	'<select>' +
            	'<option value="blanc"' + (tee.tee === 'blanc' ? ' selected' : '') + '>Blanc</option>' +
            	'<option value="bleu"' + (tee.tee === 'bleu' ? ' selected' : '') + '>Bleu</option>' +
        		'<option value="vert"' + (tee.tee === 'vert' ? ' selected' : '') + '>Vert</option>' +
        		'<option value="jaune"' + (tee.tee === 'jaune' ? ' selected' : '') + '>Jaune</option>' +
        		'<option value="noir"' + (tee.tee === 'noir' ? ' selected' : '') + '>Noir</option>' +
            	'</select>' +
            	'<input type="number" value="' + tee.rating + '" step="0.1" min="60" max="80" placeholder="Rating">' +
        		'<input type="number" value="' + tee.slope + '" min="85" max="155" placeholder="Slope">' +
        		'<input type="number" value="' + tee.par + '" min="68" max="76" placeholder="Par">' +
        		'<button type="button" class="btn-danger" onclick="removeEditTeeInput(this)">❌</button>' +
            	'</div>';
    	}

    	formHtml += '</div>' +
        	'<button class="btn-secondary" onclick="addEditTeeInput()">➕ Ajouter un Départ</button>' +
        	'<br><br>' +
    		'<div style="margin-top: 25px; text-align: center;">' +
    		'<button onclick="saveCourseEdit(\'' + courseName + '\')" style="background: #4a7c59; color: white; border: none; padding: 12px 24px; border-radius: 5px; margin: 5px; cursor: pointer; font-size: 16px;">💾 Sauvegarder</button>' +
        	'<button onclick="cancelCourseEdit()" style="background: #6c757d; color: white; border: none; padding: 12px 24px; border-radius: 5px; margin: 5px; cursor: pointer; font-size: 16px;">❌ Annuler</button>' +
        	'</div>' +
    		'</div></div>';

    	// Ajouter la popup au body
    	var popup = document.createElement('div');
    	popup.id = 'editCoursePopup';
    	popup.innerHTML = formHtml;
    	document.body.appendChild(popup);
	}

	// Ajouter un nouveau départ dans l'édition
	function addEditTeeInput() {
    	var container = document.getElementById('editTeeInputs');
   		var newRow = document.createElement('div');
    	newRow.className = 'tee-form-row';
    	newRow.innerHTML = 
        	'<select>' +
        	'<option value="blanc">Blanc</option>' +
    		'<option value="bleu">Bleu</option>' +
    		'<option value="vert">Vert</option>' +
        	'<option value="jaune">Jaune</option>' +
        	'<option value="noir">Noir</option>' +
    		'</select>' +
    		'<input type="number" placeholder="Rating (ex: 69.5)" step="0.1" min="60" max="80">' +
        	'<input type="number" placeholder="Slope (ex: 123)" min="85" max="155">' +
        	'<input type="number" placeholder="Par (ex: 72)" min="68" max="76">' +
    		'<button type="button" class="btn-danger" onclick="removeEditTeeInput(this)">❌</button>';
    	container.appendChild(newRow);
	}

	// Supprimer un départ dans l'édition
	function removeEditTeeInput(button) {
    	var container = document.getElementById('editTeeInputs');
    	if (container.children.length > 1) {
        	button.parentElement.remove();
    	} else {
        	alert('Un terrain doit avoir au moins un départ.');
    	}
	}

	// Sauvegarder les modifications du terrain
	function saveCourseEdit(originalCourseName) {
    	var newCourseName = document.getElementById('editCourseName').value.trim();
    	if (!newCourseName) {
        	alert('Veuillez saisir le nom du terrain.');
        	return;
    	}
    
    	// Vérifier si le nouveau nom existe déjà (sauf si c'est le même)
    	if (newCourseName !== originalCourseName && coursesDatabase[newCourseName]) {
        	alert('Un terrain avec ce nom existe déjà.');
        	return;
    	}
    
    	var teeRows = document.querySelectorAll('#editTeeInputs .tee-form-row');
    	var tees = [];
    
    	for (var i = 0; i < teeRows.length; i++) {
        	var row = teeRows[i];
        	var select = row.querySelector('select');
    		var ratingInput = row.querySelectorAll('input')[0];
   			var slopeInput = row.querySelectorAll('input')[1];
        	var parInput = row.querySelectorAll('input')[2];
        
        	var teeColor = select.value;
    		var rating = parseFloat(ratingInput.value);
    		var slope = parseInt(slopeInput.value);
			var par = parseInt(parInput.value);
        
        	if (!rating || !slope || !par || rating < 60 || rating > 80 || slope < 85 || slope > 155 || par < 68 || par > 76) {
        		alert('Veuillez remplir tous les champs avec des valeurs valides (Rating: 60-80, Slope: 85-155, Par: 68-76).');
        		return;
        		}
        
        	tees.push({
        		tee: teeColor,
        		rating: rating,
        		slope: slope,
            	par: par
        	});
    	}
    
    	// Si le nom a changé, supprimer l'ancien
    	if (newCourseName !== originalCourseName) {
    		delete coursesDatabase[originalCourseName];
        
        	// Mettre à jour toutes les références dans les parties existantes
        	for (var i = 0; i < courses.length; i++) {
        		if (courses[i] === originalCourseName) {
            		courses[i] = newCourseName;
            	}
        	}
        
        	// Mettre à jour les rounds
        	for (var i = 0; i < rounds.length; i++) {
        		if (rounds[i].course === originalCourseName) {
            		rounds[i].course = newCourseName;
            	}
        	}
    	}
    
    	// Sauvegarder le terrain (nouveau nom ou modifié)
    	coursesDatabase[newCourseName] = tees;
    
		// Sauvegarder dans Firebase
    	Promise.all([
    		saveCoursesToFirebase(),
    		saveDatesToFirebase()
    	]).then(function() {
        	console.log('Terrain modifié dans Firebase');
        	var action = newCourseName !== originalCourseName ? 'renommé et modifié' : 'modifié';
    		alert('✅ Terrain "' + newCourseName + '" ' + action + ' avec succès!');
    		cancelCourseEdit();
			loadCoursesList();
        
    	}).catch(function(error) {
    		console.error('Erreur de modification terrain:', error);
    		alert('Erreur de modification: ' + error.message);
    	});
	}

	// Fermer la popup d'édition
	function cancelCourseEdit() {
    	var popup = document.getElementById('editCoursePopup');
    	if (popup) {
        	popup.remove();
    	}
	}
    function exportCourses() {
        var dataToExport = {
            courses: coursesDatabase,
            exportDate: new Date().toISOString(),
            totalCourses: Object.keys(coursesDatabase).length
        };
            
        var dataStr = JSON.stringify(dataToExport, null, 2);
        var dataBlob = new Blob([dataStr], {type: 'application/json'});
            
        var link = document.createElement('a');
        link.href = URL.createObjectURL(dataBlob);
        link.download = 'terrains-golf-' + new Date().toISOString().split('T')[0] + '.json';
        link.click();
    }

    function saveCourseData() {
        try {
            var dataString = JSON.stringify(coursesDatabase);
            // Simulate saving to storage
            console.log('Courses saved:', Object.keys(coursesDatabase).length + ' terrains');
        } catch (e) {
            console.error('Erreur de sauvegarde:', e);
        }
    }

    // Scores par joueur
    function loadPlayerSelector() {
    	var select = document.getElementById('playerSelect');
    	select.innerHTML = '<option value="">-- Choisir un joueur --</option>';
    
    	for (var i = 0; i < players.length; i++) {
        var player = players[i];
        var option = document.createElement('option');
        option.value = player.id;
        option.textContent = player.name || (player.firstName + ' ' + player.lastName); // CORRECTION
        select.appendChild(option);
    	}
	}

    function showPlayerDetail() {
    	var playerId = parseInt(document.getElementById('playerSelect').value);
    	var container = document.getElementById('playerDetail');
    
    	if (!playerId) {
        container.innerHTML = '';
        return;
    	}
    
    	var player = players.find(p => p.id === playerId);
    	var playerScores = scores.filter(s => s.playerId === playerId);
    
    	if (playerScores.length === 0) {
        container.innerHTML = '<div class="card"><p>Aucun score enregistré pour ce joueur.</p></div>';
        return;
    	}
    
    	var playerName = player.name || (player.firstName + ' ' + player.lastName); // CORRECTION
    
    	// Statistiques du joueur
    	var avgGross = playerScores.reduce((sum, s) => sum + s.score, 0) / playerScores.length;
    	var avgNet = playerScores.reduce((sum, s) => sum + s.net, 0) / playerScores.length;
    	var bestGross = Math.min(...playerScores.map(s => s.score));
    	var worstGross = Math.max(...playerScores.map(s => s.score));
    	var bestNet = Math.min(...playerScores.map(s => s.net));
    	var worstNet = Math.max(...playerScores.map(s => s.net));
    
    	var diabloScores = playerScores.filter(s => s.type === 'diablo');
    	var gprScores = playerScores.filter(s => s.type === 'gpr');
    
    	var html = '<div class="player-card">' +
               	   '<h3>🏌️ ' + playerName + ' (Handicap Index: ' + player.handicap + ')</h3>' +  // UTILISER playerName
               
               	   '<div class="player-stats">' +
                   '<div class="stat-box">' +
           	       '<div class="stat-value">' + playerScores.length + '</div>' +
           	       '<div class="stat-label">Parties Jouées</div>' +
           	       '</div>' +
                   '<div class="stat-box">' +
               	   '<div class="stat-value">' + avgGross.toFixed(1) + '</div>' +
                   '<div class="stat-label">Score Brut Moyen</div>' +
           	       '</div>' +
           	       '<div class="stat-box">' +
           	       '<div class="stat-value">' + avgNet.toFixed(1) + '</div>' +
               	   '<div class="stat-label">Score Net Moyen</div>' +
               	   '</div>' +
                   '<div class="stat-box">' +
           	       '<div class="stat-value">' + bestGross + '</div>' +
           	       '<div class="stat-label">Meilleur Score Brut</div>' +
           	       '</div>' +
               	   '<div class="stat-box">' +
               	   '<div class="stat-value">' + bestNet.toFixed(1) + '</div>' +
                   '<div class="stat-label">Meilleur Score Net</div>' +
           	       '</div>' +
           	       '<div class="stat-box">' +
           	       '<div class="stat-value">' + diabloScores.length + '</div>' +
               	   '<div class="stat-label">Parties Diablo</div>' +
               	   '</div>' +
                   '<div class="stat-box">' +
           	       '<div class="stat-value">' + gprScores.length + '</div>' +
           	       '<div class="stat-label">Parties GPR</div>' +
           	       '</div>' +
               	   '</div>' +
               
               	   '<h4>📋 Historique des Scores</h4>' +
                   '<div class="score-history">';
    
    	// Trier les scores par date (plus récents en premier)
        playerScores.sort((a, b) => {
        var roundA = rounds.find(r => r.id === a.roundId);
        var roundB = rounds.find(r => r.id === b.roundId);
        return new Date(roundB.date) - new Date(roundA.date);
    	});
    
    	for (var i = 0; i < playerScores.length; i++) {
        var score = playerScores[i];
        var round = rounds.find(r => r.id === score.roundId);
        
        var scoreClass = '';
        if (score.score === bestGross) scoreClass = 'best-score';
        else if (score.score === worstGross) scoreClass = 'worst-score';
        
        var badgeClass = score.type === 'diablo' ? 'badge-diablo' : 'badge-gpr';
        var badgeText = score.type === 'diablo' ? '🏆 Diablo' : '🎯 GPR';
        
        var teeIcon = score.tee === 'bleu' ? '🔵' : '⚪';
        
        html += '<div class="score-row">' +
                '<div>' +
                '<strong>' + round.date.split('-').reverse().join('/') + '</strong><br>' +
            	'<small>' + round.course + ' ' + teeIcon + ' ' + score.tee + '</small>' +
            	'</div>' +
            	'<div class="tournament-badge ' + badgeClass + '">' + badgeText + '</div>' +
            	'<div style="text-align: right;">' +
                '<span class="' + scoreClass + '">Brut: ' + score.score + '</span><br>' +
            	'<small>Handicap: ' + score.courseHandicap.toFixed(1) + ' | Net: ' + score.net.toFixed(1) + '</small>' +
            	'</div>' +
            	'</div>';
    	}
    
    	html += '</div></div>';
    	container.innerHTML = html;
	}

        // 1. REMPLACER LA FONCTION loadDiablo() par celle-ci :

	function loadDiablo() {
    	loadYearSelectors();
    
    	var selectedYear = document.getElementById('diabloYearSelect').value;
    
    	var diabloScores = scores.filter(s => {
        	return s.type === 'diablo' && (!selectedYear || s.year == selectedYear);
    	});

    	if (diabloScores.length === 0) {
        	document.getElementById('diabloContent').innerHTML = '<p>Aucune partie Diablo trouvée pour cette période.</p>';
        	document.getElementById('diabloStatus').innerHTML = '';
        	return;
    	}

    	updateDiabloStatus(selectedYear);

    	var playerStats = {};
    
    	for (var i = 0; i < diabloScores.length; i++) {
        	var score = diabloScores[i];
        	if (!playerStats[score.playerId]) {
            	var player = players.find(p => p.id === score.playerId);
            	var playerName = player ? (player.name || (player.firstName + ' ' + player.lastName)) : ('Joueur #' + score.playerId);
            
            	playerStats[score.playerId] = {
                	player: player,
                	playerName: playerName,
                	totalRounds: 0,
                	totalNet: 0
            	};
        	}
        	playerStats[score.playerId].totalRounds++;
        	playerStats[score.playerId].totalNet += score.net;
    	}

    	var leaderboard = [];
    	for (var playerId in playerStats) {
        	var stats = playerStats[playerId];
        	leaderboard.push({
            	player: stats.player,
            	playerName: stats.playerName,
            	rounds: stats.totalRounds,
            	avgNet: stats.totalNet / stats.totalRounds
        	});
    	}

    	leaderboard.sort((a, b) => a.avgNet - b.avgNet);

    	var yearText = selectedYear ? selectedYear : 'Toutes les années';
    	var html = '';
    
    	// === TABLEAU RÉCAPITULATIF DIABLO (existant) ===
    	html += '<div class="card" style="margin-top: 30px;">' +
        	    '<h4>📊 Tableau Récapitulatif - Scores par Partie</h4>' +
            	'<div style="overflow-x: auto;">' +
            	'<table class="table" style="font-size: 12px;">' +
            	'<thead><tr><th>Joueur</th>';

    	var diabloRounds = rounds.filter(r => {
        	return r.type === 'diablo' && (!selectedYear || r.year == selectedYear);
    	});
    
    	diabloRounds.sort((a, b) => new Date(a.date) - new Date(b.date));
    
    	for (var i = 0; i < diabloRounds.length; i++) {
        	var round = diabloRounds[i];
        	var dateStr = round.date.split('-').reverse().join('/');
        	html += '<th style="writing-mode: vertical-rl; text-orientation: mixed; padding: 5px; min-width: 60px;">' + 
            	    dateStr + '</th>';
    	}
    
    	if (selectedYear && diabloRounds.length >= 3) {
        	html += '<th style="background: #8b1a1a !important; color: white !important; font-weight: bold; text-align: center;">Total Diablo</th>';
    	}
    
    	html += '</tr></thead><tbody>';
    	    
    	    // Construire les données pour chaque joueur
    	    var playerDiabloData = {};
    	    
    	    for (var i = 0; i < diabloScores.length; i++) {
        	    var score = diabloScores[i];
        	    if (!playerDiabloData[score.playerId]) {
            	    var player = players.find(p => p.id === score.playerId);
            	    var playerName = player ? (player.name || (player.firstName + ' ' + player.lastName)) : ('Joueur #' + score.playerId);
            	    
            	    playerDiabloData[score.playerId] = {
                	    playerName: playerName,
                	    scores: {},
                	    totalNet: 0,
                	    totalDiff: 0,
                	    gamesPlayed: 0
            	    };
        	    }
        	    
        	    // Calculer le différentiel
        	    var round = rounds.find(r => r.id === score.roundId);
        	    var differential = calculateScoreDifferentialReal(score.score, round.course, score.tee);
        	    
        	    playerDiabloData[score.playerId].scores[score.roundId] = {
            	    score: score.score,
            	    net: score.net,
            	    differential: differential
        	    };
        	    
        	    playerDiabloData[score.playerId].totalNet += score.net;
        	    playerDiabloData[score.playerId].totalDiff += differential || 0;
        	    playerDiabloData[score.playerId].gamesPlayed++;
    	    }
    	    
    	    // Convertir en array et trier
    	    var playersArray = [];
    	    for (var playerId in playerDiabloData) {
        	    playersArray.push({
            	    playerId: parseInt(playerId),
            	    data: playerDiabloData[playerId]
        	    });
    	    }
    	    
    	    // Trier par moyenne net ou total selon l'année
    	    if (selectedYear && diabloRounds.length >= 3) {
        	    // Trier par total des 3 parties - ceux qui n'ont pas joué les 3 parties vont à la fin
        	    playersArray.sort((a, b) => {
            	    // Compter les parties jouées pour l'année
            	    var aPlayed = 0;
            	    var bPlayed = 0;
            	    
            	    for (var i = 0; i < diabloRounds.length; i++) {
                	    if (a.data.scores[diabloRounds[i].id]) aPlayed++;
                	    if (b.data.scores[diabloRounds[i].id]) bPlayed++;
            	    }
            	    
            	    // Si un joueur n'a pas joué toutes les parties, il va à la fin (12e position)
            	    if (aPlayed < diabloRounds.length && bPlayed === diabloRounds.length) return 1;
            	    if (bPlayed < diabloRounds.length && aPlayed === diabloRounds.length) return -1;
            	    
            	    // Sinon, trier par total net
            	    return a.data.totalNet - b.data.totalNet;
        	    });
    	    } else {
        	    // Trier par moyenne
        	    playersArray.sort((a, b) => {
            	    var avgA = a.data.gamesPlayed > 0 ? a.data.totalNet / a.data.gamesPlayed : 999;
            	    var avgB = b.data.gamesPlayed > 0 ? b.data.totalNet / b.data.gamesPlayed : 999;
            	    return avgA - avgB;
        	    });
    	    }
    	    
    	    // Afficher les lignes
    	    for (var p = 0; p < playersArray.length; p++) {
        	    var playerData = playersArray[p];
        	    var data = playerData.data;
        	    
        	    // Style de ligne selon le rang
        	    var rowStyle = '';
        	    if (p === 0) rowStyle = ' style="background: #fff4e6;"'; // Or
        	    else if (p === 1) rowStyle = ' style="background: #f0f0f0;"'; // Argent
        	    else if (p === 2) rowStyle = ' style="background: #fff0e6;"'; // Bronze
        	    
        	    html += '<tr' + rowStyle + '><td><strong>' + (p + 1) + '. ' + data.playerName + '</strong></td>';
        	    
        	    // Scores pour chaque partie
        	    var partiesTotalNet = 0;
        	    var partiesTotalDiff = 0;
        	    var partiesCount = 0;
        	    
        	    for (var i = 0; i < diabloRounds.length; i++) {
            	    var round = diabloRounds[i];
            	    var scoreData = data.scores[round.id];
            	    
            	    if (scoreData) {
                	    // Obtenir le par du terrain
                	    var round = diabloRounds[i];
                	    var coursePar = 72; // Par défaut
                	    if (coursesDatabase[round.course]) {
                    	    var courseData = coursesDatabase[round.course];
                    	    var teeData = courseData.find(t => t.tee === (scoreData.tee || round.tee));
                    	    if (teeData && teeData.par) {
                        	    coursePar = teeData.par;
                    	    }
                	    }
                	    
                	    // Calculer le différentiel (score net - par)
                	    var differential = Math.round(scoreData.net) - coursePar;
                	    var differentialStr = differential > 0 ? '+' + differential : differential.toString();
                	    
                	    html += '<td style="text-align: center;">' +
                    	        '<span style="font-size: 16px; font-weight: bold;">' + differentialStr + '</span> ' +
                    	        '<span style="font-size: 12px;">(' + scoreData.score + ')</span></td>';
                    	        
                	    // Pour le calcul du total Diablo
                	    if (selectedYear) {
                    	    partiesTotalNet += scoreData.net;
                    	    partiesCount++;
                	    }
            	    } else {
                	    html += '<td style="text-align: center; color: #ccc;">-</td>';
            	    }
        	    }
        	    
        	    // Colonne Total si année spécifique et au moins 3 parties
        	    if (selectedYear && diabloRounds.length >= 3) {
            	    if (partiesCount === diabloRounds.length) {
                	    // Calculer le total des pars pour les parties jouées
                	    var totalPar = 0;
                	    var totalScore = 0;
                	    
                	    for (var i = 0; i < diabloRounds.length; i++) {
                    	    var round = diabloRounds[i];
                    	    var scoreData = data.scores[round.id];
                    	    
                    	    if (scoreData) {
                        	    totalScore += scoreData.score;
                        	    
                        	    // Obtenir le par du terrain
                        	    var coursePar = 72; // Par défaut
                        	    if (coursesDatabase[round.course]) {
                            	        var courseData = coursesDatabase[round.course];
                            	        var teeData = courseData.find(t => t.tee === (scoreData.tee || round.tee));
                            	        if (teeData && teeData.par) {
                                	        coursePar = teeData.par;
                            	        }
                        	    }
                        	    totalPar += coursePar;
                    	    }
                	    }
                	    
                	    // Différentiel total (score net total - par total)
                	    var totalDifferential = Math.round(partiesTotalNet) - totalPar;
                	    var totalDiffStr = totalDifferential > 0 ? '+' + totalDifferential : totalDifferential.toString();
                	    
                	    html += '<td style="text-align: center; background: #8b1a1a; color: white;">' +
                    	        '<span style="font-size: 20px; font-weight: bold;">' + totalDiffStr + '</span> ' +
                    	        '<span style="font-size: 14px;">(' + totalScore + ')</span></td>';
            	    } else {
                	    html += '<td style="text-align: center; background: #8b1a1a; color: #999;">-</td>';
            	    }
        	    }
        	    
        	    html += '</tr>';
    	    }
    	    
    	    html += '</tbody></table></div>' +
            		'<div style="margin-top: 10px; font-size: 12px; color: #666;">' +
            		'<strong>Légende:</strong> Score brut (Différentiel) | ' +
            		'Le différentiel mesure la performance relative au parcours' +
            		'</div></div>';
    
    		// === NOUVEAU : DÉTAILS DE CHAQUE PARTIE DIABLO ===
    		html += '<div class="card" style="margin-top: 30px;">' +
            		'<h4>📋 Détails de chaque Partie</h4>';

    		for (var i = 0; i < diabloRounds.length; i++) {
       			var round = diabloRounds[i];
        		var roundScores = scores.filter(s => s.roundId === round.id);
        
        		if (roundScores.length === 0) continue;
        
        		// Obtenir le par du terrain
        		var coursePar = 72; // Par défaut
        		if (coursesDatabase[round.course]) {
            		var courseData = coursesDatabase[round.course];
            		var teeData = courseData.find(t => t.tee === round.tee);
            		if (teeData && teeData.par) {
                		coursePar = teeData.par;
            		}
        		}
        
        		html += '<div style="margin: 15px 0; padding: 15px; border: 2px solid #8b1a1a; border-radius: 10px; background: #fff8f8;">' +
                		'<div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 15px;">' +
                		'<div>' +
                		'<strong style="color: #8b1a1a; font-size: 16px;">🏆 ' + round.date.split('-').reverse().join('/') + ' - ' + round.course + '</strong>' +
                		'<br><small>Départ: ' + round.tee + ' | Par: ' + coursePar + ' | ' + roundScores.length + ' joueurs</small>' +
                		'</div>' +
                		'<button class="btn-secondary" onclick="toggleDiabloRoundDetail(\'diablo_round_' + round.id + '\')">👁️ Voir/Masquer</button>' +
                		'</div>';

        		html += '<div id="diablo_round_' + round.id + '" style="display: block;">' +
                		'<table class="table" style="font-size: 13px;">' +
                		'<thead>' +
                		'<tr style="background: #8b1a1a; color: white;">' +
                		'<th>Pos</th>' +
                		'<th>Joueur</th>' +
                		'<th>Score Brut</th>' +
                		'<th>Diff. Brut</th>' +
                		'<th>Hcp Parcours</th>' +
                		'<th>Score Net</th>' +
                		'<th>Diff. Net</th>' +
                		'<th>Différentiel</th>' +
                		'</tr>' +
                		'</thead>' +
                		'<tbody>';
        
        		// Trier par score net
        		roundScores.sort((a, b) => a.net - b.net);
        
        		for (var j = 0; j < roundScores.length; j++) {
            		var score = roundScores[j];
            
            		// Calculer les différentiels
            		var brutDiff = score.score - coursePar;
            		var netDiff = Math.round(score.net) - coursePar;
            		var differential = calculateScoreDifferentialReal(score.score, round.course, score.tee);
            
            		// Style pour le podium
            		var rowStyle = '';
            		if (j === 0) rowStyle = ' style="background: #fff4e6;"'; // Or
            		else if (j === 1) rowStyle = ' style="background: #f0f0f0;"'; // Argent
            		else if (j === 2) rowStyle = ' style="background: #fff0e6;"'; // Bronze
            
            		// Formatage des différentiels
            		var brutDiffStr = brutDiff > 0 ? '+' + brutDiff : brutDiff.toString();
            		var netDiffStr = netDiff > 0 ? '+' + netDiff : netDiff.toString();
            		var diffStr = differential ? differential.toFixed(1) : 'N/A';
            
            		// Icône selon la position
            		var posIcon = '';
            		if (j === 0) posIcon = '🥇 ';
            		else if (j === 1) posIcon = '🥈 ';
            		else if (j === 2) posIcon = '🥉 ';
            
            		html += '<tr' + rowStyle + '>' +
                    		'<td><strong>' + posIcon + (j + 1) + '</strong></td>' +
                    		'<td><strong>' + score.playerName + '</strong></td>' +
                    		'<td style="text-align: center; font-weight: bold;">' + score.score + '</td>' +
                    		'<td style="text-align: center; color: ' + (brutDiff < 0 ? '#28a745' : brutDiff > 0 ? '#dc3545' : '#333') + ';">' +
                    		'<strong>' + brutDiffStr + '</strong></td>' +
                    		'<td style="text-align: center;">' + score.courseHandicap.toFixed(1) + '</td>' +
                    		'<td style="text-align: center; font-weight: bold; color: #8b1a1a;">' + Math.round(score.net) + '</td>' +
                    		'<td style="text-align: center; color: ' + (netDiff < 0 ? '#28a745' : netDiff > 0 ? '#dc3545' : '#333') + ';">' +
                    		'<strong>' + netDiffStr + '</strong></td>' +
                    		'<td style="text-align: center;">' + diffStr + '</td>' +
                    		'</tr>';
        		}
        
        		html += '</tbody></table>';
        
        		// Statistiques de la partie
        		var avgBrut = roundScores.reduce((sum, s) => sum + s.score, 0) / roundScores.length;
        		var avgNet = roundScores.reduce((sum, s) => sum + s.net, 0) / roundScores.length;
        		var bestBrut = Math.min(...roundScores.map(s => s.score));
        		var bestNet = Math.min(...roundScores.map(s => s.net));
        
        		html += '<div style="margin-top: 10px; padding: 10px; background: #ffe8e8; border-radius: 5px; font-size: 12px;">' +
                		'<strong>📊 Statistiques de la partie:</strong><br>' +
                		'<div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(150px, 1fr)); gap: 10px; margin-top: 5px;">' +
                		'<div>🏌️ Meilleur brut: <strong>' + bestBrut + '</strong></div>' +
                		'<div>🎯 Meilleur net: <strong>' + Math.round(bestNet) + '</strong></div>' +
                		'<div>📈 Moyenne brut: <strong>' + avgBrut.toFixed(1) + '</strong></div>' +
                		'<div>📊 Moyenne net: <strong>' + avgNet.toFixed(1) + '</strong></div>' +
                		'</div>' +
                		'</div>';
        
        		html += '</div></div>';
    		}
    
    		// Statistiques globales du tournoi
    		if (diabloRounds.length > 0) {
        		html += '<div style="margin-top: 20px; padding: 15px; background: #8b1a1a; color: white; border-radius: 8px;">' +
                		'<h5 style="margin: 0 0 10px 0;">🏆 Résumé du Tournoi Diablo ' + yearText + '</h5>' +
                		'<div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(200px, 1fr)); gap: 15px;">' +
                		'<div>📅 Nombre de parties: <strong>' + diabloRounds.length + '</strong></div>' +
                		'<div>👥 Participants uniques: <strong>' + leaderboard.length + '</strong></div>' +
                		'<div>🥇 Leader actuel: <strong>' + (leaderboard[0] ? leaderboard[0].playerName : 'N/A') + '</strong></div>' +
                		'<div>🎯 Meilleur moyenne net: <strong>' + (leaderboard[0] ? leaderboard[0].avgNet.toFixed(1) : 'N/A') + '</strong></div>' +
                		'</div>' +
                		'</div>';
    		}
    
    		html += '</div>';
    
    		document.getElementById('diabloContent').innerHTML = html;
		}

		// Fonction pour afficher/masquer les détails d'une partie Diablo
		function toggleDiabloRoundDetail(roundId) {
    		var element = document.getElementById(roundId);
    		if (element.style.display === 'none') {
        		element.style.display = 'block';
    		} else {
        		element.style.display = 'none';
    		}
		}

	// FONCTION loadGPR
	function loadGPR() {
	    loadYearSelectors();
    	console.log('=== DÉBUT loadGPR ===');

    	// DÉCLARER TOUTES LES VARIABLES AU DÉBUT DE LA FONCTION
    	playerPoints = {};
    	playerBest4Points = {};
    	roundDetails = [];

    	var selectedYear = document.getElementById('gprYearSelect').value;

    	var gprScores = scores.filter(s => {
        	return s.type === 'gpr' && (!selectedYear || s.year == selectedYear);
    	});

    	if (gprScores.length === 0) {
        	document.getElementById('gprContent').innerHTML = '<p>Aucune partie GPR trouvée pour cette période.</p>';
        	document.getElementById('gprStatus').innerHTML = '';
        	return;
    	}

    	updateGPRStatus(selectedYear);

    	var gprRounds = rounds.filter(r => {
        	return r.type === 'gpr' && (!selectedYear || r.year == selectedYear);
    	});
    
    	console.log('=== FILTRAGE PAR ANNÉE ===');
    	console.log('Année sélectionnée:', selectedYear);
    	console.log('Scores GPR trouvés:', gprScores.length);

    	// Séparer les parties Exhibition et Finale
    	var exhibitionRounds = gprRounds.filter(r => !r.gprPhase || r.gprPhase === 'exhibition');
    	var finaleRounds = gprRounds.filter(r => r.gprPhase === 'finale');
    
    	// Pour le tableau récapitulatif, on veut TOUTES les finales si "Toutes les années"
    	var allFinaleRoundsForTable = finaleRounds;
    	if (!selectedYear) {
        	// Si "Toutes les années", prendre toutes les finales GPR
        	allFinaleRoundsForTable = rounds.filter(r => 
            	r.type === 'gpr' && 
            	r.gprPhase === 'finale'
        	);
    	}
    
    	console.log('Finales pour le tableau:', allFinaleRoundsForTable.length);
    	console.log('=== SÉPARATION DES ROUNDS GPR ===');
    	console.log('Total rounds GPR:', gprRounds.length);
    	console.log('Rounds exhibition:', exhibitionRounds.length);
    	console.log('Rounds finale:', finaleRounds.length);

    	// IMPORTANT : Filtrer pour avoir SEULEMENT les vraies exhibitions (pas les finales)
    	exhibitionRounds = exhibitionRounds.filter(r => r.gprPhase !== 'finale');
    	console.log('Rounds exhibition après filtrage:', exhibitionRounds.length);

    	// === TRAITEMENT DES PARTIES EXHIBITION ===
    	var pointsScale = [120, 105, 90, 78, 70, 62, 54, 46, 38, 30, 22, 15];
    	var grossPointsScale = [80, 68, 60, 52, 45, 40, 35, 30, 25, 20, 15, 10];

    	// Points pour les finales
    	var finaleNetPointsScale = [225, 190, 165, 140, 125, 110, 90, 75, 60, 45, 35, 25];
    	var finaleBrutPointsScale = [175, 140, 120, 100, 85, 70, 60, 50, 40, 30, 20, 10];

    	for (var i = 0; i < exhibitionRounds.length; i++) {
        	var round = exhibitionRounds[i];
        	var roundScores = gprScores.filter(s => s.roundId === round.id && s.playerId !== 13);

        	// Identifier TOUS les joueurs GPR de l'année (pour les absents)
        	var allGPRPlayers = scores.filter(s => 
            	s.year === round.year && 
            	s.type === 'gpr' && 
            	s.playerId !== 13
        	).map(s => s.playerId).filter((v, i, a) => a.indexOf(v) === i);

        	// Ajouter les absents avec score fictif élevé
        	var presentPlayers = roundScores.map(s => s.playerId);
        	for (var p = 0; p < allGPRPlayers.length; p++) {
            	var playerId = allGPRPlayers[p];
            	if (!presentPlayers.includes(playerId)) {
                	var player = players.find(p => p.id === playerId);
                	// Ajouter un score fictif pour l'absent
                	roundScores.push({
                    	playerId: playerId,
                    	playerName: player.name || (player.firstName + ' ' + player.lastName),
                    	score: 999, // Score très élevé
                    	net: 999,   // Net très élevé
                    	absent: true
                	});
            	}
        	}

        	console.log('Partie du', round.date, '- Joueurs:', roundScores.length, '(dont absents)');

        	// Classement par score net avec gestion des ex-æquo
        	var netGroups = {};
        	roundScores.forEach(function(score, index) {
            	var netValue = score.net;
            	if (!netGroups[netValue]) {
                	netGroups[netValue] = [];
            	}
            	netGroups[netValue].push({score: score, originalIndex: index});
        	});

        	// Trier les groupes
        	var sortedNetGroups = Object.keys(netGroups).sort((a, b) => parseFloat(a) - parseFloat(b));

        	var netRanking = [];
        	var currentPosition = 0;

        	for (var g = 0; g < sortedNetGroups.length; g++) {
            	var group = netGroups[sortedNetGroups[g]];
            	var totalPoints = 0;

            	// Calculer les points totaux pour ce groupe
            	for (var j = 0; j < group.length; j++) {
                	totalPoints += pointsScale[Math.min(currentPosition + j, pointsScale.length - 1)];
            	}

            	var pointsPerPlayer = Math.round(totalPoints / group.length);

            	// Attribuer les points
            	for (var j = 0; j < group.length; j++) {
                	netRanking.push({
                    	player: group[j].score,
                    	position: currentPosition + 1,
                    	points: pointsPerPlayer
                	});
            	}

            	currentPosition += group.length;
        	}

        	// Faire la même chose pour le classement brut
        	var grossGroups = {};
        	roundScores.forEach(function(score, index) {
            	var grossValue = score.score;
            	if (!grossGroups[grossValue]) {
                	grossGroups[grossValue] = [];
            	}
            	grossGroups[grossValue].push({score: score, originalIndex: index});
        	});

        	var sortedGrossGroups = Object.keys(grossGroups).sort((a, b) => parseFloat(a) - parseFloat(b));

        	var grossRanking = [];
        	currentPosition = 0;

        	for (var g = 0; g < sortedGrossGroups.length; g++) {
            	var group = grossGroups[sortedGrossGroups[g]];
            	var totalPoints = 0;

            	for (var j = 0; j < group.length; j++) {
                	totalPoints += grossPointsScale[Math.min(currentPosition + j, grossPointsScale.length - 1)];
            	}

            	var pointsPerPlayer = Math.round(totalPoints / group.length);

            	for (var j = 0; j < group.length; j++) {
                	grossRanking.push({
                    	player: group[j].score,
                    	position: currentPosition + 1,
                    	points: pointsPerPlayer
                	});
            	}

            	currentPosition += group.length;
        	}

        	// CRÉER LE ROUNDDETAIL
        	var roundDetail = {
            	round: round,
            	netRanking: netRanking,
            	grossRanking: grossRanking,
            	isExhibition: true,
            	isFinale: false
        	};

        	roundDetails.push(roundDetail);

        	// ACCUMULER LES POINTS POUR CHAQUE JOUEUR
        	for (var k = 0; k < roundScores.length; k++) {
            	var score = roundScores[k];

            	// Ne pas Ignorer les absents - ils doivent recevoir leur points!
                    
            	if (!playerPoints[score.playerId]) {
                	var player = players.find(p => p.id === score.playerId);
                	var playerName = player ? (player.name || (player.firstName + ' ' + player.lastName)) : ('Joueur #' + score.playerId);

                	playerPoints[score.playerId] = {
                    	player: player,
                    	playerName: playerName,
                    	totalPoints: 0,
                    	rounds: 0,
                    	exhibitionPoints: 0,
                    	finalePoints: 0,
                    	details: []
                	};
            	}

            	if (!playerBest4Points[score.playerId]) {
                	var player = players.find(p => p.id === score.playerId);
                	var playerName = player ? (player.name || (player.firstName + ' ' + player.lastName)) : ('Joueur #' + score.playerId);

                	playerBest4Points[score.playerId] = {
                    	player: player,
                    	playerName: playerName,
                    	best4Points: 0,
                    	finalePoints: 0,
                    	totalBest4: 0,
                    	best4Details: []
                	};
            	}

            	// Trouver les points pour ce joueur dans cette partie
            	var netResult = netRanking.find(r => r.player.playerId === score.playerId);
            	var grossResult = grossRanking.find(r => r.player.playerId === score.playerId);

            	var netPoints = netResult ? netResult.points : 0;
            	var grossPoints = grossResult ? grossResult.points : 0;
            	var totalRoundPoints = netPoints + grossPoints;

            	playerPoints[score.playerId].totalPoints += totalRoundPoints;
            	playerPoints[score.playerId].exhibitionPoints += totalRoundPoints;
            	playerPoints[score.playerId].rounds++;

            	// Stocker les détails de cette partie exhibition
            	playerPoints[score.playerId].details.push({
                	round: round,
                	grossScore: score.score,
                	netScore: score.net,
                	grossPosition: grossResult ? grossResult.position : '-',
                	netPosition: netResult ? netResult.position : '-',
                	grossPoints: grossPoints,
                	netPoints: netPoints,
                	totalRoundPoints: totalRoundPoints,
                	courseHandicap: score.courseHandicap,
                	type: 'exhibition'
            	});
        	}
    	} // FIN DE LA BOUCLE DES EXHIBITIONS

    	// === CALCUL DES 4 MEILLEURES PARTIES ===
		var yearToCalculate = selectedYear ? parseInt(selectedYear) : new Date().getFullYear();
		console.log('Année pour calcul best4:', yearToCalculate, 'Type:', typeof yearToCalculate);
    	console.log('=== DEBUG CALCUL FINALE ===');
    	console.log('Année pour calcul finale:', yearToCalculate);
    	console.log('Type de yearToCalculate:', typeof yearToCalculate);
    	console.log('selectedYear:', selectedYear, 'type:', typeof selectedYear);
    
    	// DEBUG: Vérifier les finales
    	console.log('=== DEBUG FINALES ===');
    	console.log('Année calculée:', yearToCalculate);
    	var testFinaleRounds = rounds.filter(r => r.year === yearToCalculate && r.gprPhase === 'finale');
    	console.log('Parties finale trouvées:', testFinaleRounds);
    
    	for (var playerId in playerPoints) {
    		var playerIdInt = parseInt(playerId);
    
    		// S'assurer que playerBest4Points[playerId] existe
    		if (!playerBest4Points[playerId]) {
        		var player = players.find(p => p.id === playerIdInt);
        		playerBest4Points[playerId] = {
            		player: player,
            		playerName: player.name || (player.firstName + ' ' + player.lastName),
            		best4Points: 0,
            		finalePoints: 0,
            		totalBest4: 0,
            		best4Details: []
        		};
    		}
    
    		// Calculer les 4 meilleures exhibitions
    		var yearForCalculation = selectedYear ? parseInt(selectedYear) : new Date().getFullYear();
    		var best4Results = calculateBest4Exhibition(playerIdInt, yearForCalculation);
    
    		console.log('Calcul best4 pour joueur', playerId, 'année', yearForCalculation, ':', best4Results.length, 'parties');
    
    		var best4Total = 0;
    		playerBest4Points[playerId].best4Details = []; // Réinitialiser
    
    		for (var i = 0; i < best4Results.length; i++) {
        		best4Total += best4Results[i].totalPoints;
        
        		playerBest4Points[playerId].best4Details.push({
            		round: rounds.find(r => r.id === best4Results[i].roundId),
            		grossScore: best4Results[i].score.score,
            		netScore: best4Results[i].score.net,
            		grossPosition: best4Results[i].brutPos,
            		netPosition: best4Results[i].netPos,
            		grossPoints: best4Results[i].brutPoints,
            		netPoints: best4Results[i].netPoints,
            		totalRoundPoints: best4Results[i].totalPoints,
            		isSelected: true,
            		roundId: best4Results[i].roundId // Ajouter l'ID pour faciliter la vérification
        		});
    		}
    
    		playerBest4Points[playerId].best4Points = best4Total;
    		playerBest4Points[playerId].totalBest4 = best4Total;
    
    		console.log('Best4 total pour', playerBest4Points[playerId].playerName, ':', best4Total);
		}

    	// === TRAITEMENT DES FINALES (400 POINTS FIXES) ===
    	if (finaleRounds.length > 0) {
        	var finaleResults = calculateFinaleScores(yearToCalculate);

        	// Ajouter les points finale aux totaux des joueurs
        	for (var playerId in finaleResults) {
            	var finaleData = finaleResults[playerId];

            	if (!playerPoints[playerId]) {
                	playerPoints[playerId] = {
                    	player: finaleData.player,
                    	playerName: finaleData.player.name || (finaleData.player.firstName + ' ' + finaleData.player.lastName),
                    	totalPoints: 0,
                    	rounds: 0,
                    	exhibitionPoints: 0,
                    	finalePoints: 0,
                    	details: []
                	};
            	}

            	if (!playerBest4Points[playerId]) {
                	playerBest4Points[playerId] = {
                    	player: finaleData.player,
                    	playerName: finaleData.player.name || (finaleData.player.firstName + ' ' + finaleData.player.lastName),
                    	best4Points: 0,
                    	finalePoints: 0,
                    	totalBest4: 0,
                    	best4Details: []
                	};
            	}

            	// Les points finale sont déjà corrects (400 points total)
            	var finalePoints = finaleData.totalPointsFinale || 0;
            	console.log('=== DEBUG MULTIPLICATION ===');
            	console.log('Joueur:', finaleData.player.name);
            	console.log('finaleData.totalPointsFinale:', finaleData.totalPointsFinale);
            	console.log('finaleData.daysPlayed:', finaleData.daysPlayed);
            	console.log('finalePoints utilisés:', finalePoints);

            	console.log('Joueur', finaleData.player.name, 'Points finale:', finalePoints);

            	playerPoints[playerId].totalPoints += finalePoints;
            	playerPoints[playerId].finalePoints = finalePoints;

            	playerBest4Points[playerId].finalePoints = finalePoints;
            	playerBest4Points[playerId].totalBest4 += finalePoints;

            	// Ajouter détail finale
            	var finaleDetail = {
                	type: 'finale',
                	totalBrut: finaleData.totalBrut,
                	totalNet: finaleData.totalNet,
                	daysPlayed: finaleData.daysPlayed,
                	brutPosition: finaleData.positionBrut,
                	netPosition: finaleData.positionNet,
                	brutPoints: finaleData.pointsBrut,
                	netPoints: finaleData.pointsNet,
               		totalRoundPoints: finalePoints,
                	absent: finaleData.daysPlayed === 0
            	};

            	playerPoints[playerId].details.push(finaleDetail);
        	}

        	// Debug
        	console.log('=== VÉRIFICATION FINALE GPR ===');
        	var totalPointsDistribues = 0;
        	for (var playerId in finaleResults) {
            	totalPointsDistribues += finaleResults[playerId].totalPointsFinale || 0;
        	}
        	console.log('Total points finale distribués:', totalPointsDistribues);

        	// Debug pour voir qui manque
        	console.log('=== DEBUG JOUEURS MANQUANTS ===');
        	for (var playerId in finaleResults) {
            	if (!playerPoints[playerId]) {
                	console.log('Joueur manquant dans playerPoints:', playerId, finaleResults[playerId].player.name);
            	}
        	}

        	// Ajouter les joueurs qui ont SEULEMENT des points de finale (absents à toutes les exhibitions)
        	for (var playerId in finaleResults) {
            	if (!playerPoints[playerId]) {
                	var finaleData = finaleResults[playerId];

                	playerPoints[playerId] = {
                    	player: finaleData.player,
                    	playerName: finaleData.player.name || (finaleData.player.firstName + ' ' + finaleData.player.lastName),
                    	totalPoints: 0,
                    	rounds: 0,
                    	exhibitionPoints: 0,
                    	finalePoints: 0,
                    	details: []
                	};

                	console.log('Ajout joueur absent exhibitions:', playerPoints[playerId].playerName);
            	}

            	if (!playerBest4Points[playerId]) {
                	var finaleData = finaleResults[playerId];

                	playerBest4Points[playerId] = {
                    	player: finaleData.player,
                    	playerName: finaleData.player.name || (finaleData.player.firstName + ' ' + finaleData.player.lastName),
                    	best4Points: 0,
                    	finalePoints: 0,
                    	totalBest4: 0,
                    	best4Details: []
                	};
            	}
        	}
    	}

    	// Créer les classements
    	var leaderboardComplete = [];
    	var leaderboardBest4 = [];

    	for (var playerId in playerPoints) {
        	var stats = playerPoints[playerId];
        	leaderboardComplete.push({
            	player: stats.player,
            	playerName: stats.playerName,
            	rounds: stats.rounds,
            	totalPoints: stats.totalPoints,
            	exhibitionPoints: stats.exhibitionPoints,
            	finalePoints: stats.finalePoints,
            	details: stats.details,
            	averagePoints: stats.rounds > 0 ? stats.totalPoints / stats.rounds : 0
        	});
    	}

    	for (var playerId in playerBest4Points) {
        	var stats = playerBest4Points[playerId];
        	leaderboardBest4.push({
            	player: stats.player,
            	playerName: stats.playerName,
            	best4Points: stats.best4Points,
            	finalePoints: stats.finalePoints,
            	totalBest4: stats.totalBest4,
            	best4Details: stats.best4Details,
            	partiesCount: stats.best4Details.length
        	});
    	}

    	leaderboardComplete.sort((a, b) => b.totalPoints - a.totalPoints);
    	leaderboardBest4.sort((a, b) => b.totalBest4 - a.totalBest4);

    	var yearText = selectedYear ? selectedYear : 'Toutes les années';

    	// Affichage du classement général
    	var html = '<div class="card"><h3>Coupe GPR - ' + yearText
        	       
    	// === TABLEAU RÉCAPITULATIF DES POINTS PAR PARTIE ===
    	html += '<div class="card">' +
        	    '<h4>📊 Tableau Récapitulatif - Points par Partie</h4>' +
            	'<p style="font-size: 14px; color: #666;">Les 4 meilleures parties d\'exhibition sont marquées d\'une ⭐</p>' +
            	'<div style="overflow-x: auto;">' +
            	'<table class="table" style="font-size: 12px;">' +
            	'<thead><tr><th>Joueur</th>';

    	// Combiner toutes les parties (exhibitions + finales) et trier par date
    	var allGameRounds = [];
    	
    	// Ajouter les exhibitions
    	for (var i = 0; i < exhibitionRounds.length; i++) {
        	var round = exhibitionRounds[i];
        	allGameRounds.push({
            	round: round,
            	type: 'exhibition',
            	date: round.date,
            	dateObj: new Date(round.date)
        	});
    	}
    	
    	// Ajouter les finales
    	for (var i = 0; i < allFinaleRoundsForTable.length; i++) {
        	var finaleRound = allFinaleRoundsForTable[i];
        	allGameRounds.push({
            	round: finaleRound,
            	type: 'finale',
            	date: finaleRound.date,
            	dateObj: new Date(finaleRound.date)
        	});
    	}
    	
    	// Trier par date chronologique
    	allGameRounds.sort((a, b) => a.dateObj - b.dateObj);

    	// En-têtes des colonnes (toutes les parties par ordre chronologique)
		for (var i = 0; i < allGameRounds.length; i++) {
    		var gameRound = allGameRounds[i];
    		var dateStr = gameRound.date.split('-').reverse().join('/');
    
    		if (gameRound.type === 'finale') {
        		var year = gameRound.round.year;
        		html += '<th style="background: #1e3a8a; color: white; font-weight: bold; text-align: center; padding: 8px;">Finale ' + year + '<br>' + dateStr + '</th>';
    		} else {
        		html += '<th style="writing-mode: vertical-rl; text-orientation: mixed; padding: 5px; min-width: 60px;">' + dateStr + '</th>';
    		}
		}

		// Ajouter les colonnes Best4 et Total SEULEMENT si une année spécifique est sélectionnée
		if (selectedYear) {
    		html += '<th style="background: #ff6b35; color: white; font-weight: bold; text-align: center;">Best 4</th>';
    		html += '<th style="background: #8b1a1a; color: white; font-weight: bold; text-align: center;">Total</th>';
		}

		html += '</tr></thead><tbody>';

    	// Trier les joueurs par total de points décroissant
    	var allPlayers = Object.keys(playerPoints).map(id => ({
        	id: parseInt(id),
        	data: playerPoints[id],
        	best4Data: playerBest4Points[id]
    	}));
    	
    	// Trier selon que c'est une année spécifique ou toutes les années
    	if (selectedYear) {
        	// Pour une année spécifique, trier par Best4 + Finale
        	allPlayers.sort((a, b) => {
            	var totalA = (a.best4Data ? (a.best4Data.best4Points + a.best4Data.finalePoints) : 0);
            	var totalB = (b.best4Data ? (b.best4Data.best4Points + b.best4Data.finalePoints) : 0);
            	return totalB - totalA;
        	});
    	} else {
        	// Pour toutes les années, trier par total de tous les points
        	allPlayers.sort((a, b) => b.data.totalPoints - a.data.totalPoints);
    	}

    	// Lignes pour chaque joueur
    	for (var p = 0; p < allPlayers.length; p++) {
        	var playerData = allPlayers[p];
        	var playerId = playerData.id;
        	var player = playerData.data;
        	var best4Info = playerData.best4Data;

        	// Style de ligne selon le rang
        	var rowStyle = '';
        	if (p === 0) rowStyle = ' style="background: #fff4e6;"'; // Or
        	else if (p === 1) rowStyle = ' style="background: #f0f0f0;"'; // Argent
        	else if (p === 2) rowStyle = ' style="background: #fff0e6;"'; // Bronze

        	html += '<tr' + rowStyle + '><td><strong>' + (p + 1) + '. ' + player.playerName + '</strong></td>';

        	// Points pour chaque partie dans l'ordre chronologique
			for (var i = 0; i < allGameRounds.length; i++) {
    			var gameRound = allGameRounds[i];
    
    			if (gameRound.type === 'exhibition') {
        			// Traitement des parties exhibition
        			var round = gameRound.round;
        			var roundDetail = roundDetails.find(rd => rd.round.id === round.id);

        			// Chercher si le joueur a participé
        			var netResult = roundDetail ? roundDetail.netRanking.find(r => r.player.playerId === playerId) : null;
        			var grossResult = roundDetail ? roundDetail.grossRanking.find(r => r.player.playerId === playerId) : null;

        			if (netResult || grossResult) {
            			var netPts = netResult ? netResult.points : 0;
            			var grossPts = grossResult ? grossResult.points : 0;
            			var total = Math.round(netPts + grossPts);
            			var isAbsent = netResult && netResult.player.absent;
    
            			// Style pour les absents
            			var cellStyle = 'text-align: center;';
            			if (isAbsent) {
                			cellStyle += ' font-style: italic; color: #999;';
            			}
    
            			// Afficher les étoiles et barrés SEULEMENT si une année est sélectionnée
            			if (selectedYear) {
                			// Vérifier si cette partie fait partie des 4 meilleures
                			var isBest4 = false;
                			var best4Info = playerBest4Points[playerId];
        
                			if (best4Info && best4Info.best4Details) {
                    			isBest4 = best4Info.best4Details.some(detail => 
                        			detail.roundId === round.id
                    			);
                			}
        
                			// Barrer si plus de 4 parties et pas dans best4
                			if (!isAbsent && best4Info && best4Info.best4Details.length >= 4 && !isBest4) {
                    			cellStyle += ' text-decoration: line-through; color: #ccc;';
                			}
        
                			html += '<td style="' + cellStyle + '">' + 
                        			(isBest4 ? '⭐ ' : '') + total + 
                        			'<br><small>(' + Math.round(grossPts) + '+' + Math.round(netPts) + ')</small></td>';
            			} else {
                			// Pas d'étoiles ni de barrés pour "Toutes les années"
                			html += '<td style="' + cellStyle + '">' + 
                        			total + 
                        			'<br><small>(' + Math.round(grossPts) + '+' + Math.round(netPts) + ')</small></td>';
            			}
        			} else {
            			html += '<td style="text-align: center; color: #ccc;">-</td>';
        			}
    
    			} else if (gameRound.type === 'finale') {
        			// Traitement des parties finale
        			var finaleRound = gameRound.round;
        			var year = finaleRound.year;

        			// Chercher les points de cette année de finale
        			var finaleDetail = player.details.find(d => 
            			d.type === 'finale' && 
            			rounds.find(r => r.year == year && r.gprPhase === 'finale')
        			);

        			if (finaleDetail && finaleRound.year == year) {
            			var brutPts = Math.round(finaleDetail.brutPoints || 0);
            			var netPts = Math.round(finaleDetail.netPoints || 0);
            			// Pour finale multi-jours, diviser par le nombre de jours
            			var nbJoursFinale = allFinaleRoundsForTable.filter(r => r.year == year).length;
            			var totalPts = Math.round((finaleDetail.brutPoints + finaleDetail.netPoints) / nbJoursFinale);

            			html += '<td style="text-align: center; background: #1e3a8a; color: white; font-size: 16px; font-weight: bold;' + 
                    			(finaleDetail.absent ? ' font-style: italic; opacity: 0.7;' : '') + '">' +
                    			totalPts + '<br>' +
                    			'<small style="color: #cbd5e1; font-weight: normal;">(' + Math.round(brutPts/nbJoursFinale) + '+' + Math.round(netPts/nbJoursFinale) + ')</small></td>';
        			} else {
            			html += '<td style="text-align: center; background: #1e3a8a; color: #64748b; font-size: 16px; font-weight: bold;">-</td>';
        			}
    			}
			}

			// Afficher Best4 et Total SEULEMENT si une année spécifique est sélectionnée
			if (selectedYear) {
    			// Total Best 4
    			var playerBest4Info = playerBest4Points[playerId];
    			var best4Points = playerBest4Info ? playerBest4Info.best4Points : 0;
    			var finalePoints = playerBest4Info ? playerBest4Info.finalePoints : 0;
    			
    			html += '<td style="text-align: center; background: #ff6b35; color: white; font-size: 16px; font-weight: bold;">' + 
            			Math.round(best4Points) + '</td>';
    
    			// Total FINAL = Best 4 + Finale (c'est ce qui détermine le vainqueur)
    			var totalFinal = best4Points + finalePoints;
    			html += '<td style="text-align: center; background: #8b1a1a; color: white; font-size: 16px; font-weight: bold;">' + 
            			Math.round(totalFinal) + '</td>';
			}

			html += '</tr>';
    	}

    	html += '</tbody></table></div>' +
        	    '<div style="margin-top: 10px; font-size: 12px; color: #666;">' +
            	'<strong>Légende:</strong> Total (Brut+Net) | <em>Italique = Absent</em>' +
				(selectedYear ? ' | ⭐ = Compte dans les 4 meilleures | <s>Barré</s> = Ne compte pas' : '') +
            	'</div></div>';

    	// Affichage des parties individuelles
    	html += '<div class="card">' +
        	    '<h4>📅 Détails de chaque Partie</h4>';

    	for (var i = 0; i < roundDetails.length; i++) {
        	var roundDetail = roundDetails[i];
        	var round = roundDetail.round;

        	html += '<div style="margin: 15px 0; padding: 15px; border: 1px solid #ddd; border-radius: 8px; background: #f9f9f9;">' +
            	    '<div style="display: flex; justify-content: space-between; align-items: center;">' +
                	'<div>' +
                	'<strong>' + round.date.split('-').reverse().join('/') + ' - ' + round.course + ' (Exhibition)</strong>' +
                	'<br><small>' + roundDetail.netRanking.length + ' joueurs</small>' +
                	'</div>' +
                	'<button class="btn" onclick="toggleRoundDetail(\'round_' + round.id + '\')">👁️ Voir classements</button>' +
                	'</div>' +

                	'<div id="round_' + round.id + '" style="display: none; margin-top: 15px;">' +
                	'<div style="display: grid; grid-template-columns: 1fr 1fr; gap: 20px;">' +

                	// Classement net
                	'<div>' +
                	'<h5>🎯 Classement Score Net</h5>' +
                	'<table class="table" style="font-size: 14px;">' +
                	'<thead><tr><th>Pos</th><th>Joueur</th><th>Score Net</th><th>Points</th></tr></thead>' +
                	'<tbody>';

        	for (var j = 0; j < roundDetail.netRanking.length; j++) {
            	var result = roundDetail.netRanking[j];
            	var playerScore = result.player;

            	html += '<tr>' +
                	    '<td><strong>' + result.position + '</strong></td>' +
                    	'<td>' + playerScore.playerName + '</td>' +
                    	'<td><strong>' + (playerScore.net ? playerScore.net.toFixed(1) : 'N/A') + '</strong></td>' +
                    	'<td><span style="background: #28a745; color: white; padding: 2px 6px; border-radius: 10px;">' + result.points + '</span></td>' +
                    	'</tr>';
        	}

        	html += '</tbody></table></div>' +

            	    // Classement brut
                	'<div>' +
                	'<h5>🏌️ Classement Score Brut</h5>' +
                	'<table class="table" style="font-size: 14px;">' +
                	'<thead><tr><th>Pos</th><th>Joueur</th><th>Score Brut</th><th>Points</th></tr></thead>' +
                	'<tbody>';

        	for (var j = 0; j < roundDetail.grossRanking.length; j++) {
            	var result = roundDetail.grossRanking[j];
            	var playerScore = result.player;

            	html += '<tr>' +
                	    '<td><strong>' + result.position + '</strong></td>' +
                    	'<td>' + playerScore.playerName + '</td>' +
                    	'<td><strong>' + playerScore.score + '</strong></td>' +
                    	'<td><span style="background: #17a2b8; color: white; padding: 2px 6px; border-radius: 10px;">' + result.points + '</span></td>' +
                		'</tr>';
    		}

    		html += '</tbody></table></div>' +
            		'</div></div></div>';
		}

		html += '</div>';
		document.getElementById('gprContent').innerHTML = html;
	}

	// 2. FONCTION POUR AFFICHER/MASQUER LES DÉTAILS D'UNE PARTIE
	function toggleRoundDetail(roundId) {
    	    var element = document.getElementById(roundId);
    	    if (element.style.display === 'none') {
        	element.style.display = 'block';
    	    } else {
        	element.style.display = 'none';
    	    }
	}

	// 3. FONCTION POUR AFFICHER LES DÉTAILS D'UN JOUEUR GPR
	function showGPRPlayerDetails(playerId, selectedYear) {
    	    var gprScores = scores.filter(s => {
        	return s.type === 'gpr' && s.playerId === playerId && (!selectedYear || s.year == selectedYear);
    	    });
    
    	    if (gprScores.length === 0) {
        	alert('Aucune partie GPR trouvée pour ce joueur.');
        	return;
    	    }
    
    	    var player = players.find(p => p.id === playerId);
    	    var playerName = player ? (player.name || (player.firstName + ' ' + player.lastName)) : 'Joueur #' + playerId;
    
    	    var pointsScale = [120, 105, 90, 78, 70, 62, 54, 46, 38, 30, 22, 15];
    	    var grossPointsScale = [80, 68, 60, 52, 45, 40, 35, 30, 25, 20, 15, 10];
    
    	    var html = '<div style="position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.5); z-index: 1000; display: flex; justify-content: center; align-items: center;">' +
               	       '<div style="background: white; padding: 30px; border-radius: 10px; box-shadow: 0 4px 20px rgba(0,0,0,0.3); max-width: 800px; width: 90%; max-height: 80%; overflow-y: auto;">' +
               	       '<h3 style="margin-top: 0; color: #2c5530;">📊 Détails GPR - ' + playerName + '</h3>' +
               
               	       '<table class="table">' +
               	       '<thead><tr><th>Date</th><th>Terrain</th><th>Score Brut</th><th>Pos. Brut</th><th>Pts Brut</th><th>Score Net</th><th>Pos. Net</th><th>Pts Net</th><th>Total Pts</th></tr></thead>' +
               	       '<tbody>';
    
    	    var totalPoints = 0;
    
    	    // Trier par date
    	    gprScores.sort((a, b) => new Date(a.roundId) - new Date(b.roundId));
    
    	    for (var i = 0; i < gprScores.length; i++) {
        	var score = gprScores[i];
        	var round = rounds.find(r => r.id === score.roundId);
        
        	if (!round) continue;
        
        	// Trouver tous les scores de cette partie pour calculer les positions
        	var roundScores = scores.filter(s => s.roundId === score.roundId);
        
        	// Position brute
        	var grossRanking = [...roundScores].sort((a, b) => a.score - b.score);
        	var grossPosition = grossRanking.findIndex(s => s.playerId === playerId) + 1;
        	var grossPoints = grossPointsScale[Math.min(grossPosition - 1, grossPointsScale.length - 1)];
        
        	// Position nette
        	var netRanking = [...roundScores].sort((a, b) => a.net - b.net);
        	var netPosition = netRanking.findIndex(s => s.playerId === playerId) + 1;
        	var netPoints = pointsScale[Math.min(netPosition - 1, pointsScale.length - 1)];
        
        	var roundTotal = grossPoints + netPoints;
        	totalPoints += roundTotal;
        
        	html += '<tr>' +
                	'<td>' + round.date.split('-').reverse().join('/') + '</td>' +
                	'<td><small>' + round.course + '</small></td>' +
                	'<td><strong>' + score.score + '</strong></td>' +
                	'<td>' + grossPosition + '</td>' +
                	'<td><span style="background: #17a2b8; color: white; padding: 1px 5px; border-radius: 8px; font-size: 12px;">' + grossPoints + '</span></td>' +
                	'<td><strong>' + score.net.toFixed(1) + '</strong></td>' +
                	'<td>' + netPosition + '</td>' +
                	'<td><span style="background: #28a745; color: white; padding: 1px 5px; border-radius: 8px; font-size: 12px;">' + netPoints + '</span></td>' +
                	'<td><strong>' + roundTotal + '</strong></td>' +
                	'</tr>';
    	    }
    
    	    html += '</tbody></table>' +
            
            	    '<div style="margin-top: 20px; padding: 15px; background: #f8f9fa; border-radius: 8px; text-align: center;">' +
            	    '<strong>Résumé:</strong> ' + gprScores.length + ' parties GPR | ' +
            	    '<strong>Total: ' + totalPoints + ' points</strong> | ' +
            	    '<strong>Moyenne: ' + (totalPoints / gprScores.length).toFixed(1) + ' pts/partie</strong>' +
            	    '</div>' +
            
            	    '<div style="margin-top: 25px; text-align: center;">' +
            	    '<button onclick="closeGPRPlayerDetails()" style="background: #6c757d; color: white; border: none; padding: 10px 20px; border-radius: 5px; cursor: pointer;">❌ Fermer</button>' +
            	    '</div>' +
            
            	    '</div></div>';
    
    	    // Ajouter la popup au body
    	    var popup = document.createElement('div');
    	    popup.id = 'gprPlayerDetailsPopup';
    	    popup.innerHTML = html;
    	    document.body.appendChild(popup);
	}

	// 4. FONCTION POUR FERMER LA POPUP DES DÉTAILS
	function closeGPRPlayerDetails() {
    	    var popup = document.getElementById('gprPlayerDetailsPopup');
    	    if (popup) {
        	popup.remove();
    	    }
	}
    
	function showGPRTab(tabName) {
    	// Fonction vide - plus nécessaire
    	return;
	}

	// Fonction pour afficher les détails des 4 meilleures parties
	function showGPRBest4Details(playerId, selectedYear) {
    	var yearToCheck = selectedYear || new Date().getFullYear();
    	var best4Results = calculateBest4Exhibition(playerId, yearToCheck);
    
    	if (best4Results.length === 0) {
        	alert('Aucune partie exhibition trouvée pour ce joueur.');
        	return;
    	}
    
    	var player = players.find(p => p.id === playerId);
    	var playerName = player ? (player.name || (player.firstName + ' ' + player.lastName)) : 'Joueur #' + playerId;
    
    	var html = '<div style="position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.5); z-index: 1000; display: flex; justify-content: center; align-items: center;">' +
        	       '<div style="background: white; padding: 30px; border-radius: 10px; box-shadow: 0 4px 20px rgba(0,0,0,0.3); max-width: 900px; width: 90%; max-height: 80%; overflow-y: auto;">' +
            	   '<h3 style="margin-top: 0; color: #2c5530;">🏆 Sélection des 4 Meilleures Parties - ' + playerName + '</h3>' +
               
            	   '<div style="background: #e7f3ff; padding: 15px; border-radius: 8px; margin-bottom: 20px;">' +
            	   '<strong>Règle:</strong> Les 4 parties avec le plus de points totaux (brut + net) sont automatiquement sélectionnées. ' +
            	   'Si moins de 5 parties jouées, toutes les parties comptent.' +
            	   '</div>' +
               
            	   '<table class="table">' +
            	   '<thead><tr><th>🏆</th><th>Date</th><th>Terrain</th><th>Score Brut</th><th>Pos. Brut</th><th>Pts Brut</th><th>Score Net</th><th>Pos. Net</th><th>Pts Net</th><th>Total Pts</th></tr></thead>' +
            	   '<tbody>';
    
    	var totalPoints = 0;
    
    	for (var i = 0; i < best4Results.length; i++) {
        	var result = best4Results[i];
        	var round = rounds.find(r => r.id === result.roundId);
        
        	totalPoints += result.totalPoints;
        
        	html += '<tr style="background: #f8fff8;">' +
            	    '<td style="text-align: center;"><span style="color: #28a745; font-size: 16px;">✅</span></td>' +
            	    '<td>' + round.date.split('-').reverse().join('/') + '</td>' +
            	    '<td><small>' + round.course + '</small></td>' +
            	    '<td><strong>' + result.score.score + '</strong></td>' +
            	    '<td>' + result.brutPos + '</td>' +
            	    '<td><span style="background: #17a2b8; color: white; padding: 1px 5px; border-radius: 8px; font-size: 12px;">' + result.brutPoints + '</span></td>' +
            	    '<td><strong>' + result.score.net.toFixed(1) + '</strong></td>' +
           		    '<td>' + result.netPos + '</td>' +
            	    '<td><span style="background: #28a745; color: white; padding: 1px 5px; border-radius: 8px; font-size: 12px;">' + result.netPoints + '</span></td>' +
            	    '<td><strong style="color: #2c5530;">' + result.totalPoints + '</strong></td>' +
            	    '</tr>';
    	}
    
    	html += '</tbody></table>' +
		
        	    '<div style="margin-top: 20px; padding: 15px; background: #f8f9fa; border-radius: 8px; text-align: center;">' +
            	'<strong>Résumé:</strong> ' + best4Results.length + ' partie(s) sélectionnée(s) | ' +
            	'<strong>Total Exhibition: ' + totalPoints + ' points</strong>';
    
    	// Ajouter les points de finale s'ils existent
    	var finalePoints = 0;
    	var finaleRounds = rounds.filter(r => r.type === 'gpr' && r.gprPhase === 'finale' && r.year === yearToCheck);
    
    	if (finaleRounds.length > 0) {
        	var finaleResults = calculateFinaleScores(yearToCheck);
        	if (finaleResults[playerId]) {
            	finalePoints = (finaleResults[playerId].pointsBrut || 0) + (finaleResults[playerId].pointsNet || 0);
            	html += ' | <strong>Points Finale: ' + finalePoints + '</strong>';
        	}
    	}
    
    	html += ' | <strong style="color: #e74c3c;">TOTAL OFFICIEL: ' + (totalPoints + finalePoints) + ' points</strong>' +
        	    '</div>' +
            
            	'<div style="margin-top: 25px; text-align: center;">' +
            	'<button onclick="closeGPRBest4Details()" style="background: #6c757d; color: white; border: none; padding: 10px 20px; border-radius: 5px; cursor: pointer;">❌ Fermer</button>' +
            	'</div>' +
            
            	'</div></div>';
    
    	// Ajouter la popup au body
    	var popup = document.createElement('div');
    	popup.id = 'gprBest4DetailsPopup';
    	popup.innerHTML = html;
    	document.body.appendChild(popup);
	}

	// Fonction pour fermer la popup des détails best4
	function closeGPRBest4Details() {
    	var popup = document.getElementById('gprBest4DetailsPopup');
    	if (popup) {
        	popup.remove();
    	}
	}

	// Fonctions utilitaires
        function loadYearSelectors() {
            var years = [];
            for (var i = 0; i < rounds.length; i++) {
                if (years.indexOf(rounds[i].year) === -1) {
                    years.push(rounds[i].year);
                }
            }
            years.sort();

            var diabloSelect = document.getElementById('diabloYearSelect');
            var gprSelect = document.getElementById('gprYearSelect');
            
            var currentDiabloYear = diabloSelect.value;
            var currentGprYear = gprSelect.value;
            
            diabloSelect.innerHTML = '<option value="">-- Toutes les années --</option>';
            gprSelect.innerHTML = '<option value="">-- Toutes les années --</option>';
            
            for (var i = 0; i < years.length; i++) {
                var year = years[i];
                
                var diabloOption = document.createElement('option');
                diabloOption.value = year;
                diabloOption.textContent = year;
                if (year == currentDiabloYear) diabloOption.selected = true;
                diabloSelect.appendChild(diabloOption);
                
                var gprOption = document.createElement('option');
                gprOption.value = year;
                gprOption.textContent = year;
                if (year == currentGprYear) gprOption.selected = true;
                gprSelect.appendChild(gprOption);
            }
        }

        function updateDiabloStatus(selectedYear) {
            var statusElement = document.getElementById('diabloStatus');
            var currentDate = new Date();
            var currentYear = currentDate.getFullYear();
            var currentMonth = currentDate.getMonth() + 1;
            
            if (!selectedYear || selectedYear == currentYear) {
                if (currentMonth >= 9) {
                    statusElement.innerHTML = '🔴 En cours';
                    statusElement.style.background = '#28a745';
                    statusElement.style.color = 'white';
                } else {
                    statusElement.innerHTML = '⏳ À venir (Septembre)';
                    statusElement.style.background = '#ffc107';
                    statusElement.style.color = 'black';
                }
            } else if (selectedYear < currentYear) {
                statusElement.innerHTML = '✅ Terminée';
                statusElement.style.background = '#6c757d';
                statusElement.style.color = 'white';
            } else {
                statusElement.innerHTML = '📅 Future';
                statusElement.style.background = '#17a2b8';
                statusElement.style.color = 'white';
            }
        }

        function updateGPRStatus(selectedYear) {
            var statusElement = document.getElementById('gprStatus');
            var currentDate = new Date();
            var currentYear = currentDate.getFullYear();
            var currentMonth = currentDate.getMonth() + 1;
            
            if (!selectedYear || selectedYear == currentYear) {
                if (currentMonth >= 5 && currentMonth <= 7) {
                    statusElement.innerHTML = '🔴 En cours';
                    statusElement.style.background = '#28a745';
                    statusElement.style.color = 'white';
                } else if (currentMonth < 5) {
                    statusElement.innerHTML = '⏳ À venir (Mai-Juillet)';
                    statusElement.style.background = '#ffc107';
                    statusElement.style.color = 'black';
                } else {
                    statusElement.innerHTML = '✅ Terminée';
                    statusElement.style.background = '#6c757d';
                    statusElement.style.color = 'white';
                }
            } else if (selectedYear < currentYear) {
                statusElement.innerHTML = '✅ Terminée';
                statusElement.style.background = '#6c757d';
                statusElement.style.color = 'white';
            } else {
                statusElement.innerHTML = '📅 Future';
                statusElement.style.background = '#17a2b8';
                statusElement.style.color = 'white';
            }
        }

        function getUniquePlayersCount(scoresList) {
            var playerIds = [];
            for (var i = 0; i < scoresList.length; i++) {
                if (playerIds.indexOf(scoresList[i].playerId) === -1) {
                    playerIds.push(scoresList[i].playerId);
                }
            }
            return playerIds.length;
        }

        function loadProgress() {
            var currentDate = new Date();
            var currentYear = currentDate.getFullYear();
            var currentMonth = currentDate.getMonth() + 1;
            
            var html = '<div class="card">' +
                       '<h3>État des Coupes ' + currentYear + '</h3>' +
                       '</div>';
            
            // Progression GPR
            var gprRounds = rounds.filter(r => r.type === 'gpr' && r.year === currentYear);
            var gprScores = scores.filter(s => s.type === 'gpr' && s.year === currentYear);
            
            html += '<div class="card">' +
                    '<h4>🎯 Coupe GPR ' + currentYear + ' (Mai - Juillet)</h4>';
            
            if (currentMonth >= 5 && currentMonth <= 7) {
                html += '<p style="color: #28a745;"><strong>🔴 EN COURS</strong></p>';
            } else if (currentMonth < 5) {
                html += '<p style="color: #ffc107;"><strong>⏳ À VENIR</strong></p>';
            } else {
                html += '<p style="color: #6c757d;"><strong>✅ TERMINÉE</strong></p>';
            }
            
            html += '<p><strong>Parties jouées:</strong> ' + gprRounds.length + '</p>' +
                    '<p><strong>Participants:</strong> ' + getUniquePlayersCount(gprScores) + '</p>';
            
            if (gprScores.length > 0) {
                var gprLeader = getGPRLeader(gprRounds, gprScores);
                html += '<p><strong>Leader actuel:</strong> ' + gprLeader + '</p>';
            }
            
            html += '</div>';
            
            // Progression Diablo
            var diabloRounds = rounds.filter(r => r.type === 'diablo' && r.year === currentYear);
            var diabloScores = scores.filter(s => s.type === 'diablo' && s.year === currentYear);
            
            html += '<div class="card">' +
                    '<h4>🏆 Coupe Diablo ' + currentYear + ' (Septembre)</h4>';
            
            if (currentMonth >= 9) {
                html += '<p style="color: #28a745;"><strong>🔴 EN COURS</strong></p>';
            } else {
                html += '<p style="color: #ffc107;"><strong>⏳ À VENIR</strong></p>';
            }
            
            html += '<p><strong>Parties jouées:</strong> ' + diabloRounds.length + '</p>' +
                    '<p><strong>Participants:</strong> ' + getUniquePlayersCount(diabloScores) + '</p>';
            
            if (diabloScores.length > 0) {
                var diabloLeader = getDiabloLeader(diabloScores);
                html += '<p><strong>Leader actuel:</strong> ' + diabloLeader + '</p>';
            }
            
            html += '</div>';
            
            document.getElementById('progressContent').innerHTML = html;
        }

        function getGPRLeader(gprRounds, gprScores) {
    		var tempPlayerPoints = {};  // Utiliser une variable locale
    		var pointsScale = [120, 105, 90, 78, 70, 62, 54, 46, 38, 30, 22, 15];
    		var grossPointsScale = [80, 68, 60, 52, 45, 40, 35, 30, 25, 20, 15, 10];

    		for (var i = 0; i < gprRounds.length; i++) {
        		var round = gprRounds[i];
        		var roundScores = gprScores.filter(s => s.roundId === round.id);
        
        		roundScores.sort((a, b) => a.net - b.net);
        
        		for (var k = 0; k < roundScores.length; k++) {
            		var score = roundScores[k];
            		if (!tempPlayerPoints[score.playerId]) {
                		var player = players.find(p => p.id === score.playerId);
                		var playerName = player ? (player.name || (player.firstName + ' ' + player.lastName)) : ('Joueur #' + score.playerId);
                
                		tempPlayerPoints[score.playerId] = {
                    		playerName: playerName,
                    		totalPoints: 0
                		};
            		}
            
            		var netPoints = pointsScale[Math.min(k, pointsScale.length - 1)];
            		var grossPoints = grossPointsScale[Math.min(k, grossPointsScale.length - 1)];
            
            		tempPlayerPoints[score.playerId].totalPoints += netPoints + grossPoints;
        		}
    		}

    		var maxPoints = 0;
    		var leader = 'Aucun';
    		for (var playerId in tempPlayerPoints) {
        		if (tempPlayerPoints[playerId].totalPoints > maxPoints) {
            		maxPoints = tempPlayerPoints[playerId].totalPoints;
            		leader = tempPlayerPoints[playerId].playerName + ' (' + maxPoints + ' pts)';
        		}
    		}
    
    		return leader;
		}

	function getDiabloLeader(diabloScores) {
    	    var playerStats = {};
    
    	    for (var i = 0; i < diabloScores.length; i++) {
        	var score = diabloScores[i];
        	if (!playerStats[score.playerId]) {
            	    // CORRECTION : Même logique que dans l'overview
            	    var player = players.find(p => p.id === score.playerId);
            	    var playerName = player ? (player.name || (player.firstName + ' ' + player.lastName)) : ('Joueur #' + score.playerId);
            
            	    playerStats[score.playerId] = {
                	playerName: playerName,  // UTILISER le nom calculé
                	totalNet: 0,
                	rounds: 0
            	    };
        	}
        	playerStats[score.playerId].totalNet += score.net;
        	playerStats[score.playerId].rounds++;
    	    }

    	    var bestAvg = 999;
    	    var leader = 'Aucun';
    	    for (var playerId in playerStats) {
        	var avg = playerStats[playerId].totalNet / playerStats[playerId].rounds;
        	if (avg < bestAvg) {
            	    bestAvg = avg;
            	    leader = playerStats[playerId].playerName + ' (' + avg.toFixed(1) + ' net)';  // UTILISER playerName
        	}
    	    }
    
    	    return leader;
	}

        function loadDetails() {
            var select = document.getElementById('roundSelect');
            select.innerHTML = '<option value="">-- Sélectionner une partie --</option>';
            
            for (var i = 0; i < rounds.length; i++) {
                var round = rounds[i];
                var icon = round.type === 'diablo' ? '🏆' : '🎯';
                var date = round.date.split('-').reverse().join('/');
                
                var option = document.createElement('option');
                option.value = round.id;
                option.textContent = icon + ' ' + date + ' - ' + round.course;
                select.appendChild(option);
            }
        }

        function showRoundDetail() {
            var roundId = parseInt(document.getElementById('roundSelect').value);
            if (!roundId) {
                document.getElementById('detailsContent').innerHTML = '';
                return;
            }

            var round = rounds.find(r => r.id === roundId);
            var roundScores = scores.filter(s => s.roundId === roundId);

            if (!round || roundScores.length === 0) {
                document.getElementById('detailsContent').innerHTML = '<p>Aucun score pour cette partie.</p>';
                return;
            }

            console.log('DEBUG: round =', round);
            console.log('DEBUG: roundScores =', roundScores);
            console.log('DEBUG: round.type =', round.type);

            var html = '<div class="card">' +
                       '<h3>' + round.date.split('-').reverse().join('/') + ' - ' + round.course + '</h3>' +
                       '<p><strong>Type:</strong> ' + (round.type === 'diablo' ? '🏆 Coupe Diablo' : '🎯 Coupe GPR') + '</p>' +
                       '<p><strong>Départ:</strong> ' + (round.tee === 'bleu' ? '🔵 Bleu' : '⚪ Blanc') + ' (Antonio: ' + (teeUsed[round.id-1] === 'bleu' ? '🔵 Bleu' : '⚪ Blanc') + ', Autres: ⚪ Blanc)</p>' +
                       '<div style="margin: 15px 0; text-align: center; background: #f8f9fa; padding: 15px; border-radius: 8px;">' +
					   '<h4 style="margin: 0 0 10px 0; color: #2c5530;">⚙️ Actions sur cette partie</h4>' +
					   '<button class="btn-secondary" onclick="editRound(' + round.id + ')" style="margin: 5px;">✏️ Modifier Scores</button>' +
					   '<button class="btn-danger" onclick="deleteRound(' + round.id + ')" style="margin: 5px;">🗑️ Supprimer Partie</button>' +
					   '<button class="btn" onclick="duplicateRound(' + round.id + ')" style="margin: 5px;">📋 Dupliquer Partie</button>' +
					   '</div>' +
					   '</div>';

            if (round.type === 'diablo') {
                console.log('DEBUG: Génération détails Diablo');
                html += generateDiabloRoundDetail(round, roundScores);
            } else {
                console.log('DEBUG: Génération détails GPR');
                html += generateGPRRoundDetail(round, roundScores);
            }

            console.log('DEBUG: HTML final =', html);
            document.getElementById('detailsContent').innerHTML = html;
        }

        // Générer les détails pour une partie Diablo
        function generateDiabloRoundDetail(round, roundScores) {
            var html = '';
            
            // Classement de la partie
            roundScores.sort((a, b) => a.net - b.net);
            
            html += '<div class="card">' +
                    '<h4>🏆 Classement de la Partie</h4>' +
                    '<table class="table">' +
                    '<thead><tr><th>Position</th><th>Joueur</th><th>Score Brut</th><th>Score Net</th><th>Différentiel</th></tr></thead>' +
                    '<tbody>';

            for (var i = 0; i < roundScores.length; i++) {
                var score = roundScores[i];
                var rowStyle = '';
                if (i === 0) rowStyle = ' style="background: gold;"';
                else if (i === 1) rowStyle = ' style="background: silver;"';
                else if (i === 2) rowStyle = ' style="background: #cd7f32;"';
                
                // Calculer le différentiel
                var differential = calculateScoreDifferentialReal(score.score, round.course, score.tee);
                
                html += '<tr' + rowStyle + '>' +
                        '<td><strong>' + (i + 1) + '</strong></td>' +
                        '<td><strong>' + score.playerName + '</strong></td>' +
                        '<td>' + score.score + '</td>' +
                        '<td><strong>' + score.net.toFixed(1) + '</strong></td>' +
                        '<td>' + (differential ? differential.toFixed(1) : 'N/A') + '</td>' +
                        '</tr>';
            }

            html += '</tbody></table></div>';
            
            // Pointage global du tournoi Diablo pour cette année
            html += generateDiabloTournamentStandings(round.year);
            
            return html;
        }

        // Générer les détails pour une partie GPR
        function generateGPRRoundDetail(round, roundScores) {
            var html = '';
            
            // Points scale
            var brutPointsScale = [80, 68, 60, 52, 45, 40, 35, 30, 25, 20, 15, 10];
            var netPointsScale = [120, 105, 90, 78, 70, 62, 54, 46, 38, 30, 22, 15];
            
            // Exclure Éric Gosselin (ID 12) des classements GPR
            var gprScores = roundScores.filter(s => s.playerId !== 13);
            
            // 1. Classement Brut avec pointage
            var brutRanking = [...gprScores].sort((a, b) => a.score - b.score);
            
            html += '<div class="card">' +
                    '<h4>🏌️ Classement Score Brut</h4>' +
                    '<table class="table">' +
                    '<thead><tr><th>Position</th><th>Joueur</th><th>Score Brut</th><th>Points</th></tr></thead>' +
                    '<tbody>';

            for (var i = 0; i < brutRanking.length; i++) {
                var score = brutRanking[i];
                var points = brutPointsScale[Math.min(i, brutPointsScale.length - 1)];
                var rowStyle = '';
                if (i === 0) rowStyle = ' style="background: gold;"';
                else if (i === 1) rowStyle = ' style="background: silver;"';
                else if (i === 2) rowStyle = ' style="background: #cd7f32;"';
                
                html += '<tr' + rowStyle + '>' +
                        '<td><strong>' + (i + 1) + '</strong></td>' +
                        '<td><strong>' + score.playerName + '</strong></td>' +
                        '<td>' + score.score + '</td>' +
                        '<td><span style="background: #17a2b8; color: white; padding: 2px 8px; border-radius: 10px;">' + points + '</span></td>' +
                        '</tr>';
            }

            html += '</tbody></table></div>';
            
            // 2. Classement Net avec pointage
            var netRanking = [...gprScores].sort((a, b) => a.net - b.net);
            
            html += '<div class="card">' +
                    '<h4>🎯 Classement Score Net</h4>' +
                    '<table class="table">' +
                    '<thead><tr><th>Position</th><th>Joueur</th><th>Score Net</th><th>Points</th></tr></thead>' +
                    '<tbody>';

            for (var i = 0; i < netRanking.length; i++) {
                var score = netRanking[i];
                var points = netPointsScale[Math.min(i, netPointsScale.length - 1)];
                var rowStyle = '';
                if (i === 0) rowStyle = ' style="background: gold;"';
                else if (i === 1) rowStyle = ' style="background: silver;"';
                else if (i === 2) rowStyle = ' style="background: #cd7f32;"';
                
                html += '<tr' + rowStyle + '>' +
                        '<td><strong>' + (i + 1) + '</strong></td>' +
                        '<td><strong>' + score.playerName + '</strong></td>' +
                        '<td><strong>' + score.net.toFixed(1) + '</strong></td>' +
                        '<td><span style="background: #28a745; color: white; padding: 2px 8px; border-radius: 10px;">' + points + '</span></td>' +
                        '</tr>';
            }

            html += '</tbody></table></div>';
            
            // 3. Points totaux pour cette partie
            var roundTotals = [];
            
            for (var i = 0; i < gprScores.length; i++) {
                var score = gprScores[i];
                var brutPos = brutRanking.findIndex(s => s.playerId === score.playerId) + 1;
                var netPos = netRanking.findIndex(s => s.playerId === score.playerId) + 1;
                var brutPoints = brutPointsScale[Math.min(brutPos - 1, brutPointsScale.length - 1)];
                var netPoints = netPointsScale[Math.min(netPos - 1, netPointsScale.length - 1)];
                var totalPoints = brutPoints + netPoints;
                
                roundTotals.push({
                    player: score,
                    brutPoints: brutPoints,
                    netPoints: netPoints,
                    totalPoints: totalPoints
                });
            }
            
            roundTotals.sort((a, b) => b.totalPoints - a.totalPoints);
            
            html += '<div class="card">' +
                    '<h4>🏆 Points Totaux de la Partie</h4>' +
                    '<table class="table">' +
                    '<thead><tr><th>Position</th><th>Joueur</th><th>Points Brut</th><th>Points Net</th><th>Total</th></tr></thead>' +
                    '<tbody>';

            for (var i = 0; i < roundTotals.length; i++) {
                var total = roundTotals[i];
                var rowStyle = '';
                if (i === 0) rowStyle = ' style="background: gold;"';
                else if (i === 1) rowStyle = ' style="background: silver;"';
                else if (i === 2) rowStyle = ' style="background: #cd7f32;"';
                
                html += '<tr' + rowStyle + '>' +
                        '<td><strong>' + (i + 1) + '</strong></td>' +
                        '<td><strong>' + total.player.playerName + '</strong></td>' +
                        '<td>' + total.brutPoints + '</td>' +
                        '<td>' + total.netPoints + '</td>' +
                        '<td><strong>' + total.totalPoints + '</strong></td>' +
                        '</tr>';
            }

            html += '</tbody></table></div>';
            
            // 4. Pointage global du tournoi GPR pour cette année
            html += generateGPRTournamentStandings(round.year);
            
            return html;
        }

        // Générer le classement global Diablo pour une année
        function generateDiabloTournamentStandings(year) {
            var diabloScores = scores.filter(s => s.type === 'diablo' && s.year === year);
            
            if (diabloScores.length === 0) {
                return '<div class="card"><h4>🏆 Classement Global Diablo ' + year + '</h4><p>Aucune partie Diablo pour cette année.</p></div>';
            }
            
            var playerStats = {};
            
            for (var i = 0; i < diabloScores.length; i++) {
                var score = diabloScores[i];
                if (!playerStats[score.playerId]) {
                    playerStats[score.playerId] = {
                        playerName: score.playerName,
                        totalNet: 0,
                        rounds: 0
                    };
                }
                playerStats[score.playerId].totalNet += score.net;
                playerStats[score.playerId].rounds++;
            }
            
            var leaderboard = [];
            for (var playerId in playerStats) {
                var stats = playerStats[playerId];
                leaderboard.push({
                    playerName: stats.playerName,
                    rounds: stats.rounds,
                    avgNet: stats.totalNet / stats.rounds
                });
            }
            
            leaderboard.sort((a, b) => a.avgNet - b.avgNet);
            
            var html = '<div class="card">' +
                       '<h4>🏆 Classement Global Diablo ' + year + '</h4>' +
                       '<table class="table">' +
                       '<thead><tr><th>Position</th><th>Joueur</th><th>Parties</th><th>Score Net Moyen</th></tr></thead>' +
                       '<tbody>';
            
            for (var i = 0; i < leaderboard.length; i++) {
                var stats = leaderboard[i];
                var rowStyle = '';
                if (i === 0) rowStyle = ' style="background: gold;"';
                else if (i === 1) rowStyle = ' style="background: silver;"';
                else if (i === 2) rowStyle = ' style="background: #cd7f32;"';
                
                html += '<tr' + rowStyle + '>' +
                        '<td><strong>' + (i + 1) + '</strong></td>' +
                        '<td><strong>' + stats.playerName + '</strong></td>' +
                        '<td>' + stats.rounds + '</td>' +
                        '<td><strong>' + stats.avgNet.toFixed(1) + '</strong></td>' +
                        '</tr>';
            }
            
            html += '</tbody></table></div>';
            
            return html;
        }

        // Générer le classement global GPR pour une année
        function generateGPRTournamentStandings(year) {
            var gprScores = scores.filter(s => s.type === 'gpr' && s.year === year && s.playerId !== 13); // Exclure Gosselin
            
            if (gprScores.length === 0) {
                return '<div class="card"><h4>🎯 Classement Global GPR ' + year + '</h4><p>Aucune partie GPR pour cette année.</p></div>';
            }
            
            var gprRounds = rounds.filter(r => r.type === 'gpr' && r.year === year);
            var playerPoints = {};
            var brutPointsScale = [80, 68, 60, 52, 45, 40, 35, 30, 25, 20, 15, 10];
            var netPointsScale = [120, 105, 90, 78, 70, 62, 54, 46, 38, 30, 22, 15];
            
            for (var i = 0; i < gprRounds.length; i++) {
                var round = gprRounds[i];
                var roundScores = gprScores.filter(s => s.roundId === round.id);
                
                // Classement brut pour cette partie
                var brutRanking = [...roundScores].sort((a, b) => a.score - b.score);
                // Classement net pour cette partie
                var netRanking = [...roundScores].sort((a, b) => a.net - b.net);
                
                for (var j = 0; j < roundScores.length; j++) {
                    var score = roundScores[j];
                    if (!playerPoints[score.playerId]) {
                        playerPoints[score.playerId] = {
                            playerName: score.playerName,
                            totalPoints: 0,
                            rounds: 0
                        };
                    }
                    
                    var brutPos = brutRanking.findIndex(s => s.playerId === score.playerId) + 1;
                    var netPos = netRanking.findIndex(s => s.playerId === score.playerId) + 1;
                    var brutPoints = brutPointsScale[Math.min(brutPos - 1, brutPointsScale.length - 1)];
                    var netPoints = netPointsScale[Math.min(netPos - 1, netPointsScale.length - 1)];
                    
                    playerPoints[score.playerId].totalPoints += brutPoints + netPoints;
                    playerPoints[score.playerId].rounds++;
                }
            }
            
            var leaderboard = [];
            for (var playerId in playerPoints) {
                var stats = playerPoints[playerId];
                leaderboard.push({
                    playerName: stats.playerName,
                    rounds: stats.rounds,
                    totalPoints: stats.totalPoints
                });
            }
            
            leaderboard.sort((a, b) => b.totalPoints - a.totalPoints);
            
            var html = '<div class="card">' +
                       '<h4>🎯 Classement Global GPR ' + year + '</h4>' +
                       '<table class="table">' +
                       '<thead><tr><th>Position</th><th>Joueur</th><th>Parties</th><th>Points Totaux</th></tr></thead>' +
                       '<tbody>';
            
            for (var i = 0; i < leaderboard.length; i++) {
                var stats = leaderboard[i];
                var rowStyle = '';
                if (i === 0) rowStyle = ' style="background: gold;"';
                else if (i === 1) rowStyle = ' style="background: silver;"';
                else if (i === 2) rowStyle = ' style="background: #cd7f32;"';
                
                html += '<tr' + rowStyle + '>' +
                        '<td><strong>' + (i + 1) + '</strong></td>' +
                        '<td><strong>' + stats.playerName + '</strong></td>' +
                        '<td>' + stats.rounds + '</td>' +
                        '<td><strong>' + stats.totalPoints + '</strong></td>' +
                        '</tr>';
            }
            
            html += '</tbody></table></div>';
            
            return html;
        }

	// Variables globales pour le graphique
	var selectedPlayers = [];
	var handicapEvolutionData = {};

	// Fonction pour afficher la section évolution des handicaps
	function showHandicapEvolution() {
    	    hideAllSections();
    	    document.getElementById('handicapEvolution').style.display = 'block';
    	    setActiveButton(6); // Ajustez l'index selon votre navigation
    	    loadHandicapEvolution();
	}

	// Charger l'interface d'évolution des handicaps
	function loadHandicapEvolution() {
    	    // Préparer les données d'évolution pour tous les joueurs
    	    prepareHandicapEvolutionData();
    
    	    // Créer les checkboxes pour sélectionner les joueurs
    	    createPlayerCheckboxes();
    
    	    // Sélectionner automatiquement les 3 premiers joueurs
    	    selectDefaultPlayers();
    
    	    // Afficher le graphique initial
    	    updateHandicapChart();
    
    	    // CORRECTION : Toujours afficher les statistiques, même sans sélection
    	    displayHandicapStats();
	}

	// Préparer les données d'évolution des handicaps
	function prepareHandicapEvolutionData() {
    	    console.log("🔄 Préparation des données d'évolution avec calculs réels...");
    
    	    handicapEvolutionData = {};
    
    	    // Vider le cache pour éviter les conflits
    	    if (typeof handicapCache !== 'undefined') {
        	handicapCache = {};
    	    }
    
    	    for (var i = 0; i < players.length; i++) {
        	var player = players[i];
        	var evolution = [];
        	var playerName = player.name || (player.firstName + ' ' + player.lastName);
        
        	console.log("Calcul pour:", playerName);
        
        	// Handicap de départ (avant toute partie)
        	var currentHandicap = player.handicap;
        
        	// Point de départ
        	evolution.push({
            	    date: dates[0] || '2023-01-01',
            	    handicap: currentHandicap,
            	    gameNumber: 0,
            	    change: 0
        	});
        
        	// CORRECTION : Calculer l'évolution RÉELLE après chaque partie
        	var scoresCount = 0;
        	var allDifferentials = [];
        
        	for (var j = 0; j < dates.length; j++) {
            	    if (allScores[i][j] > 0) {
                	scoresCount++;
                	var grossScore = allScores[i][j];
                	var courseName = courses[j];
                	var teeForPlayer = (player.id === 1) ? teeUsed[j] : 'blanc';
                
                	// Calculer le différentiel pour ce score
                	var differential = calculateScoreDifferentialReal(grossScore, courseName, teeForPlayer);
                	if (differential > 0) {
                    	    allDifferentials.push(differential);
                	}
                
                	// Calculer le nouveau handicap basé sur tous les scores jusqu'ici
                	var newHandicap = calculateNewHandicapFromDifferentials(allDifferentials, player.handicap);
                	var change = newHandicap - currentHandicap;
                
                	evolution.push({
                    	    date: dates[j],
                    	    handicap: newHandicap,
                    	    gameNumber: j + 1,
                    	    change: change,
                    	    score: grossScore,
                    	    course: courseName,
                    	    differential: differential,
                    	    totalDifferentials: allDifferentials.length
                	});
                
                	currentHandicap = newHandicap;
                
                	console.log(`  Partie ${j+1}: Score ${grossScore} → Handicap ${newHandicap.toFixed(1)} (${change > 0 ? '+' : ''}${change.toFixed(1)})`);
            	    }
        	}
        
        	handicapEvolutionData[player.id] = {
            	    player: player,
            	    playerName: playerName,
            	    evolution: evolution
        	};
        
        	var finalChange = evolution.length > 1 ? evolution[evolution.length-1].handicap - evolution[0].handicap : 0;
        	console.log(`${playerName} - Changement total: ${finalChange > 0 ? '+' : ''}${finalChange.toFixed(1)}`);
    	    }
    
    	    console.log("✅ Données d'évolution préparées avec calculs réels!");
	}

	// 1. FONCTION DE DIAGNOSTIC POUR COMPRENDRE LE PROBLÈME
	function diagnoseHandicapProgression() {
    	    console.log("🔍 DIAGNOSTIC DE LA PROGRESSION DES HANDICAPS");
    	    console.log("=============================================");
    
    	    // Prendre Antonio comme exemple
    	    var antonio = players.find(p => p.id === 1);
    	    if (!antonio || !allScores[0]) {
        	console.log("❌ Pas de données pour Antonio");
        	return;
    	    }
    
    	    console.log("Analyse pour Antonio Coccaro:");
    	    console.log("Handicap initial:", antonio.handicap);
    
    	    var progressiveDifferentials = [];
    
    	    for (var i = 0; i < Math.min(10, dates.length); i++) {
        	if (allScores[0][i] > 0) {
            	    var score = allScores[0][i];
            	    var course = courses[i];
            	    var tee = teeUsed[i]; // Antonio joue des bleus parfois
            
            	    // Calculer le différentiel pour ce score
            	    var diff = calculateScoreDifferentialReal(score, course, tee);
            	    if (diff > 0) {
                	progressiveDifferentials.push(diff);
                
                	// Calculer le handicap avec SEULEMENT les scores jusqu'ici
                	var handicapAtThisPoint = calculateNewHandicapFromDifferentials(progressiveDifferentials, antonio.handicap);
                
                	console.log(`Partie ${i+1} (${dates[i]}):`);
                	console.log(`  Score: ${score} au ${course} (${tee})`);
                	console.log(`  Différentiel: ${diff}`);
                	console.log(`  Différentiels accumulés: ${progressiveDifferentials.length}`);
                	console.log(`  Handicap calculé: ${handicapAtThisPoint}`);
                	console.log(`  ---`);
            	    }
        	}
    	    }
    
    	    console.log("\n🎯 Si les handicaps sont identiques, c'est que le calcul ne progresse pas correctement!");
	}

	// 2. FONCTION CORRIGÉE POUR CALCULER L'ÉVOLUTION PROGRESSIVE
	function prepareHandicapEvolutionDataProgressive() {
    	    console.log("🔄 Préparation PROGRESSIVE des données d'évolution...");
    
    	    handicapEvolutionData = {};
    
    	    for (var i = 0; i < players.length; i++) {
        	var player = players[i];
        	var evolution = [];
        	var playerName = player.name || (player.firstName + ' ' + player.lastName);
        
        	console.log(`\nCalcul progressif pour: ${playerName}`);
        
        	// Handicap de départ
        	var currentHandicap = player.handicap;
        
        	// Point de départ
        	evolution.push({
            	    date: dates[0] || '2023-01-01',
            	    handicap: currentHandicap,
            	    gameNumber: 0,
            	    change: 0,
            	    scoresUsed: 0,
            	    status: 'Initial'
        	});
        
        	// CORRECTION : Accumuler progressivement les différentiels
        	var progressiveDifferentials = [];
        	var gameNumber = 0;
        
        	for (var j = 0; j < dates.length; j++) {
            	    if (allScores[i][j] > 0) {
                	gameNumber++;
                	var grossScore = allScores[i][j];
                	var courseName = courses[j];
                	var teeForPlayer = (player.id === 1) ? teeUsed[j] : 'blanc';
                
                	// Calculer le différentiel pour cette partie
                	var differential = calculateScoreDifferentialReal(grossScore, courseName, teeForPlayer);
                
                	if (differential > 0) {
                    	    // AJOUTER ce différentiel à la liste progressive
                    	    progressiveDifferentials.push({
                        	date: dates[j],
                        	differential: differential,
                        	score: grossScore,
                        	course: courseName
                    	    });
                    
                    	    // Calculer le nouveau handicap avec SEULEMENT les scores jusqu'à cette date
                    	    var newHandicap;
                    
                    	    if (progressiveDifferentials.length < 5) {
                        	// Pas assez de scores, garder le handicap précédent
                        	newHandicap = currentHandicap;
                        	var status = `Pas assez de scores (${progressiveDifferentials.length}/5)`;
                    	    } else {
                        	// Calculer avec les différentiels disponibles jusqu'ici
                        	var diffValues = progressiveDifferentials.map(d => d.differential);
                        	newHandicap = calculateNewHandicapFromDifferentials(diffValues, player.handicap);
                        	var status = `Calculé avec ${progressiveDifferentials.length} scores`;
                    	    }
                    
                    	    var change = newHandicap - currentHandicap;
                    
                    	    evolution.push({
                        	date: dates[j],
                        	handicap: newHandicap,
                        	gameNumber: gameNumber,
                        	change: change,
                        	score: grossScore,
                        	course: courseName,
                        	differential: differential,
                        	scoresUsed: progressiveDifferentials.length,
                        	status: status
                    	    });
                    
                    	    console.log(`  Partie ${gameNumber}: ${grossScore} → H=${newHandicap.toFixed(1)} (${progressiveDifferentials.length} scores)`);
                    
                    	    currentHandicap = newHandicap;
                	}
            	    }
        	}
        
        	handicapEvolutionData[player.id] = {
            	    player: player,
            	    playerName: playerName,
            	    evolution: evolution
        	};
        
        	// Résumé pour ce joueur
        	if (evolution.length > 1) {
            	    var initialH = evolution[0].handicap;
            	    var finalH = evolution[evolution.length - 1].handicap;
            	    // Trouver l'handicap à la 6e partie JOUÉE par ce joueur
					var initialHandicapForDisplay = evolution[0].handicap;
					var partiesJouees = 0;
					for (var k = 0; k < evolution.length; k++) {
    					// Vérifier s'il a joué cette partie (a un score)
    					if (evolution[k].score && evolution[k].score > 0) {
        					partiesJouees++;
        					if (partiesJouees === 6) {
            					initialHandicapForDisplay = evolution[k].handicap;
            					break;
        					}
    					}
					}
					// Si le joueur n'a pas 6 parties, garder son handicap initial
					if (partiesJouees < 6) {
    					initialHandicapForDisplay = evolution[0].handicap;
					}
					var totalChange = finalH - initialHForDisplay;
            	    var totalGames = evolution[evolution.length - 1].gameNumber;
            
            	    console.log(`${playerName} RÉSUMÉ: ${initialH.toFixed(1)} → ${finalH.toFixed(1)} (${totalChange > 0 ? '+' : ''}${totalChange.toFixed(1)}) sur ${totalGames} parties`);
        	}
    	    }
    
    	    console.log("\n✅ Évolution PROGRESSIVE calculée!");
	}

	// 3. FONCTION POUR CALCULER AVEC VARIATION RÉALISTE (alternative)
	function prepareHandicapEvolutionWithRealisticVariation() {
    	    console.log("🎭 Préparation avec variation réaliste...");
    
    	    handicapEvolutionData = {};
    
    	    for (var i = 0; i < players.length; i++) {
        	var player = players[i];
        	var evolution = [];
        	var playerName = player.name || (player.firstName + ' ' + player.lastName);
        
        	// Handicap de départ
        	var currentHandicap = player.handicap;
        
        	evolution.push({
            	    date: dates[0] || '2023-01-01',
            	    handicap: currentHandicap,
            	    gameNumber: 0,
            	    change: 0
        	});
        
        	// Variables pour la progression réaliste
        	var recentScores = [];
        	var gameNumber = 0;
        	var lastHandicapUpdate = 0;
        
        	for (var j = 0; j < dates.length; j++) {
            	    if (allScores[i][j] > 0) {
                	gameNumber++;
                	var grossScore = allScores[i][j];
                
                	// Ajouter à la liste des scores récents
                	recentScores.push(grossScore);
                
                	// Garder seulement les 8 derniers scores pour l'évaluation
                	if (recentScores.length > 8) {
                    	    recentScores.shift();
                	}
                
                	// Calculer un changement basé sur la performance récente
                	var change = 0;
                
                	if (gameNumber >= 5 && (gameNumber - lastHandicapUpdate) >= 3) {
                    	    // Recalculer le handicap tous les 3 parties après les 5 premières
                    	    var avgRecentScore = recentScores.reduce((sum, s) => sum + s, 0) / recentScores.length;
                    	    var expectedScore = 72 + currentHandicap; // Score attendu basé sur par + handicap
                    
                    	    var performance = avgRecentScore - expectedScore;
                    
                    	    if (performance < -3) {
                        	// Très bonne performance = handicap baisse
                        	change = -0.5 - (Math.random() * 0.5);
                    	    } else if (performance < -1) {
                        	// Bonne performance = légère baisse
                        	change = -0.2 - (Math.random() * 0.3);
                    	    } else if (performance > 3) {
                        	// Mauvaise performance = handicap monte
                        	change = 0.3 + (Math.random() * 0.7);
                    	    } else if (performance > 1) {
                        	// Performance décevante = légère hausse
                        	change = 0.1 + (Math.random() * 0.3);
                    	    } else {
                        	// Performance stable = changement minimal
                        	change = (Math.random() - 0.5) * 0.2;
                    	    }
                    
                    	    lastHandicapUpdate = gameNumber;
                	}
                
                	// Appliquer le changement
                	currentHandicap = Math.max(0, Math.min(36.4, currentHandicap + change));
                	currentHandicap = Math.round(currentHandicap * 10) / 10;
                
                	evolution.push({
                    	    date: dates[j],
                    	    handicap: currentHandicap,
                    	    gameNumber: gameNumber,
                    	    change: change,
                    	    score: grossScore,
                    	    course: courses[j],
                    	    avgRecent: recentScores.length > 0 ? (recentScores.reduce((sum, s) => sum + s, 0) / recentScores.length).toFixed(1) : 'N/A'
                	});
            	    }
        	}
        
        	handicapEvolutionData[player.id] = {
            	    player: player,
            	    playerName: playerName,
            	    evolution: evolution
        	};
    	    }
    
    	    console.log("✅ Évolution avec variation réaliste calculée!");
	}

	// 4. FONCTION POUR CHOISIR LA MÉTHODE DE CALCUL
	function updateHandicapEvolutionMethod(method) {
    	    console.log(`🔄 Mise à jour avec méthode: ${method}`);
    
    	    switch(method) {
        	case 'progressive':
            	    prepareHandicapEvolutionDataProgressive();
            	    break;
        	case 'realistic':
            	    prepareHandicapEvolutionWithRealisticVariation();
            	    break;
        	default:
            	    console.log("❌ Méthode inconnue. Utilisez 'progressive' ou 'realistic'");
            	    return;
    	    }
    
    	    // Mettre à jour l'affichage
    	    if (typeof displayHandicapStats === 'function') {
        	displayHandicapStats();
    	    }
    
    	    if (typeof selectedPlayers !== 'undefined' && selectedPlayers.length > 0) {
        	if (typeof drawHandicapChart === 'function') {
            	    drawHandicapChart();
        	}
    	    }
    
    	    console.log("✅ Affichage mis à jour!");
	}

	// 5. INSTRUCTIONS DE TEST
	console.log("=== INSTRUCTIONS POUR CORRIGER L'ÉVOLUTION ===");
	console.log("1. Diagnostic: diagnoseHandicapProgression()");
	console.log("2. Méthode progressive: updateHandicapEvolutionMethod('progressive')");
	console.log("3. Méthode réaliste: updateHandicapEvolutionMethod('realistic')");
	console.log("4. La méthode réaliste donnera des variations plus visibles");

	// Créer les checkboxes pour sélectionner les joueurs
	function createPlayerCheckboxes() {
    	    var container = document.getElementById('playerCheckboxes');
    	    var html = '';
    
    	    for (var i = 0; i < players.length; i++) {
        	var player = players[i];
        	var totalScores = allScores[i].filter(score => score > 0).length;
        
        	if (totalScores >= 5) { // Seulement les joueurs avec assez de scores
            	    // CORRECTION : Utiliser le nom calculé
            	    var playerName = player.name || (player.firstName + ' ' + player.lastName);
            
            	    html += '<label style="display: flex; align-items: center; gap: 8px; padding: 8px; border: 1px solid #ddd; border-radius: 5px;">' +
                    	    '<input type="checkbox" value="' + player.id + '" onchange="togglePlayer(' + player.id + ')">' +
                    	    '<span><strong>' + playerName + '</strong> (' + totalScores + ' parties)</span>' +
                    	    '</label>';
        	}
    	    }
    
    	    container.innerHTML = html;
	}

	// Sélectionner les joueurs par défaut
	function selectDefaultPlayers() {
    	    var checkboxes = document.querySelectorAll('#playerCheckboxes input[type="checkbox"]');
    	    selectedPlayers = [];
    
    	    // Sélectionner les 3 premiers joueurs avec assez de scores
    	    for (var i = 0; i < Math.min(3, checkboxes.length); i++) {
        	checkboxes[i].checked = true;
        	selectedPlayers.push(parseInt(checkboxes[i].value));
    	    }
	}

	// Basculer la sélection d'un joueur
	function togglePlayer(playerId) {
    	var index = selectedPlayers.indexOf(playerId);
    	if (index > -1) {
        	selectedPlayers.splice(index, 1);
    	} else {
        	selectedPlayers.push(playerId);
    	}
    
    	// Mettre à jour le graphique après chaque changement
    	updateHandicapChart();
	}

	// Sélectionner tous les joueurs
	function selectAllPlayers() {
    	    var checkboxes = document.querySelectorAll('#playerCheckboxes input[type="checkbox"]');
    	    selectedPlayers = [];
    
    	    for (var i = 0; i < checkboxes.length; i++) {
        	checkboxes[i].checked = true;
        	selectedPlayers.push(parseInt(checkboxes[i].value));
    	    }
    
    	    updateHandicapChart();
	}

	// Désélectionner tous les joueurs
	function clearAllPlayers() {
    	    var checkboxes = document.querySelectorAll('#playerCheckboxes input[type="checkbox"]');
    	    selectedPlayers = [];
    
    	    for (var i = 0; i < checkboxes.length; i++) {
        	checkboxes[i].checked = false;
    	    }
    
    	    updateHandicapChart();
    
    	    // CORRECTION : Maintenir l'affichage des statistiques même quand aucun joueur n'est sélectionné
    	    displayHandicapStats();
	}

	// Mettre à jour le graphique
	function updateHandicapChart() {
    	    if (selectedPlayers.length === 0) {
        	document.getElementById('handicapChart').innerHTML = 
            	    '<div style="text-align: center; padding: 50px; color: #666; border: 2px dashed #ddd; border-radius: 8px; background: #f9f9fa;">' +
            	    '<h3 style="color: #999; margin-bottom: 10px;">📈 Graphique d\'Évolution</h3>' +
            	    '<p>Veuillez sélectionner au moins un joueur pour voir le graphique d\'évolution des handicaps.</p>' +
            	    '<p style="font-size: 14px; color: #999;">Les statistiques de tous les joueurs sont affichées ci-dessous.</p>' +
            	    '</div>';
        
        	// CORRECTION : Toujours afficher les statistiques
        	displayHandicapStats();
        	return;
    	    }
    
    	    // Remettre le canvas si des joueurs sont sélectionnés
    	    document.getElementById('handicapChart').innerHTML = 
        	'<canvas id="handicapCanvas" width="1000" height="500" style="max-width: 100%; border: 1px solid #ddd; border-radius: 8px;"></canvas>';
    
    	    drawHandicapChart();
    	    displayHandicapStats();
	}

	// Dessiner le graphique des handicaps
	function drawHandicapChart() {
    	var canvas = document.getElementById('handicapCanvas');
    	var ctx = canvas.getContext('2d');

    	// Dimensions
    	var width = canvas.width;
    	var height = canvas.height;
    	var padding = 60;
    	var chartWidth = width - 2 * padding;
    	var chartHeight = height - 2 * padding;

    	// Nettoyer le canvas
    	ctx.clearRect(0, 0, width, height);

    	// Couleurs pour les joueurs
    	var colors = ['#e74c3c', '#3498db', '#2ecc71', '#f39c12', '#9b59b6', '#1abc9c', '#e67e22', '#34495e', '#f1c40f', '#95a5a6', '#d35400', '#8e44ad', '#16a085'];

    	// Trouver les limites des données (seulement à partir de la 6e partie)
    	var minHandicap = Infinity;
    	var maxHandicap = -Infinity;
    	var maxGames = 0;

    	for (var i = 0; i < selectedPlayers.length; i++) {
        	var playerId = selectedPlayers[i];
        	var evolution = handicapEvolutionData[playerId].evolution;
        
        	for (var j = 0; j < evolution.length; j++) {
            	if (evolution[j].gameNumber >= 5) { // Seulement à partir de la 6e partie
                	minHandicap = Math.min(minHandicap, evolution[j].handicap);
                	maxHandicap = Math.max(maxHandicap, evolution[j].handicap);
                	// Ajuster pour que maxGames représente la plage visible (0 = 6e partie)
                	maxGames = Math.max(maxGames, evolution[j].gameNumber - 5);
            	}
        	}
    	}

    	// Ajouter une marge
    	var handicapRange = maxHandicap - minHandicap;
    	minHandicap -= handicapRange * 0.1;
    	maxHandicap += handicapRange * 0.1;

    	// Dessiner les axes
    	ctx.strokeStyle = '#333';
    	ctx.lineWidth = 2;
    	ctx.beginPath();
    	ctx.moveTo(padding, padding);
    	ctx.lineTo(padding, height - padding);
    	ctx.lineTo(width - padding, height - padding);
    	ctx.stroke();

    	// Dessiner la grille horizontale
    	ctx.strokeStyle = '#e0e0e0';
    	ctx.lineWidth = 1;
    	for (var i = 0; i <= 10; i++) {
        	var y = padding + (chartHeight * i / 10);
        	ctx.beginPath();
        	ctx.moveTo(padding, y);
        	ctx.lineTo(width - padding, y);
        	ctx.stroke();
        
        	// Étiquettes handicap
        	var handicapValue = maxHandicap - (handicapRange * i / 10);
        	ctx.fillStyle = '#666';
        	ctx.font = '12px Arial';
        	ctx.textAlign = 'right';
        	ctx.fillText(handicapValue.toFixed(1), padding - 10, y + 4);
    	}

    	// Dessiner la grille verticale
    	for (var i = 0; i <= maxGames; i += Math.max(1, Math.floor(maxGames / 10))) {
        	var x = padding + (chartWidth * i / maxGames);
        	ctx.beginPath();
        	ctx.moveTo(x, padding);
        	ctx.lineTo(x, height - padding);
        	ctx.stroke();
        
        	// Étiquettes parties (ajuster pour montrer le vrai numéro de partie)
        	ctx.fillStyle = '#666';
        	ctx.font = '12px Arial';
        	ctx.textAlign = 'center';
        	ctx.fillText('P' + (i + 6), x, height - padding + 20); // +6 car on commence à la 6e partie
    	}

    	// Dessiner les lignes des joueurs
    	for (var i = 0; i < selectedPlayers.length; i++) {
        	var playerId = selectedPlayers[i];
        	var playerData = handicapEvolutionData[playerId];
        	var evolution = playerData.evolution;
        	var color = colors[i % colors.length];

        	ctx.strokeStyle = color;
        	ctx.fillStyle = color;
        	ctx.lineWidth = 3;

        	// Filtrer pour ne montrer qu'à partir de la 6e partie (gameNumber >= 5)
        	var visibleEvolution = evolution.filter(point => point.gameNumber >= 5);
        
        	if (visibleEvolution.length === 0) continue;

        	// Dessiner la ligne (seulement pour les parties 6+)
        	ctx.beginPath();
        	for (var j = 0; j < visibleEvolution.length; j++) {
            	var point = visibleEvolution[j];
            	// Ajuster gameNumber pour que la 6e partie devienne la position 0
            	var adjustedGameNumber = point.gameNumber - 5;
            	var x = padding + (chartWidth * adjustedGameNumber / maxGames);
            	var y = padding + (chartHeight * (maxHandicap - point.handicap) / handicapRange);

            	if (j === 0) {
                	ctx.moveTo(x, y);
            	} else {
                	ctx.lineTo(x, y);
            	}
        	}
        	ctx.stroke();

        	// Dessiner les points (seulement pour les parties 6+)
        	for (var j = 0; j < visibleEvolution.length; j++) {
            	var point = visibleEvolution[j];
            	var adjustedGameNumber = point.gameNumber - 5;
            	var x = padding + (chartWidth * adjustedGameNumber / maxGames);
            	var y = padding + (chartHeight * (maxHandicap - point.handicap) / handicapRange);

            	ctx.beginPath();
            	ctx.arc(x, y, 4, 0, 2 * Math.PI);
            	ctx.fill();
        	}
    	}

    	// Légende
    	var legendY = 20;
    	for (var i = 0; i < selectedPlayers.length; i++) {
        	var playerId = selectedPlayers[i];
        	var playerData = handicapEvolutionData[playerId];
        	var color = colors[i % colors.length];
        
        	var playerName = playerData.playerName || playerData.player.name || (playerData.player.firstName + ' ' + playerData.player.lastName);
        
        	ctx.fillStyle = color;
        	ctx.fillRect(width - 200, legendY + (i * 25), 15, 15);
        
        	ctx.fillStyle = '#333';
        	ctx.font = '14px Arial';
        	ctx.textAlign = 'left';
        	ctx.fillText(playerName, width - 180, legendY + (i * 25) + 12);
    	}

    	// Titre
    	ctx.fillStyle = '#333';
    	ctx.font = 'bold 16px Arial';
    	ctx.textAlign = 'center';
    	ctx.fillText('Évolution des Handicaps par Partie (à partir de la 6e partie)', width / 2, 30);

    	// Étiquettes des axes
    	ctx.fillStyle = '#666';
    	ctx.font = '14px Arial';
    	ctx.textAlign = 'center';
    	ctx.fillText('Numéro de Partie', width / 2, height - 10);

    	ctx.save();
    	ctx.translate(20, height / 2);
    	ctx.rotate(-Math.PI / 2);
    	ctx.fillText('Handicap Index', 0, 0);
    	ctx.restore();
	}

	// Afficher les statistiques d'évolution
	function displayHandicapStats() {
    	    // CORRECTION : Afficher les stats pour TOUS les joueurs avec des scores, pas seulement les sélectionnés
    	    var allPlayersWithScores = [];
    
    	    for (var playerId in handicapEvolutionData) {
        	var playerData = handicapEvolutionData[playerId];
        	var evolution = playerData.evolution;
        
        	if (evolution.length >= 2) { // Au moins 2 points pour calculer l'évolution
            	    allPlayersWithScores.push({
                	playerId: playerId,
                	playerData: playerData
            	    });
        	}
    	    }
    
    	    if (allPlayersWithScores.length === 0) {
        	document.getElementById('handicapStats').innerHTML = '<p style="text-align: center; color: #666; padding: 20px;">Aucune donnée d\'évolution disponible</p>';
        	return;
    	    }
    
    	    var html = '<h3>📊 Statistiques d\'Évolution - Tous les Joueurs</h3>';
    	    html += '<p style="color: #666; margin-bottom: 15px;">Évolution des handicaps pour tous les joueurs ayant au moins 5 parties</p>';
    	    html += '<table class="table"><thead><tr><th>Joueur</th><th>Handicap Initial</th><th>Handicap Final</th><th>Changement Total</th><th>Plus Grande Amélioration</th><th>Plus Grande Dégradation</th><th>Parties</th></tr></thead><tbody>';
    
    	    // Trier par changement total (les améliorations en premier)
    	    allPlayersWithScores.sort((a, b) => {
        	var evolutionA = a.playerData.evolution;
        	var evolutionB = b.playerData.evolution;
        	var changeA = evolutionA[evolutionA.length - 1].handicap - evolutionA[0].handicap;
        	var changeB = evolutionB[evolutionB.length - 1].handicap - evolutionB[0].handicap;
        	return changeA - changeB; // Ordre croissant (améliorations négatives en premier)
    	    });
    
    	    for (var i = 0; i < allPlayersWithScores.length; i++) {
        		var playerData = allPlayersWithScores[i].playerData;
        		var evolution = playerData.evolution;
        
        		// Trouver l'handicap à la 6e partie JOUÉE par ce joueur
				var initialHandicapForDisplay = evolution[0].handicap;
				var partiesJouees = 0;
				for (var k = 0; k < evolution.length; k++) {
    				// Vérifier s'il a joué cette partie (a un score)
    				if (evolution[k].score && evolution[k].score > 0) {
        				partiesJouees++;
        				if (partiesJouees === 6) {
            				initialHandicapForDisplay = evolution[k].handicap;
            				break;
        				}
    				}
				}
				// Si le joueur n'a pas 6 parties, garder son handicap initial
				if (partiesJouees < 6) {
    				initialHandicapForDisplay = evolution[0].handicap;
				}

				var initialHandicap = evolution[0].handicap; // Garder le vrai initial pour les calculs
				var finalHandicap = evolution[evolution.length - 1].handicap;
				var totalChange = finalHandicap - initialHandicapForDisplay; // Changement depuis la 6e partie
        
        	var bestChange = 0;
        	var worstChange = 0;
        
        	for (var j = 1; j < evolution.length; j++) {
            	    var change = evolution[j].change;
            	    if (change < bestChange) bestChange = change;
            	    if (change > worstChange) worstChange = change;
        	}
        
        	// Style de ligne selon l'amélioration/dégradation
        	var changeClass = '';
        	var rowStyle = '';
        	if (totalChange < -2) {
            	    changeClass = 'style="color: #28a745; font-weight: bold;"'; // Vert pour grosse amélioration
            	    rowStyle = ' style="background: #f8fff8;"';
        	} else if (totalChange < 0) {
            	    changeClass = 'style="color: #28a745;"'; // Vert pour amélioration
        	} else if (totalChange > 2) {
            	    changeClass = 'style="color: #dc3545; font-weight: bold;"'; // Rouge pour grosse dégradation
            	    rowStyle = ' style="background: #fff8f8;"';
        	} else if (totalChange > 0) {
            	    changeClass = 'style="color: #dc3545;"'; // Rouge pour dégradation
        	}
        
        	var playerName = playerData.playerName || playerData.player.name || (playerData.player.firstName + ' ' + playerData.player.lastName);
        	var totalGames = evolution.length - 1; // -1 car le premier point est l'état initial
        
        	html += '<tr' + rowStyle + '>' +
                	'<td><strong>' + playerName + '</strong></td>' +
                	'<td>' + initialHandicapForDisplay.toFixed(1) + '</td>' +
                	'<td>' + finalHandicap.toFixed(1) + '</td>' +
                	'<td ' + changeClass + '><strong>' + (totalChange > 0 ? '+' : '') + totalChange.toFixed(1) + '</strong></td>' +
                	'<td style="color: #28a745;">' + bestChange.toFixed(1) + '</td>' +
                	'<td style="color: #dc3545;">+' + worstChange.toFixed(1) + '</td>' +
                	'<td>' + totalGames + '</td>' +
                	'</tr>';
    	    }
    
    	    html += '</tbody></table>';
    
    	    // Ajouter une légende
    	    html += '<div style="margin-top: 15px; padding: 10px; background: #f8f9fa; border-radius: 5px; font-size: 14px;">' +
            	    '<strong>Légende:</strong> ' +
            	    '<span style="color: #28a745;">🟢 Amélioration du handicap</span> | ' +
            	    '<span style="color: #dc3545;">🔴 Dégradation du handicap</span> | ' +
            	    '<span style="color: #666;">⚪ Changement minimal (±2 points)</span>' +
            	    '</div>';
    
    	    document.getElementById('handicapStats').innerHTML = html;
	}

	// 5. AJOUTER UNE FONCTION POUR FILTRER LES STATISTIQUES PAR SÉLECTION (optionnel) :

	function toggleStatsDisplay() {
    	    var showOnlySelected = document.getElementById('showOnlySelected').checked;
    
    	    if (showOnlySelected && selectedPlayers.length > 0) {
        	displayHandicapStatsFiltered();
    	    } else {
        	displayHandicapStats();
    	    }
	}

	function displayHandicapStatsFiltered() {
    	    if (selectedPlayers.length === 0) return;
    
    	    var html = '<h3>📊 Statistiques d\'Évolution - Joueurs Sélectionnés</h3>';
    	    html += '<table class="table"><thead><tr><th>Joueur</th><th>Handicap Initial</th><th>Handicap Final</th><th>Changement Total</th><th>Plus Grande Amélioration</th><th>Plus Grande Dégradation</th><th>Parties</th></tr></thead><tbody>';
    
    	    for (var i = 0; i < selectedPlayers.length; i++) {
        	var playerId = selectedPlayers[i];
        	var playerData = handicapEvolutionData[playerId];
        	var evolution = playerData.evolution;
        
        	if (evolution.length < 2) continue;
        
        	var initialHandicap = evolution[0].handicap;
        	var finalHandicap = evolution[evolution.length - 1].handicap;
        	// Trouver l'handicap à la 6e partie JOUÉE par ce joueur
			var initialHandicapForDisplay = evolution[0].handicap;
			var partiesJouees = 0;
			for (var k = 0; k < evolution.length; k++) {
    			// Vérifier s'il a joué cette partie (a un score)
    			if (evolution[k].score && evolution[k].score > 0) {
        			partiesJouees++;
        			if (partiesJouees === 6) {
            			initialHandicapForDisplay = evolution[k].handicap;
            			break;
        			}
    			}
			}
			// Si le joueur n'a pas 6 parties, garder son handicap initial
			if (partiesJouees < 6) {
    			initialHandicapForDisplay = evolution[0].handicap;
			}
			var totalChange = finalHandicap - initialHandicapForDisplay;
        
        	var bestChange = 0;
        	var worstChange = 0;
        
        	for (var j = 1; j < evolution.length; j++) {
            	    var change = evolution[j].change;
            	    if (change < bestChange) bestChange = change;
            	    if (change > worstChange) worstChange = change;
        	}
        
        	var changeClass = totalChange < 0 ? 'style="color: #28a745;"' : totalChange > 0 ? 'style="color: #dc3545;"' : '';
        	var playerName = playerData.playerName || playerData.player.name || (playerData.player.firstName + ' ' + playerData.player.lastName);
        	var totalGames = evolution.length - 1;
        
        	html += '<tr>' +
                	'<td><strong>' + playerName + '</strong></td>' +
                	'<td>' + initialHandicap.toFixed(1) + '</td>' +
                	'<td>' + finalHandicap.toFixed(1) + '</td>' +
                	'<td ' + changeClass + '><strong>' + (totalChange > 0 ? '+' : '') + totalChange.toFixed(1) + '</strong></td>' +
                	'<td style="color: #28a745;">' + bestChange.toFixed(1) + '</td>' +
                	'<td style="color: #dc3545;">+' + worstChange.toFixed(1) + '</td>' +
                	'<td>' + totalGames + '</td>' +
                	'</tr>';
    	    }
    
    	    html += '</tbody></table>';
    
    	    document.getElementById('handicapStats').innerHTML = html;
	}

	// Exporter les données d'évolution
	function exportHandicapData() {
    	    if (selectedPlayers.length === 0) {
        	alert('Veuillez sélectionner au moins un joueur');
        	return;
    	    }
    
    	    var csvContent = 'Joueur,Date,Numéro Partie,Handicap,Changement,Score,Terrain\n';
    
    	    for (var i = 0; i < selectedPlayers.length; i++) {
        	var playerId = selectedPlayers[i];
        	var playerData = handicapEvolutionData[playerId];
        	var evolution = playerData.evolution;
        
        	// CORRECTION : Utiliser le nom calculé
        	var playerName = playerData.playerName || playerData.player.name || (playerData.player.firstName + ' ' + playerData.player.lastName);
        
        	for (var j = 0; j < evolution.length; j++) {
            	    var point = evolution[j];
            	    csvContent += playerName + ',' +  // UTILISER playerName
                         	point.date + ',' +
                                point.gameNumber + ',' +
                         	point.handicap.toFixed(1) + ',' +
                         	point.change.toFixed(1) + ',' +
                         	(point.score || '') + ',' +
                         	(point.course || '') + '\n';
        	}
    	    }
    
    	    var blob = new Blob([csvContent], { type: 'text/csv' });
    	    var link = document.createElement('a');
    	    link.href = URL.createObjectURL(blob);
    	    link.download = 'evolution-handicaps-' + new Date().toISOString().split('T')[0] + '.csv';
    	    link.click();
	}

	// Variables pour la gestion des joueurs
	var nextPlayerId = 14; // Commencer après les joueurs existants

	// Afficher la section de gestion des joueurs
	function showPlayerManagement() {
    	    hideAllSections();
    	    document.getElementById('playerManagement').style.display = 'block';
    	    setActiveButton(8); // Ajustez selon votre ordre de boutons
    	    loadPlayersGrid();
	}

	// Charger la grille des joueurs
	function loadPlayersGrid() {
    	    var html = '';
    
    	    // CORRECTION : S'assurer que tous les joueurs ont la propriété 'active'
    	    for (var i = 0; i < players.length; i++) {
        	if (players[i].active === undefined) {
            	    players[i].active = true; // Par défaut, tous les joueurs sont actifs
        	}
    	    }
    
    	    var activePlayers = players.filter(p => p.active);
    
    	    console.log("DEBUG: Nombre total de joueurs:", players.length);
    	    console.log("DEBUG: Joueurs actifs:", activePlayers.length);
    
    	    // Statistiques générales
    	    html += '<div class="card" style="background: #f8f9fa;">' +
            	    '<h3>📊 Statistiques du Club</h3>' +
            	    '<div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(150px, 1fr)); gap: 15px;">' +
            	    '<div class="stat-box"><div class="stat-value">' + activePlayers.length + '</div><div class="stat-label">Joueurs Actifs</div></div>' +
            	    '<div class="stat-box"><div class="stat-value">' + (players.length - activePlayers.length) + '</div><div class="stat-label">Joueurs Inactifs</div></div>' +
            	    '<div class="stat-box"><div class="stat-value">' + getAverageHandicap().toFixed(1) + '</div><div class="stat-label">Handicap Moyen</div></div>' +
            	    '<div class="stat-box"><div class="stat-value">' + getTotalGamesPlayed() + '</div><div class="stat-label">Parties Totales</div></div>' +
            	    '</div>' +
            	    '</div>';
    
    	    // CORRECTION : Afficher TOUS les joueurs (actifs ET inactifs) pour la gestion
    	    for (var i = 0; i < players.length; i++) {
        	var player = players[i];
        
        	// CORRECTION : Calculer le nom du joueur
        	var playerName = player.name || (player.firstName + ' ' + player.lastName) || ('Joueur #' + player.id);
        
        	var playerStats = calculatePlayerStats(player);
        	var statusBadge = player.active ? 
            	    '<span style="background: #28a745; color: white; padding: 2px 8px; border-radius: 10px; font-size: 11px;">ACTIF</span>' : 
            	    '<span style="background: #6c757d; color: white; padding: 2px 8px; border-radius: 10px; font-size: 11px;">INACTIF</span>';
        
        	html += '<div class="course-card">' +
                	'<div class="course-header">' +
                	'<div class="course-name">🏌️ ' + playerName + '</div>' +
                	'<div>' +
                	statusBadge +
                	'<button class="btn-secondary" onclick="editPlayer(' + player.id + ')" style="margin-left: 10px;">✏️ Modifier</button>' +
                	'<button class="btn-danger" onclick="togglePlayerStatus(' + player.id + ')">🔄 Statut</button>' +
                	'</div>' +
                	'</div>' +
                
                	'<div style="margin: 10px 0; padding: 10px; background: #f8f9fa; border-radius: 5px;">' +
                	'<div style="display: grid; grid-template-columns: 1fr 1fr; gap: 10px; font-size: 14px;">' +
                	'<div><strong>📞 Téléphone:</strong><br>' + (player.phone || 'Non renseigné') + '</div>' +
                	'<div><strong>📧 Courriel:</strong><br>' + (player.email || 'Non renseigné') + '</div>' +
                	'<div><strong>🏌️ Handicap:</strong><br>' + player.handicap.toFixed(1) + '</div>' +
                	'<div><strong>📅 Membre depuis:</strong><br>' + formatDate(player.dateJoined) + '</div>' +
                	'</div>' +
                	'</div>' +
                
                	'<div style="border: 2px solid #4a7c59; border-radius: 8px; padding: 15px; background: #fff;">' +
                	'<h4 style="margin: 0 0 10px 0; color: #2c5530;">📈 Statistiques Générales</h4>' +
                	'<div style="display: grid; grid-template-columns: repeat(2, 1fr); gap: 10px; text-align: center;">' +
                	'<div style="background: #e8f5e8; padding: 10px; border-radius: 5px;"><strong>' + playerStats.totalGames + '</strong><br><small>Parties</small></div>' +
                	'<div style="background: #e3f2fd; padding: 10px; border-radius: 5px;"><strong>' + playerStats.avgScore.toFixed(1) + '</strong><br><small>Score Moyen</small></div>' +
                	'<div style="background: #fff3e0; padding: 10px; border-radius: 5px;"><strong>' + playerStats.bestScore + '</strong><br><small>Meilleur Score</small></div>' +
                	'<div style="background: #fce4ec; padding: 10px; border-radius: 5px;"><strong>' + playerStats.worstScore + '</strong><br><small>Pire Score</small></div>' +
                	'</div>' +
                	'<div style="margin-top: 10px; text-align: center; font-size: 12px; color: #666;">' +
                	'Dernière partie: ' + (playerStats.lastGame || 'Aucune') + 
                	'</div>' +
                	'</div>' +
                
                	'</div>';
    	    }
    
    	    console.log("DEBUG: HTML généré, longueur:", html.length);
    	    document.getElementById('playersGrid').innerHTML = html;
	}

	// Calculer les statistiques d'un joueur
	function calculatePlayerStats(player) {
    	    var playerIndex = players.findIndex(p => p.id === player.id);
    
    	    console.log("DEBUG: Calcul stats pour joueur", player.id, "index:", playerIndex);
    
    	    if (playerIndex === -1 || !allScores[playerIndex]) {
        	console.log("DEBUG: Pas de scores pour le joueur", player.id);
        	return {
            	    totalGames: 0,
            	    avgScore: 0,
            	    bestScore: 'N/A',
            	    worstScore: 'N/A',
            	    lastGame: 'Aucune'
        	};
    	    }
    
    	    var scores = allScores[playerIndex].filter(score => score > 0);
    
    	    console.log("DEBUG: Joueur", player.id, "a", scores.length, "scores");
    
    	    if (scores.length === 0) {
        	return {
            	    totalGames: 0,
            	    avgScore: 0,
            	    bestScore: 'N/A',
            	    worstScore: 'N/A',
            	    lastGame: 'Aucune'
        	};
    	    }
    
    	    var totalScore = scores.reduce((sum, score) => sum + score, 0);
    	    var avgScore = totalScore / scores.length;
    	    var bestScore = Math.min(...scores);
    	    var worstScore = Math.max(...scores);
    
    	    // Trouver la dernière partie
    	    var lastGameIndex = -1;
    	    for (var i = allScores[playerIndex].length - 1; i >= 0; i--) {
        	if (allScores[playerIndex][i] > 0) {
            	    lastGameIndex = i;
            	    break;
        	}
    	    }
    
    	    var lastGame = lastGameIndex >= 0 ? formatDate(dates[lastGameIndex]) : 'Aucune';
    
    	    return {
        	totalGames: scores.length,
        	avgScore: avgScore,
        	bestScore: bestScore,
        	worstScore: worstScore,
        	lastGame: lastGame
    	    };
	}

	// Afficher le formulaire d'ajout de joueur
	function showAddPlayerForm() {
    	    var form = document.getElementById('addPlayerForm');
    	    if (form.style.display === 'none') {
        	form.style.display = 'block';
        	// Définir la date d'aujourd'hui par défaut
        	document.getElementById('newPlayerDateJoined').value = new Date().toISOString().split('T')[0];
        	// Vider les champs
        	document.getElementById('newPlayerFirstName').value = '';
        	document.getElementById('newPlayerLastName').value = '';
        	document.getElementById('newPlayerPhone').value = '';
        	document.getElementById('newPlayerEmail').value = '';
        	document.getElementById('newPlayerHandicap').value = '';
    	    } else {
        	form.style.display = 'none';
    	    }
	}

	// Sauvegarder un nouveau joueur
	function saveNewPlayer() {
    	    var firstName = document.getElementById('newPlayerFirstName').value.trim();
    	    var lastName = document.getElementById('newPlayerLastName').value.trim();
    	    var phone = document.getElementById('newPlayerPhone').value.trim();
    	    var email = document.getElementById('newPlayerEmail').value.trim();
    	    var handicap = parseFloat(document.getElementById('newPlayerHandicap').value);
    	    var dateJoined = document.getElementById('newPlayerDateJoined').value;
    
    	    // Validation
    	    if (!firstName || !lastName) {
        	alert('Le prénom et le nom sont obligatoires.');
        	return;
    	    }
    
    	    if (isNaN(handicap) || handicap < 0 || handicap > 36.4) {
        	alert('Le handicap doit être un nombre entre 0 et 36.4.');
        	return;
    	    }
    
    	    if (email && !isValidEmail(email)) {
        	alert('L\'adresse courriel n\'est pas valide.');
        	return;
    	    }
    
    	    // Vérifier si le joueur existe déjà
    	    var existingPlayer = players.find(p => 
        	p.firstName.toLowerCase() === firstName.toLowerCase() && 
        	p.lastName.toLowerCase() === lastName.toLowerCase()
    	    );
    
    	    if (existingPlayer) {
        	alert('Un joueur avec ce nom existe déjà.');
        	return;
    	    }
    
    	    // Trouver le prochain ID disponible
    	    var nextId = Math.max(...players.map(p => p.id)) + 1;
    
    	    // Créer le nouveau joueur
    	    var newPlayer = {
        	id: nextId,
        	firstName: firstName,
        	lastName: lastName,
        	name: firstName + ' ' + lastName,
        	phone: phone,
        	email: email,
        	handicap: handicap,
        	dateJoined: dateJoined,
        	active: true
    	    };
    
    	    players.push(newPlayer);
    
    	    // Ajouter un tableau vide de scores pour ce joueur
    	    var emptyScores = new Array(dates.length).fill(null);
    	    allScores.push(emptyScores);
    
            // Sauvegarder dans Firebase
            Promise.all([
                savePlayersToFirebase(),
                saveScoresToFirebase()
            ]).then(function() {
                console.log('Nouveau joueur sauvegardé dans Firebase');
            }).catch(function(error) {
                console.error('Erreur de sauvegarde:', error);
                alert('Erreur de sauvegarde: ' + error.message);
            });

    	    // Sauvegarder et recharger
    	    loadPlayersGrid();
    	    showAddPlayerForm(); // Fermer le formulaire
    
    	    alert('✅ Joueur "' + newPlayer.name + '" ajouté avec succès!');
	}

	// Annuler l'ajout de joueur
	function cancelAddPlayer() {
    	    showAddPlayerForm();
	}

	// Éditer un joueur
	function editPlayer(playerId) {
    	    var player = players.find(p => p.id === playerId);
    	    if (!player) {
        	alert('Joueur non trouvé!');
        	return;
    	    }
    
    	    var playerName = player.name || (player.firstName + ' ' + player.lastName);
    
    	    // Créer un formulaire d'édition plus complet
    	    var formHtml = 
        	'<div style="position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.5); z-index: 1000; display: flex; justify-content: center; align-items: center;">' +
        	'<div style="background: white; padding: 30px; border-radius: 10px; box-shadow: 0 4px 20px rgba(0,0,0,0.3); max-width: 500px; width: 90%;">' +
        	'<h3 style="margin-top: 0; color: #2c5530;">✏️ Modifier ' + playerName + '</h3>' +
        
        	'<div style="margin: 15px 0;">' +
        	'<label style="display: block; font-weight: bold; margin-bottom: 5px;">Prénom:</label>' +
        	'<input type="text" id="editFirstName" value="' + (player.firstName || '') + '" style="width: 100%; padding: 8px; border: 1px solid #ddd; border-radius: 4px;">' +
        	'</div>' +
        
        	'<div style="margin: 15px 0;">' +
        	'<label style="display: block; font-weight: bold; margin-bottom: 5px;">Nom:</label>' +
        	'<input type="text" id="editLastName" value="' + (player.lastName || '') + '" style="width: 100%; padding: 8px; border: 1px solid #ddd; border-radius: 4px;">' +
        	'</div>' +
        
        	'<div style="margin: 15px 0;">' +
        	'<label style="display: block; font-weight: bold; margin-bottom: 5px;">Téléphone:</label>' +
        	'<input type="tel" id="editPhone" value="' + (player.phone || '') + '" style="width: 100%; padding: 8px; border: 1px solid #ddd; border-radius: 4px;">' +
        	'</div>' +
        
        	'<div style="margin: 15px 0;">' +
        	'<label style="display: block; font-weight: bold; margin-bottom: 5px;">Courriel:</label>' +
        	'<input type="email" id="editEmail" value="' + (player.email || '') + '" style="width: 100%; padding: 8px; border: 1px solid #ddd; border-radius: 4px;">' +
        	'</div>' +
        
        	'<div style="margin: 15px 0;">' +
        	'<label style="display: block; font-weight: bold; margin-bottom: 5px;">Handicap:</label>' +
        	'<input type="number" id="editHandicap" value="' + player.handicap + '" step="0.1" min="0" max="36.4" style="width: 100%; padding: 8px; border: 1px solid #ddd; border-radius: 4px;">' +
        	'</div>' +
        
        	'<div style="margin: 15px 0;">' +
        	'<label style="display: block; font-weight: bold; margin-bottom: 5px;">Date d\'adhésion:</label>' +
        	'<input type="date" id="editDateJoined" value="' + (player.dateJoined || '') + '" style="width: 100%; padding: 8px; border: 1px solid #ddd; border-radius: 4px;">' +
        	'</div>' +
        
        	'<div style="margin-top: 25px; text-align: center;">' +
        	'<button onclick="savePlayerEdit(' + playerId + ')" style="background: #4a7c59; color: white; border: none; padding: 10px 20px; border-radius: 5px; margin: 5px; cursor: pointer;">💾 Sauvegarder</button>' +
        	'<button onclick="cancelPlayerEdit()" style="background: #6c757d; color: white; border: none; padding: 10px 20px; border-radius: 5px; margin: 5px; cursor: pointer;">❌ Annuler</button>' +
        	'</div>' +
        
        	'</div>' +
        	'</div>';
    
    	    // Ajouter le formulaire au body
    	    var formDiv = document.createElement('div');
    	    formDiv.id = 'editPlayerForm';
    	    formDiv.innerHTML = formHtml;
    	    document.body.appendChild(formDiv);
	}

	function savePlayerEdit(playerId) {
    	    var player = players.find(p => p.id === playerId);
    	    if (!player) return;
    
    	    var newFirstName = document.getElementById('editFirstName').value.trim();
    	    var newLastName = document.getElementById('editLastName').value.trim();
    	    var newPhone = document.getElementById('editPhone').value.trim();
    	    var newEmail = document.getElementById('editEmail').value.trim();
    	    var newHandicap = parseFloat(document.getElementById('editHandicap').value);
    	    var newDateJoined = document.getElementById('editDateJoined').value;
    
    	    // Validation
    	    if (!newFirstName || !newLastName) {
        	alert('Le prénom et le nom sont obligatoires.');
        	return;
    	    }
    
    	    if (isNaN(newHandicap) || newHandicap < 0 || newHandicap > 36.4) {
        	alert('Le handicap doit être un nombre entre 0 et 36.4.');
        	return;
    	    }
    
    	    if (newEmail && !isValidEmail(newEmail)) {
        	alert('L\'adresse courriel n\'est pas valide.');
        	return;
    	    }
    
    	    // Mettre à jour
    	    player.firstName = newFirstName;
    	    player.lastName = newLastName;
    	    player.name = newFirstName + ' ' + newLastName;
    	    player.phone = newPhone;
    	    player.email = newEmail;
    	    player.handicap = newHandicap;
    	    player.dateJoined = newDateJoined;
    
    	    // Fermer le formulaire
    	    cancelPlayerEdit();
    
    	    // Recharger l'affichage
    	    loadPlayersGrid();
    
    	    alert('✅ Joueur "' + player.name + '" modifié avec succès!');
	}

	function cancelPlayerEdit() {
    	    var formDiv = document.getElementById('editPlayerForm');
    	    if (formDiv) {
        	formDiv.remove();
    	    }
	}
		// Basculer le statut actif/inactif d'un joueur
		function togglePlayerStatus(playerId) {
    	    	    var player = players.find(p => p.id === playerId);
    	    	    if (!player) return;
    
    	    	    var action = player.active ? 'désactiver' : 'réactiver';
    	    	    if (confirm('Voulez-vous ' + action + ' le joueur "' + getPlayerName(player) + '"?')) {
        		player.active = !player.active;
        		savePlayersData();
        		loadPlayersGrid();
        
        		var status = player.active ? 'réactivé' : 'désactivé';
        		alert('✅ Joueur ' + status + ' avec succès!');
    	    	    }
		}

	// Fonctions utilitaires
	function getAverageHandicap() {
    	    var activePlayers = players.filter(p => p.active);
    	    if (activePlayers.length === 0) return 0;
    
    	    var total = activePlayers.reduce((sum, p) => sum + p.handicap, 0);
    	    return total / activePlayers.length;
	}

	function getTotalGamesPlayed() {
    	    var total = 0;
    	    for (var i = 0; i < allScores.length; i++) {
        	total += allScores[i].filter(score => score > 0).length;
    	    }
    	    return total;
	}

	function formatDate(dateString) {
    	    if (!dateString) return 'Non définie';
    	    var date = new Date(dateString);
    	    return date.toLocaleDateString('fr-FR');
	}

	function isValidEmail(email) {
    	    var emailRegex = /^[^\s@]+@[^\s@]+\.[^\s@]+$/;
    	    return emailRegex.test(email);
	}

	// Exporter les données des joueurs
	function exportPlayersData() {
    	    var dataToExport = {
        	players: players,
        	exportDate: new Date().toISOString(),
        	totalPlayers: players.length
    	    };
    
    	    var dataStr = JSON.stringify(dataToExport, null, 2);
    	    var dataBlob = new Blob([dataStr], {type: 'application/json'});
    
    	    var link = document.createElement('a');
    	    link.href = URL.createObjectURL(dataBlob);
    	    link.download = 'joueurs-golf-' + new Date().toISOString().split('T')[0] + '.json';
    	    link.click();
	}	

	// Importer les données des joueurs
	function importPlayersData() {
    	    document.getElementById('importFile').click();
	}

	function handleFileImport(event) {
    	    var file = event.target.files[0];
    	    if (!file) return;
    
    	    var reader = new FileReader();
    	    reader.onload = function(e) {
        	try {
            	    var importedData = JSON.parse(e.target.result);
            	    if (importedData.players && Array.isArray(importedData.players)) {
                	if (confirm('Cela va remplacer tous les joueurs existants. Continuer?')) {
                    	    players = importedData.players;
                    	    nextPlayerId = Math.max(...players.map(p => p.id)) + 1;
                    	    savePlayersData();
                    	    loadPlayersGrid();
                    	    alert('✅ Joueurs importés avec succès!');
                	}	
            	    } else {
                	alert('❌ Format de fichier invalide.');
            	    }
        	} catch (error) {
            	    alert('❌ Erreur lors de l\'importation: ' + error.message);
        	}
    	    };
    	    reader.readAsText(file);
	}

	function savePlayersData() {
    	    // Simuler la sauvegarde
    	    console.log('Joueurs sauvegardés:', players.length + ' joueurs');
	}

	// 4. FONCTION UTILITAIRE POUR OBTENIR LE NOM DU JOUEUR (AJOUTEZ CETTE FONCTION)

	function getPlayerDisplayName(player) {
    	    if (player.name) {
        	return player.name;
    	    } else if (player.firstName && player.lastName) {
        	return player.firstName + ' ' + player.lastName;
    	    } else if (player.firstName) {
        	return player.firstName;
    	    } else {
        	return 'Joueur #' + player.id;
    	    }
	}

	// 5. FONCTION POUR RÉPARER TOUS LES NOMS AUTOMATIQUEMENT

	function fixAllPlayerNames() {
    	    console.log("Réparation des noms de joueurs...");
    
    	    for (var i = 0; i < players.length; i++) {
        	var player = players[i];
        
        	// Si pas de nom mais firstName/lastName existent
        	if (!player.name && player.firstName && player.lastName) {
            	player.name = player.firstName + ' ' + player.lastName;
            	console.log("Réparé:", player.name);
        	}
        	// Si pas de firstName/lastName mais name existe
        	else if (player.name && (!player.firstName || !player.lastName)) {
            	    var parts = player.name.split(' ');
            	    player.firstName = parts[0] || '';
            	    player.lastName = parts.slice(1).join(' ') || '';
            	    console.log("Ajouté firstName/lastName pour:", player.name);
        	}
    	    }
    
    	    // Mettre à jour tous les scores existants avec les bons noms
    	    for (var i = 0; i < scores.length; i++) {
        	var score = scores[i];
        	var player = players.find(p => p.id === score.playerId);
        	if (player && (!score.playerName || score.playerName === 'undefined')) {
            	    score.playerName = getPlayerDisplayName(player);
        	}
    	    }
    
    	    console.log("Réparation terminée!");
	}

	// Variables globales pour la nouvelle partie
	var newRoundPlayers = {};

	// Afficher la section d'ajout de partie
	function showAddRound() {
    	    hideAllSections();
    	    document.getElementById('addRound').style.display = 'block';
    	    setActiveButton(8); // Ajustez selon votre ordre de boutons
    	    loadAddRoundInterface();
	}

	// Charger l'interface d'ajout de partie
	function loadAddRoundInterface() {
    	    // Définir la date d'aujourd'hui par défaut
    	    document.getElementById('newRoundDate').value = new Date().toISOString().split('T')[0];
    
    	    // Charger la liste des terrains
    	    loadCourseOptions();
    
    	    // Charger la grille des joueurs
    	    loadPlayersScoreGrid();
    
    	    // Initialiser les variables
    	    newRoundPlayers = {};

			// AJOUTER CETTE LIGNE :
    		updateGPROptions(); // Forcer l'affichage des options GPR si GPR est sélectionné par défaut
	}

	// Charger les options de terrains
	function loadCourseOptions() {
    	    var select = document.getElementById('newRoundCourse');
    	    select.innerHTML = '<option value="">-- Sélectionner un terrain --</option>';
    
    	    var courseNames = Object.keys(coursesDatabase).sort();
    
    	    for (var i = 0; i < courseNames.length; i++) {
        	var courseName = courseNames[i];
        	var option = document.createElement('option');
        	option.value = courseName;
        	option.textContent = courseName;
        	select.appendChild(option);
    	    }
	}

	// Mettre à jour les départs disponibles selon le terrain sélectionné
	function updateAvailableTees() {
    	    var courseName = document.getElementById('newRoundCourse').value;
    	    var teeSelect = document.getElementById('newRoundDefaultTee');
    
    	    teeSelect.innerHTML = '<option value="">-- Choisir --</option>';
    
    	    if (courseName && coursesDatabase[courseName]) {
        	var tees = coursesDatabase[courseName];
        
        	for (var i = 0; i < tees.length; i++) {
            	    var tee = tees[i];
            	    var option = document.createElement('option');
            	    option.value = tee.tee;
            	    option.textContent = tee.tee.charAt(0).toUpperCase() + tee.tee.slice(1) + 
                               	       ` (Rating: ${tee.rating}, Slope: ${tee.slope}, Par: ${tee.par})`;
            	    teeSelect.appendChild(option);
        	}
    	    }
	}

	// Charger la grille des joueurs pour saisie des scores
	function loadPlayersScoreGrid() {
    	    var html = '';
    
    	    for (var i = 0; i < players.length; i++) {
        	var player = players[i];
        	if (!player.active) continue; // Seulement les joueurs actifs
        
        	var playerName = player.name || (player.firstName + ' ' + player.lastName);
        
        	html += '<div class="course-card" id="playerCard_' + player.id + '">' +
                	'<div class="course-header">' +
                	'<label style="display: flex; align-items: center; gap: 10px;">' +
                	'<input type="checkbox" id="playerCheck_' + player.id + '" onchange="togglePlayerForRound(' + player.id + ')">' +
                	'<span><strong>' + playerName + '</strong></span>' +
                	'<span style="background: #e9ecef; padding: 2px 6px; border-radius: 10px; font-size: 11px;">H: ' + player.handicap.toFixed(1) + '</span>' +
                	'</label>' +
                	'</div>' +
                
                	'<div id="playerInputs_' + player.id + '" style="display: none; margin-top: 15px;">' +
                
                	'<div style="display: grid; grid-template-columns: 1fr 1fr; gap: 10px; margin-bottom: 15px;">' +
                	'<div>' +
                	'<label style="display: block; font-weight: bold; margin-bottom: 5px;">Départ:</label>' +
                	'<select id="playerTee_' + player.id + '" style="width: 100%; padding: 6px;">' +
                	'<option value="">Utiliser défaut</option>' +
                	'</select>' +
                	'</div>' +
                	'<div>' +
                	'<label style="display: block; font-weight: bold; margin-bottom: 5px;">Score Brut:</label>' +
                	'<input type="number" id="playerScore_' + player.id + '" min="50" max="150" style="width: 100%; padding: 6px;" placeholder="Ex: 85">' +
                	'</div>' +
                	'</div>' +
                
                	'<div style="background: #f8f9fa; padding: 10px; border-radius: 5px; font-size: 12px;">' +
                	'<div id="playerPreview_' + player.id + '">Sélectionnez d\'abord un terrain</div>' +
                	'</div>' +
                
                	'</div>' +
                	'</div>';
    	    }
    
    	    document.getElementById('playersScoreGrid').innerHTML = html;
	}

	// Activer/désactiver un joueur pour la partie
	function togglePlayerForRound(playerId) {
    	    var checkbox = document.getElementById('playerCheck_' + playerId);
    	    var inputs = document.getElementById('playerInputs_' + playerId);
    	    var player = players.find(p => p.id === playerId);
    
    	    if (checkbox.checked) {
        	inputs.style.display = 'block';
        
        	// Initialiser les départs disponibles pour ce joueur
        	updatePlayerTeeOptions(playerId);
        
        	// Ajouter à la liste
        	newRoundPlayers[playerId] = {
            	    player: player,
            	    tee: '',
            	    score: null
        	};
        
        	// Calculer l'aperçu si un terrain est sélectionné
        	updatePlayerPreview(playerId);
        
    	    } else {
        	inputs.style.display = 'none';
        	delete newRoundPlayers[playerId];
    	    }
	}

	// Mettre à jour les options de départ pour un joueur
	function updatePlayerTeeOptions(playerId) {
    	    var courseName = document.getElementById('newRoundCourse').value;
    	    var defaultTee = document.getElementById('newRoundDefaultTee').value;
    	    var playerTeeSelect = document.getElementById('playerTee_' + playerId);
    
    	    playerTeeSelect.innerHTML = '<option value="">Utiliser défaut (' + (defaultTee || 'non défini') + ')</option>';
    
    	    if (courseName && coursesDatabase[courseName]) {
        	var tees = coursesDatabase[courseName];
        
        	for (var i = 0; i < tees.length; i++) {
            	    var tee = tees[i];
            	    var option = document.createElement('option');
            	    option.value = tee.tee;
            	    option.textContent = tee.tee.charAt(0).toUpperCase() + tee.tee.slice(1);
            	    playerTeeSelect.appendChild(option);
        	}
    	    }
	}

	// Mettre à jour l'aperçu pour un joueur
	function updatePlayerPreview(playerId) {
    	    var courseName = document.getElementById('newRoundCourse').value;
    	    var defaultTee = document.getElementById('newRoundDefaultTee').value;
    	    var playerTee = document.getElementById('playerTee_' + playerId).value || defaultTee;
    	    var playerScore = parseInt(document.getElementById('playerScore_' + playerId).value);
    	    var player = players.find(p => p.id === playerId);
    
    	    var previewDiv = document.getElementById('playerPreview_' + playerId);
    
    	    if (!courseName || !playerTee) {
        	previewDiv.innerHTML = 'Sélectionnez un terrain et un départ';
        	return;
    	    }
    
    	    // Calculer le handicap de parcours
    	    var courseHandicap = calculateCourseHandicap(player.handicap, courseName, playerTee);
    	    var netScore = playerScore ? (playerScore - courseHandicap).toFixed(1) : '?';
    
    	    var html = '<strong>Aperçu:</strong><br>' +
               	       'Départ: ' + playerTee + ' | ' +
               	       'Handicap parcours: ' + courseHandicap.toFixed(1) + '<br>' +
               	       'Score net: ' + (playerScore ? playerScore + ' - ' + courseHandicap.toFixed(1) + ' = ' + netScore : 'En attente du score');
    
    	    previewDiv.innerHTML = html;
	}

	// Fonctions de sélection rapide
	function selectAllPlayersForRound() {
    	    for (var i = 0; i < players.length; i++) {
        	var player = players[i];
        	if (player.active) {
            	    var checkbox = document.getElementById('playerCheck_' + player.id);
            	    if (!checkbox.checked) {
                	checkbox.checked = true;
                	togglePlayerForRound(player.id);
            	    }
        	}
    	    }
	}

	function clearAllPlayersForRound() {
    	    for (var playerId in newRoundPlayers) {
        	var checkbox = document.getElementById('playerCheck_' + playerId);
        	checkbox.checked = false;
        	togglePlayerForRound(parseInt(playerId));
    	    }
	}

	function selectFrequentPlayers() {
    	    // Sélectionner les joueurs qui ont joué le plus de parties
    	    var playerGameCounts = [];
    
    	    for (var i = 0; i < players.length; i++) {
        	var player = players[i];
        	if (player.active) {
            	    var gameCount = allScores[i] ? allScores[i].filter(score => score > 0).length : 0;
            	    playerGameCounts.push({
                	playerId: player.id,
                	gameCount: gameCount
            	    });
        	}
    	    }
    
    	    // Trier par nombre de parties et prendre les 8 premiers
    	    playerGameCounts.sort((a, b) => b.gameCount - a.gameCount);
    	    var topPlayers = playerGameCounts.slice(0, 8);
    
    	    // Désélectionner tous d'abord
    	    clearAllPlayersForRound();
    
    	    // Sélectionner les joueurs fréquents
    	    for (var i = 0; i < topPlayers.length; i++) {
        	var playerId = topPlayers[i].playerId;
        	var checkbox = document.getElementById('playerCheck_' + playerId);
        	checkbox.checked = true;
        	togglePlayerForRound(playerId);
    	    }
	}

	// Aperçu de la partie
	function previewNewRound() {
    	    var date = document.getElementById('newRoundDate').value;
    	    var courseName = document.getElementById('newRoundCourse').value;
    	    var roundType = document.getElementById('newRoundType').value;
    
    	    if (!date || !courseName) {
        	alert('Veuillez sélectionner une date et un terrain.');
        	return;
    	    }
    
    	    var selectedPlayers = Object.keys(newRoundPlayers);
    	    if (selectedPlayers.length === 0) {
        	alert('Veuillez sélectionner au moins un joueur.');
        	return;
    	    }
    
    	    // Collecter les données
    	    var roundData = [];
    	    var hasAllScores = true;
    
    	    for (var i = 0; i < selectedPlayers.length; i++) {
        	var playerId = parseInt(selectedPlayers[i]);
        	var player = players.find(p => p.id === playerId);
        	var defaultTee = document.getElementById('newRoundDefaultTee').value;
        	var playerTee = document.getElementById('playerTee_' + playerId).value || defaultTee;
        	var playerScore = parseInt(document.getElementById('playerScore_' + playerId).value);
        
        	if (!playerScore || !playerTee) {
            	    hasAllScores = false;
        	}
        
        	var courseHandicap = playerTee ? calculateCourseHandicap(player.handicap, courseName, playerTee) : 0;
        	var netScore = playerScore ? playerScore - courseHandicap : null;
        
        	roundData.push({
            	    player: player,
            	    tee: playerTee,
            	    score: playerScore,
            	    courseHandicap: courseHandicap,
            	    netScore: netScore
        	});
    	    }
    
    	    // Trier par score net
    	    roundData.sort((a, b) => {
        	if (!a.netScore) return 1;
        	if (!b.netScore) return -1;
        	return a.netScore - b.netScore;
    	    });
    
    	    // Générer l'aperçu
    	    var html = '<h4>📊 Aperçu de la Partie</h4>' +
               	       '<p><strong>Date:</strong> ' + new Date(date).toLocaleDateString('fr-FR') + '</p>' +
               	       '<p><strong>Terrain:</strong> ' + courseName + '</p>' +
               	       '<p><strong>Type:</strong> ' + (roundType === 'diablo' ? '🏆 Diablo' : roundType === 'gpr' ? '🎯 GPR' : '⛳ Amicale') + '</p>' +
               	       '<p><strong>Joueurs:</strong> ' + selectedPlayers.length + '</p>';
    
    	    if (!hasAllScores) {
        	    html += '<div style="background: #fff3cd; padding: 10px; border-radius: 5px; margin: 10px 0;">' +
                	'⚠️ Certains scores ou départs sont manquants</div>';
    	    }
    
    	    html += '<table class="table">' +
            	    '<thead><tr><th>Pos.</th><th>Joueur</th><th>Départ</th><th>Score Brut</th><th>Handicap</th><th>Score Net</th></tr></thead>' +
            	    '<tbody>';
    
    	    for (var i = 0; i < roundData.length; i++) {
        	var data = roundData[i];
        	var playerName = data.player.name || (data.player.firstName + ' ' + data.player.lastName);
        
        	html += '<tr>' +
                	'<td>' + (data.netScore ? (i + 1) : '-') + '</td>' +
                	'<td><strong>' + playerName + '</strong></td>' +
                	'<td>' + (data.tee || '❌') + '</td>' +
                	'<td>' + (data.score || '❌') + '</td>' +
                	'<td>' + (data.tee ? data.courseHandicap.toFixed(1) : '-') + '</td>' +
                	'<td><strong>' + (data.netScore ? data.netScore.toFixed(1) : '❌') + '</strong></td>' +
                	'</tr>';
    	    }
    
    	    html += '</tbody></table>';
    
    	    document.getElementById('previewContent').innerHTML = html;
    	    document.getElementById('newRoundPreview').style.display = 'block';
	}

    function saveAllToFirebase() {
        showLoading('Sauvegarde en cours...');
    
        Promise.all([
            savePlayersToFirebase(),
            saveScoresToFirebase(),
            saveCoursesToFirebase(),
            saveDatesToFirebase(),
			saveRoundsToFirebase()
        ]).then(function() {
            hideLoading();
            alert('✅ Toutes les données sauvegardées avec succès!');
        }).catch(function(error) {
            hideLoading();
            console.error('Erreur de sauvegarde complète:', error);
            alert('❌ Erreur de sauvegarde: ' + error.message);
        });
    }
    
	// Sauvegarder la nouvelle partie
	function saveNewRound() {
    	    console.log('=== FONCTION saveNewRound() APPELÉE ==='); // AJOUTE CETTE LIGNE

			var date = document.getElementById('newRoundDate').value;
    	    var courseName = document.getElementById('newRoundCourse').value;
    	    var defaultTee = document.getElementById('newRoundDefaultTee').value;
    	    var roundType = document.getElementById('newRoundType').value;
    
			// === LIGNES DE DEBUG À AJOUTER ===
			console.log('=== DEBUG DATE ===');
			console.log('Date récupérée du formulaire:', date);
			console.log('Type de la variable date:', typeof date);

    	    // Validation de base
    	    if (!date || !courseName || !defaultTee) {
        	alert('Veuillez remplir tous les champs obligatoires (date, terrain, départ par défaut).');
        	return;
    	    }
    
    	    var selectedPlayers = Object.keys(newRoundPlayers);
    	    if (selectedPlayers.length === 0) {
        	alert('Veuillez sélectionner au moins un joueur.');
        	return;
    	    }
    
    	    // Vérifier que tous les joueurs ont un score
    	    var missingScores = [];
    	    for (var i = 0; i < selectedPlayers.length; i++) {
        	var playerId = parseInt(selectedPlayers[i]);
        	var playerScore = parseInt(document.getElementById('playerScore_' + playerId).value);
        	var player = players.find(p => p.id === playerId);
        	var playerName = player.name || (player.firstName + ' ' + player.lastName);
        
        	if (!playerScore) {
            	    missingScores.push(playerName);
        	}
    	    }
    
    	    if (missingScores.length > 0) {
        	if (!confirm('Les joueurs suivants n\'ont pas de score :\n' + missingScores.join(', ') + '\n\nContinuer quand même ?')) {
            	return;
        	}
    	    }
    
    	    // Confirmation finale
    	    if (!confirm('Enregistrer cette partie avec ' + selectedPlayers.length + ' joueur(s) ?')) {
        	return;
    	    }
    
    	    // Ajouter la nouvelle partie aux données
    	    var newRoundId = rounds.length + 1;
    	    // Solution simple : utiliser directement la date string
			var dateParts = date.split('-');
			var year = parseInt(dateParts[0]);
			var month = parseInt(dateParts[1]);
			var day = parseInt(dateParts[2]);

			// === AJOUTER CES LIGNES DE DEBUG ===
			console.log('Parties de date:', dateParts);
			console.log('Année:', year, 'Mois:', month, 'Jour:', day);

			// Pour l'affichage et le stockage, garder la date string originale
			var gameDate = new Date(year, month - 1, day);
    
			// === AJOUTER CETTE LIGNE DE DEBUG ===
			console.log('Date finale créée:', gameDate);
			console.log('Date qui sera stockée dans dates[]:', date);

    	    // Récupérer les métadonnées GPR
			var gprPhase = '';
			var finaleFormat = '';
			var isGPRRound = false;

			if (roundType === 'gpr') {
    			isGPRRound = true;
    			gprPhase = document.getElementById('gprPhase').value;
    			finaleFormat = document.getElementById('finaleFormat').value;
			}

			// Déterminer le type automatiquement si "amicale"
			var finalType = roundType;
			if (roundType === 'amicale') {
    			var isDiablo = (courseName === 'Le Diable' || courseName === 'Le Géant' || courseName === 'Manoir des Sables') || month === 9;
    			finalType = isDiablo ? 'diablo' : 'gpr';
			}
    
    	    // Ajouter aux rounds avec métadonnées GPR
			var newRound = {
    			id: newRoundId,
    			date: date,
    			course: courseName,
    			tee: defaultTee,
    			type: finalType,
    			year: year,
    			month: month
			};

			// Ajouter les métadonnées GPR si applicable
			if (isGPRRound) {
    			newRound.gprPhase = gprPhase;
    			newRound.gprFinaleFormat = finaleFormat;
			}

			rounds.push(newRound);

			// Sauvegarder les métadonnées GPR séparément
			if (isGPRRound) {
    			gprRoundsData.push({
        			roundId: newRoundId,
        			phase: gprPhase,
        			finaleFormat: finaleFormat,
        			date: date
    			});
			}
    
    	    // Ajouter aux dates et courses
    	    dates.push(date);
    	    courses.push(courseName);
    	    teeUsed.push(defaultTee);
    
    	    // Étendre allScores pour tous les joueurs
    	    for (var i = 0; i < allScores.length; i++) {
        	allScores[i].push(null);
    	    }
    
    	    // Ajouter les scores des joueurs participants
    	    var savedCount = 0;
    
    	    for (var i = 0; i < selectedPlayers.length; i++) {
        	var playerId = parseInt(selectedPlayers[i]);
        	var playerIndex = players.findIndex(p => p.id === playerId);
        	var playerScore = parseInt(document.getElementById('playerScore_' + playerId).value);
        	var playerTee = document.getElementById('playerTee_' + playerId).value || defaultTee;
        	var player = players.find(p => p.id === playerId);
        
        	if (playerIndex !== -1 && playerScore) {
            	    // Mettre le score dans allScores
            	    allScores[playerIndex][allScores[playerIndex].length - 1] = playerScore;
            
            	    // Ajouter aux scores calculés
            	    var courseHandicap = calculateCourseHandicap(player.handicap, courseName, playerTee);
            	    var netScore = playerScore - courseHandicap;
            	    var playerName = player.name || (player.firstName + ' ' + player.lastName);
            
            	    scores.push({
                	roundId: newRoundId,
                	playerId: playerId,
                	playerName: playerName,
                	score: playerScore,
                	courseHandicap: courseHandicap,
                	net: netScore,
                	tee: playerTee,
                	type: finalType,
                	year: year,
                	month: month
            	    });
            
            	    savedCount++;
        	}
    	    }
            
            // Sauvegarder dans Firebase
            Promise.all([
                saveScoresToFirebase(),
                saveDatesToFirebase()
            ]).then(function() {
                console.log('🔥 TEST DEBUG - LIGNE JUSTE AVANT FIREBASE');
				console.log('Nouvelle partie sauvegardée dans Firebase');
            }).catch(function(error) {
                console.error('Erreur de sauvegarde partie:', error);
                alert('Erreur de sauvegarde: ' + error.message);
            });

    	    // Confirmation et nettoyage
    	    alert('✅ Partie enregistrée avec succès !\n' + savedCount + ' score(s) sauvegardé(s).');
    
    	    resetNewRoundForm();
    
    	    // Optionnel : aller voir la partie dans les détails
    	    if (confirm('Voulez-vous voir cette partie dans les détails ?')) {
        	showDetails();
        	document.getElementById('roundSelect').value = newRoundId;
        	showRoundDetail();
    	    }
	}

	// Réinitialiser le formulaire
	function resetNewRoundForm() {
    	    document.getElementById('newRoundDate').value = new Date().toISOString().split('T')[0];
    	    document.getElementById('newRoundCourse').value = '';
    	    document.getElementById('newRoundDefaultTee').innerHTML = '<option value="">-- Choisir --</option>';
    	    document.getElementById('newRoundType').value = 'gpr';
    	    document.getElementById('newRoundPreview').style.display = 'none';
    
    	    clearAllPlayersForRound();
    	    loadPlayersScoreGrid();
	}

	// === FONCTIONS DE GESTION DES PARTIES ===

	// Supprimer une partie complètement
	function deleteRound(roundId) {
    	if (!confirm('⚠️ ATTENTION ! Supprimer définitivement cette partie ?\n\nCette action ne peut pas être annulée.')) {
        	return;
    	}
    
    	console.log('Suppression de la partie ID:', roundId);
    
    	// Trouver l'index de la partie dans les arrays
    	var roundIndex = rounds.findIndex(r => r.id === roundId);
    	var dateIndex = roundIndex;
    
    	if (roundIndex === -1) {
        	alert('❌ Partie non trouvée !');
        	return;
    	}
    
    	// Supprimer de rounds
    	rounds.splice(roundIndex, 1);
    
    	// Supprimer de dates, courses, teeUsed
    	if (dateIndex !== -1) {
        	dates.splice(dateIndex, 1);
        	courses.splice(dateIndex, 1);
        	teeUsed.splice(dateIndex, 1);
    	}
    
    	// Supprimer les scores de tous les joueurs pour cette partie
    	for (var i = 0; i < allScores.length; i++) {
        	if (allScores[i] && dateIndex !== -1) {
            	allScores[i].splice(dateIndex, 1);
        	}
    	}
    
    	// Supprimer de l'array scores
    	scores = scores.filter(s => s.roundId !== roundId);
    
    	// Supprimer des métadonnées GPR
    	gprRoundsData = gprRoundsData.filter(g => g.roundId !== roundId);
    
    	// Sauvegarder dans Firebase
    	Promise.all([
        	saveScoresToFirebase(),
        	saveDatesToFirebase()
    	]).then(function() {
        	console.log('Partie supprimée de Firebase');
        	alert('✅ Partie supprimée avec succès !');
        
        	// Rafraîchir l'affichage
        	if (document.getElementById('details').style.display === 'block') {
            	loadDetails();
        	}
        	if (document.getElementById('gpr').style.display === 'block') {
            	loadGPR();
        	}
        	if (document.getElementById('diablo').style.display === 'block') {
            	loadDiablo();
        	}
        
    	}).catch(function(error) {
        	console.error('Erreur de suppression:', error);
        	alert('❌ Erreur lors de la suppression: ' + error.message);
    	});
	}

	// Afficher le formulaire de modification d'une partie
	function editRound(roundId) {
    	var round = rounds.find(r => r.id === roundId);
    	if (!round) {
        	alert('❌ Partie non trouvée !');
        	return;
    	}
    
    	// Créer la popup de modification
    	var formHtml = 
        	'<div style="position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.5); z-index: 1000; overflow-y: auto;">' +
        	'<div style="background: white; padding: 30px; margin: 50px auto; border-radius: 10px; box-shadow: 0 4px 20px rgba(0,0,0,0.3); max-width: 800px; width: 90%;">' +
        	'<h3 style="margin-top: 0; color: #2c5530;">✏️ Modifier la Partie</h3>' +
        
        	'<div style="margin: 15px 0;">' +
        	'<label style="display: block; font-weight: bold; margin-bottom: 5px;">Date:</label>' +
        	'<input type="date" id="editRoundDate" value="' + round.date + '" style="width: 200px; padding: 8px; border: 1px solid #ddd; border-radius: 4px;">' +
        	'</div>' +
        
        	'<div style="margin: 15px 0;">' +
        	'<label style="display: block; font-weight: bold; margin-bottom: 5px;">Terrain:</label>' +
        	'<select id="editRoundCourse" style="width: 300px; padding: 8px;">';
    
    	// Ajouter les options de terrains
    	var courseNames = Object.keys(coursesDatabase).sort();
    	for (var i = 0; i < courseNames.length; i++) {
        	var selected = courseNames[i] === round.course ? ' selected' : '';
			var courseName = courseNames[i].replace(/"/g, '&quot;');
			formHtml += '<option value="' + courseName + '"' + selected + '>' + courseNames[i] + '</option>';
    	}
    
    	formHtml += '</select></div>' +
        
        	'<div style="margin: 15px 0;">' +
        	'<label style="display: block; font-weight: bold; margin-bottom: 5px;">Type:</label>' +
        	'<select id="editRoundType" style="width: 200px; padding: 8px;" onchange="updateEditGPROptions()">' +
        	'<option value="gpr"' + (round.type === 'gpr' ? ' selected' : '') + '>🎯 GPR</option>' +
        	'<option value="diablo"' + (round.type === 'diablo' ? ' selected' : '') + '>🏆 Diablo</option>' +
        	'<option value="amicale"' + (round.type === 'amicale' ? ' selected' : '') + '>⛳ Amicale</option>' +
        	'</select>' +
        	'</div>' +
        
        	// Options GPR
        	'<div id="editGprOptions" style="display: ' + (round.type === 'gpr' ? 'block' : 'none') + '; margin: 15px 0; padding: 15px; background: #e7f3ff; border-radius: 8px;">' +
        	'<h4 style="margin-top: 0;">⚙️ Configuration GPR</h4>' +
        	'<div style="margin: 10px 0;">' +
       		'<label style="display: block; font-weight: bold; margin-bottom: 5px;">Phase GPR:</label>' +
        	'<select id="editGprPhase" style="width: 200px; padding: 8px;" onchange="updateEditFinaleOptions()">' +
        	'<option value="exhibition"' + (round.gprPhase === 'exhibition' ? ' selected' : '') + '>📊 Exhibition</option>' +
        	'<option value="finale"' + (round.gprPhase === 'finale' ? ' selected' : '') + '>🏆 Finale</option>' +
        	'</select>' +
        	'</div>' +
        	'<div id="editFinaleOptions" style="display: ' + (round.gprPhase === 'finale' ? 'block' : 'none') + '; margin: 10px 0;">' +
        	'<label style="display: block; font-weight: bold; margin-bottom: 5px;">Format finale:</label>' +
        	'<select id="editFinaleFormat" style="width: 200px; padding: 8px;">' +
        	'<option value="2days"' + (round.gprFinaleFormat === '2days' ? ' selected' : '') + '>📅 Finale 2 jours</option>' +
        	'<option value="1day"' + (round.gprFinaleFormat === '1day' ? ' selected' : '') + '>⚡ Finale 1 jour</option>' +
        	'</select>' +
        	'</div>' +
        	'</div>' +
        
        	'<h4>👥 Scores des Joueurs</h4>' +
        	'<div id="editPlayersScores" style="max-height: 300px; overflow-y: auto; border: 1px solid #ddd; padding: 15px; border-radius: 5px;">';
    
    	// Ajouter les scores des joueurs
    	var roundScores = scores.filter(s => s.roundId === roundId);
    	for (var i = 0; i < roundScores.length; i++) {
        	var score = roundScores[i];
        	formHtml += '<div style="display: flex; align-items: center; gap: 15px; margin: 10px 0; padding: 10px; background: #f8f9fa; border-radius: 5px;">' +
            	'<span style="width: 150px; font-weight: bold;">' + score.playerName + '</span>' +
            	'<label>Score: <input type="number" id="editScore_' + score.playerId + '" value="' + score.score + '" min="50" max="150" style="width: 80px; padding: 5px;"></label>' +
            	'<span style="font-size: 12px; color: #666;">Handicap: ' + score.courseHandicap.toFixed(1) + ' | Net: ' + score.net.toFixed(1) + '</span>' +
            	'</div>';
    	}
    
    	formHtml += '</div>' +
        
        	'<div style="margin-top: 25px; text-align: center;">' +
        	'<button onclick="saveRoundEdit(' + roundId + ')" style="background: #4a7c59; color: white; border: none; padding: 12px 24px; border-radius: 5px; margin: 5px; cursor: pointer; font-size: 16px;">💾 Sauvegarder</button>' +
        	'<button onclick="cancelRoundEdit()" style="background: #6c757d; color: white; border: none; padding: 12px 24px; border-radius: 5px; margin: 5px; cursor: pointer; font-size: 16px;">❌ Annuler</button>' +
        	'<button onclick="deleteRound(' + roundId + ')" style="background: #dc3545; color: white; border: none; padding: 12px 24px; border-radius: 5px; margin: 5px; cursor: pointer; font-size: 16px;">🗑️ Supprimer</button>' +
        	'</div>' +
        
        	'</div></div>';
    
    	// Ajouter la popup au body
    	var popup = document.createElement('div');
    	popup.id = 'editRoundPopup';
    	popup.innerHTML = formHtml;
    	document.body.appendChild(popup);
	}

	// Fonctions auxiliaires pour la modification
	function updateEditGPROptions() {
    	var roundType = document.getElementById('editRoundType').value;
    	var gprOptions = document.getElementById('editGprOptions');
    
    	if (roundType === 'gpr') {
        	gprOptions.style.display = 'block';
    	} else {
        	gprOptions.style.display = 'none';
    	}
	}

	function updateEditFinaleOptions() {
    	var gprPhase = document.getElementById('editGprPhase').value;
    	var finaleOptions = document.getElementById('editFinaleOptions');
    
    	if (gprPhase === 'finale') {
        	finaleOptions.style.display = 'block';
    	} else {
        	finaleOptions.style.display = 'none';
    	}
	}

	// Sauvegarder les modifications
	function saveRoundEdit(roundId) {
    	var newDate = document.getElementById('editRoundDate').value;
    	var newCourse = document.getElementById('editRoundCourse').value;
    	var newType = document.getElementById('editRoundType').value;
    	var newGprPhase = document.getElementById('editGprPhase').value;
    	var newFinaleFormat = document.getElementById('editFinaleFormat').value;
    
    	if (!confirm('Sauvegarder les modifications de cette partie ?')) {
        	return;
    	}
    
    	// Mettre à jour l'objet round
    	var round = rounds.find(r => r.id === roundId);
    	var roundIndex = rounds.findIndex(r => r.id === roundId);
    	var dateIndex = roundIndex;
    
    	if (round && roundIndex !== -1) {
        	// Mettre à jour les données de base
        	round.date = newDate;
        	round.course = newCourse;
        	round.type = newType;
        
        	if (newType === 'gpr') {
            	round.gprPhase = newGprPhase;
            	round.gprFinaleFormat = newFinaleFormat;
        	}
        
        	// Mettre à jour les arrays parallèles (utiliser roundIndex au lieu de dateIndex)
			if (roundIndex !== -1) {
    			dates[roundIndex] = newDate;
    			courses[roundIndex] = newCourse;
    			// Garder le même tee pour simplicité, ou ajouter une option pour le modifier
			}
        
        	// Mettre à jour les scores des joueurs
        	var roundScores = scores.filter(s => s.roundId === roundId);
        	for (var i = 0; i < roundScores.length; i++) {
            	var score = roundScores[i];
            	var newScore = parseInt(document.getElementById('editScore_' + score.playerId).value);
            
            	if (newScore && newScore !== score.score) {
                	// Recalculer le handicap de parcours et le net
                	var player = players.find(p => p.id === score.playerId);
                	var teeForPlayer = (score.playerId === 1) ? 'bleu' : 'blanc'; // Logique simplifiée
                	var courseHandicap = calculateCourseHandicap(player.handicap, newCourse, teeForPlayer);
                	var netScore = newScore - courseHandicap;
                
                	// Mettre à jour le score
                	score.score = newScore;
                	score.net = netScore;
                	score.courseHandicap = courseHandicap;
                
                	// Mettre à jour allScores
                	var playerIndex = players.findIndex(p => p.id === score.playerId);
                	if (playerIndex !== -1 && dateIndex !== -1) {
                    	allScores[playerIndex][dateIndex] = newScore;
                	}
            	}
        	}
        
        	// Sauvegarder dans Firebase
        	Promise.all([
            	saveScoresToFirebase(),
            	saveDatesToFirebase()
        	]).then(function() {
            	console.log('Modifications sauvegardées dans Firebase');
            	alert('✅ Partie modifiée avec succès !');
            	cancelRoundEdit();
            
            	// Rafraîchir l'affichage
            	if (document.getElementById('details').style.display === 'block') {
                	loadDetails();
                	document.getElementById('roundSelect').value = roundId;
                	showRoundDetail();
            	}
            
        	}).catch(function(error) {
            	console.error('Erreur de modification:', error);
            	alert('❌ Erreur lors de la modification: ' + error.message);
        	});
    	}
	}

	// Fermer la popup de modification
	function cancelRoundEdit() {
    	var popup = document.getElementById('editRoundPopup');
    	if (popup) {
        	popup.remove();
    	}
	}

	// Fonction pour générer des scores de test
	function generateTestRound() {
    	if (!confirm('Générer une partie de test avec des scores aléatoires ?')) {
        	return;
    	}
    
    	// Sélectionner un terrain au hasard
    	var courseNames = Object.keys(coursesDatabase);
    	var randomCourse = courseNames[Math.floor(Math.random() * courseNames.length)];
    
    	// Date d'aujourd'hui
    	var today = new Date().toISOString().split('T')[0];
    
    	// Sélectionner 6-8 joueurs actifs au hasard
    	var activePlayers = players.filter(p => p.active);
    	var numPlayers = Math.floor(Math.random() * 3) + 6; // 6 à 8 joueurs
    	var selectedPlayers = [];
    
    	for (var i = 0; i < Math.min(numPlayers, activePlayers.length); i++) {
        	var randomIndex = Math.floor(Math.random() * activePlayers.length);
        	var player = activePlayers[randomIndex];
        	if (selectedPlayers.findIndex(p => p.id === player.id) === -1) {
            	selectedPlayers.push(player);
        	}
    	}
    
    	// Générer les scores (par + handicap ± variation aléatoire)
    	var newRoundId = rounds.length + 1;
    	var year = parseInt(today.split('-')[0]);
    	var month = parseInt(today.split('-')[1]);
    
    	// Ajouter la partie
    	rounds.push({
        	id: newRoundId,
        	date: today,
        	course: randomCourse,
        	tee: 'blanc',
        	type: 'gpr',
        	year: year,
        	month: month
    	});
    
    	dates.push(today);
    	courses.push(randomCourse);
    	teeUsed.push('blanc');
    
    	// Étendre allScores
    	for (var i = 0; i < allScores.length; i++) {
        	allScores[i].push(null);
    	}
    
    	// Générer les scores
    	for (var i = 0; i < selectedPlayers.length; i++) {
        	var player = selectedPlayers[i];
        	var playerIndex = players.findIndex(p => p.id === player.id);
        
        	// Score = 72 (par moyen) + handicap + variation (-5 à +10)
        	var baseScore = 72 + player.handicap;
        	var variation = Math.floor(Math.random() * 16) - 5; // -5 à +10
        	var testScore = Math.max(65, Math.min(120, Math.round(baseScore + variation)));
        
        	// Sauvegarder le score
        	allScores[playerIndex][allScores[playerIndex].length - 1] = testScore;
        
        	// Calculer handicap de parcours et net
        	var teeForPlayer = (player.id === 1) ? 'blanc' : 'blanc';
        	var courseHandicap = calculateCourseHandicap(player.handicap, randomCourse, teeForPlayer);
        	var netScore = testScore - courseHandicap;
        	var playerName = player.name || (player.firstName + ' ' + player.lastName);
        
        	scores.push({
            	roundId: newRoundId,
            	playerId: player.id,
            	playerName: playerName,
            	score: testScore,
            	courseHandicap: courseHandicap,
            	net: netScore,
            	tee: teeForPlayer,
            	type: 'gpr',
            	year: year,
            	month: month
        	});
    	}
    
    	// Sauvegarder
    	Promise.all([
        	saveScoresToFirebase(),
        	saveDatesToFirebase()
    	]).then(function() {
        	alert('✅ Partie de test générée avec ' + selectedPlayers.length + ' joueurs !\nTerrain: ' + randomCourse);
        
        	// Aller voir la partie
        	showDetails();
        	loadDetails();
        	document.getElementById('roundSelect').value = newRoundId;
        	showRoundDetail();
        
    	}).catch(function(error) {
        	console.error('Erreur génération test:', error);
        	alert('❌ Erreur: ' + error.message);
    	});
	}
	// Nouvelles fonctions pour le système GPR

	// Afficher/masquer les options GPR
	function updateGPROptions() {
   		console.log('updateGPROptions appelée'); // Pour debug
    	var roundType = document.getElementById('newRoundType').value;
    	var gprOptions = document.getElementById('gprOptions');
    
    	console.log('Type sélectionné:', roundType); // Pour debug
    
    	if (roundType === 'gpr') {
        	gprOptions.style.display = 'block';
        	console.log('Options GPR affichées'); // Pour debug
    	} else {
        	gprOptions.style.display = 'none';
        	console.log('Options GPR masquées'); // Pour debug
    	}
	}

	// Afficher/masquer les options de finale
	function updateFinaleOptions() {
    	var gprPhase = document.getElementById('gprPhase').value;
    	var finaleOptions = document.getElementById('finaleOptions');
    
    	if (gprPhase === 'finale') {
        	finaleOptions.style.display = 'block';
    	} else {
        	finaleOptions.style.display = 'none';
    	}
	}

	// Calculer les points GPR selon les nouvelles règles
	function calculateGPRPoints(position, isNet, isFinale, finaleFormat) {
    	// Points exhibition
    	var exhibitionBrutPoints = [80, 68, 60, 52, 45, 40, 35, 30, 25, 20, 15, 10];
    	var exhibitionNetPoints = [120, 105, 90, 78, 70, 62, 54, 46, 38, 30, 22, 15];
    
    	// Points finale (base pour 2 jours - 200 points par jour)
    	var finaleBrutPoints = [175, 140, 120, 100, 85, 70, 60, 50, 40, 30, 20, 10];
    	var finaleNetPoints = [225, 190, 165, 140, 125, 110, 90, 75, 60, 45, 35, 25];
    
    	var points;
    
    	if (isFinale) {
        	points = isNet ? finaleNetPoints : finaleBrutPoints;
        	// Finale 1 jour = même distribution que 2 jours (400 points total)
        	// Pas besoin de doubler, les points sont déjà corrects pour 400 total
    	} else {
        	points = isNet ? exhibitionNetPoints : exhibitionBrutPoints;
    	}
    
    	// Position est 1-indexée, tableau est 0-indexé
    	return points[Math.min(position - 1, points.length - 1)] || 0;
	}

	// Exclure Éric Gosselin (ID 12) du pointage GPR
	function isEricGosselin(playerId) {
    	return playerId === 13;
	}

	// Variables globales pour le calendrier
	var calendarEvents = [];
	var teeTimeCounter = 1;
	var currentDate = new Date();
	var currentMonth = currentDate.getMonth();
	var currentYear = currentDate.getFullYear();

	// Noms des mois et jours en français
	var monthNames = [
    	'Janvier', 'Février', 'Mars', 'Avril', 'Mai', 'Juin',
    	'Juillet', 'Août', 'Septembre', 'Octobre', 'Novembre', 'Décembre'
	];
	var dayNames = ['Dim', 'Lun', 'Mar', 'Mer', 'Jeu', 'Ven', 'Sam'];

	// Fonction principale pour afficher le calendrier
	function showCalendar() {
    	console.log('🚀 showCalendar() - Version sécurisée');
    
    	hideAllSections();
    
    	var calendarSection = document.getElementById('calendar');
    	if (calendarSection) {
        	calendarSection.style.display = 'block';
        	console.log('✅ Section calendar affichée');
    	} else {
        	console.error('❌ Section calendar non trouvée!');
        	return;
    	}
    
    	setActiveButton('showCalendar');
    
    	// Initialiser variables globales si nécessaire
    	if (typeof currentMonth === 'undefined') {
        	var now = new Date();
        	currentMonth = now.getMonth();
        	currentYear = now.getFullYear();
        	console.log('🔧 Variables initialisées:', currentMonth, currentYear);
    	}
    
    	// Afficher la vue mensuelle
    	showMonthView();
	}

	// Charger les données du calendrier depuis Firebase
	function loadCalendarData() {
    	// Cette fonction sera utilisée plus tard pour charger depuis Firebase
    	return database.ref('calendarEvents').once('value').then(function(snapshot) {
        	if (snapshot.exists()) {
            	calendarEvents = snapshot.val() || [];
        	}
    	}).catch(function(error) {
        	console.log('Pas de données calendrier dans Firebase, utilisation tableau vide');
        	calendarEvents = [];
    	});
	}

	// Sauvegarder les événements dans Firebase
	function saveCalendarToFirebase() {
    	return database.ref('calendarEvents').set(calendarEvents);
	}

	// Afficher la vue mensuelle
	function showMonthView() {
    	// S'assurer que les éléments existent
    	var calendarView = document.getElementById('calendarView');
    	var listView = document.getElementById('listView');
    
    	if (calendarView) {
        	calendarView.style.display = 'block';
    	}
    	if (listView) {
        	listView.style.display = 'none';
    	}
    
    	updateMonthTitle();
    	generateCalendar();
	}

	// Mettre à jour le titre du mois
	function updateMonthTitle() {
    	var monthTitleElement = document.getElementById('monthTitle');
    	if (monthTitleElement) {
        	monthTitleElement.textContent = monthNames[currentMonth] + ' ' + currentYear;
    	}
	}

	// 3. FONCTION generateCalendar ULTRA-SÉCURISÉE
	function generateCalendar() {
    	console.log('=== generateCalendar() appelée ===');
    
    	var calendarViewElement = document.getElementById('calendarView');
    	if (!calendarViewElement) {
        	console.error('❌ Element calendarView non trouvé!');
        	return;
    	}
    	console.log('✅ calendarViewElement trouvé');
    
    	// Variables locales sécurisées
    	var today = new Date();
    	var workingMonth = (typeof currentMonth !== 'undefined') ? currentMonth : today.getMonth();
    	var workingYear = (typeof currentYear !== 'undefined') ? currentYear : today.getFullYear();
    
    	console.log('📅 Mois:', workingMonth, 'Année:', workingYear);
    
    	var html = '<div class="calendar-grid">';
    	console.log('🏗️ Construction HTML commencée');
    
    	// En-têtes des jours (sécurisé)
    	var safeDayNames = ['Dim', 'Lun', 'Mar', 'Mer', 'Jeu', 'Ven', 'Sam'];
    	for (var i = 0; i < safeDayNames.length; i++) {
        	html += '<div class="calendar-header">' + safeDayNames[i] + '</div>';
    	}
    	console.log('✅ En-têtes générés');
    
    	// Calcul dates (sécurisé)
    	try {
        	var firstDay = new Date(workingYear, workingMonth, 1);
        	var startDate = new Date(firstDay);
        	startDate.setDate(startDate.getDate() - firstDay.getDay());
        	console.log('✅ Calcul dates OK');
        
        	// Générer 42 jours (sécurisé)
        	for (var i = 0; i < 42; i++) {
            	var cellDate = new Date(startDate);
            	cellDate.setDate(startDate.getDate() + i);
            
            	var isCurrentMonth = cellDate.getMonth() === workingMonth;
            	var isToday = (cellDate.getDate() === today.getDate() && 
                	          cellDate.getMonth() === today.getMonth() && 
                    	      cellDate.getFullYear() === today.getFullYear());
            
            	var cellClass = 'calendar-day';
            	if (!isCurrentMonth) cellClass += ' other-month';
            	if (isToday) cellClass += ' today';
            
            	// Format date sécurisé
            	var dateStr = formatDateForInput(cellDate);
            
            	html += '<div class="' + cellClass + '" onclick="selectDate(\'' + dateStr + '\')">';
            	html += '<div class="calendar-day-number">' + cellDate.getDate() + '</div>';
            	html += '</div>';
        	}
        	console.log('✅ 42 jours générés');
        
    	} catch (error) {
        	console.error('❌ Erreur dans calcul dates:', error);
        	html += '<div style="padding: 20px; color: red;">Erreur génération calendrier: ' + error.message + '</div>';
    	}
    
    	html += '</div>';
    
    	// Injection HTML
    	try {
        	calendarViewElement.innerHTML = html;
        	console.log('✅ HTML injecté, longueur:', html.length);
        	console.log('📄 HTML aperçu:', html.substring(0, 200) + '...');
    	} catch (error) {
        	console.error('❌ Erreur injection HTML:', error);
    	}
	}

	// Changer de mois
	function changeMonth(direction) {
    	currentMonth += direction;
    	if (currentMonth > 11) {
        	currentMonth = 0;
        	currentYear++;
    	} else if (currentMonth < 0) {
        	currentMonth = 11;
        	currentYear--;
    	}
    	showMonthView();
	}

	// Fonctions utilitaires
	function isDateToday(date) {
    	var today = new Date();
    	return date.getDate() === today.getDate() && 
        	   date.getMonth() === today.getMonth() && 
        	   date.getFullYear() === today.getFullYear();
	}

	function getEventsForDate(date) {
    	var dateStr = formatDateForInput(date);
    	return calendarEvents.filter(function(event) {
        	return event.date === dateStr;
    	});
	}

	// 1. FONCTION formatDateForInput CORRIGÉE (sans padStart)
	function formatDateForInput(date) {
    	var year = date.getFullYear();
    	var month = date.getMonth() + 1;
    	var day = date.getDate();
    
    	// Fonction de padding manuelle (compatible tous navigateurs)
    	function pad(num) {
        	return num < 10 ? '0' + num : num.toString();
    	}
    
    	return year + '-' + pad(month) + '-' + pad(day);
	}

	function selectDate(dateStr) {
    	var eventDateInput = document.getElementById('eventDate');
    	if (eventDateInput) {
        	eventDateInput.value = dateStr;
    	}
    	showAddEvent();
	}

	// Afficher le formulaire d'ajout
	function showAddEvent() {
    	var form = document.getElementById('addEventForm');
    	if (!form) {
        	console.error('Formulaire addEventForm non trouvé!');
        	return;
    	}
    
    	form.style.display = form.style.display === 'none' ? 'block' : 'none';
    
    	if (form.style.display === 'block') {
        	// Initialiser le formulaire
        	var eventDate = document.getElementById('eventDate');
        	var eventComments = document.getElementById('eventComments');
        
        	if (eventDate && !eventDate.value) {
            	eventDate.value = formatDateForInput(new Date());
        	}
        	if (eventComments) {
            	eventComments.value = '';
        	}
        
        	// Charger les terrains et organisateurs
        	loadEventCourseOptions();
        	loadOrganizerOptions();
        
        	// Réinitialiser les heures de départ
        	teeTimeCounter = 1;
        	var teeTimesList = document.getElementById('teeTimesList');
        	if (teeTimesList) {
            	teeTimesList.innerHTML = '';
            	addTeeTime(); // Ajouter une première heure par défaut
        	}
    	}
	}

	// Charger les options de terrains
	function loadEventCourseOptions() {
    	var select = document.getElementById('eventCourse');
    	if (!select) return;
    
    	select.innerHTML = '<option value="">-- Sélectionner un terrain --</option>';
    
    	var courseNames = Object.keys(coursesDatabase).sort();
    	for (var i = 0; i < courseNames.length; i++) {
        	var option = document.createElement('option');
        	option.value = courseNames[i];
        	option.textContent = courseNames[i];
        	select.appendChild(option);
    	}
	}

	// Charger les options d'organisateurs
	function loadOrganizerOptions() {
    	var select = document.getElementById('eventOrganizer');
    	if (!select) return;
    
    	select.innerHTML = '<option value="">-- Sélectionner --</option>';
    
    	for (var i = 0; i < players.length; i++) {
        	var player = players[i];
        	if (player.active) {
            	var option = document.createElement('option');
            	option.value = player.id;
            	option.textContent = player.name || (player.firstName + ' ' + player.lastName);
            	select.appendChild(option);
        	}
    	}
	}

	// Ajouter une heure de départ
	function addTeeTime() {
    	var container = document.getElementById('teeTimesList');
    	if (!container) return;
    
    	var teeTimeId = 'teeTime_' + teeTimeCounter;
    
    	var html = '<div class="tee-time-item" id="' + teeTimeId + '">' +
        	       '<div style="flex: 1;">' +
            	   '<label style="font-weight: bold;">Départ #' + teeTimeCounter + ':</label>' +
            	   '<input type="time" id="time_' + teeTimeId + '" style="margin: 0 10px;">' +
            	   '<button class="btn-danger" onclick="removeTeeTime(\'' + teeTimeId + '\')">❌</button>' +
            	   '</div>' +
            	   '</div>' +
            	   '<div class="foursome-slot" id="foursome_' + teeTimeId + '">' +
            	   '<select class="player-slot" id="p1_' + teeTimeId + '">' +
            	   '<option value="">Joueur 1</option>' +
            	   '</select>' +
            	   '<select class="player-slot" id="p2_' + teeTimeId + '">' +
            	   '<option value="">Joueur 2</option>' +
            	   '</select>' +
            	   '<select class="player-slot" id="p3_' + teeTimeId + '">' +
            	   '<option value="">Joueur 3</option>' +
            	   '</select>' +
            	   '<select class="player-slot" id="p4_' + teeTimeId + '">' +
            	   '<option value="">Joueur 4</option>' +
            	   '</select>' +
            	   '</div>';
    
    	// Créer un div temporaire
    	var tempDiv = document.createElement('div');
    	tempDiv.innerHTML = html;
    	container.appendChild(tempDiv);
    
    	// Remplir les selects avec les joueurs
    	for (var slot = 1; slot <= 4; slot++) {
        	var select = document.getElementById('p' + slot + '_' + teeTimeId);
        	if (select) {
            	for (var i = 0; i < players.length; i++) {
                	var player = players[i];
                	if (player.active) {
                    	var option = document.createElement('option');
                    	option.value = player.id;
                    	option.textContent = player.name || (player.firstName + ' ' + player.lastName);
                    	select.appendChild(option);
                	}
            	}
        	}
    	}
    
    	teeTimeCounter++;
	}

	// Supprimer une heure de départ
	function removeTeeTime(teeTimeId) {
    	var element = document.getElementById(teeTimeId);
    	if (element && element.parentElement) {
        	element.parentElement.remove();
    	}
	}

	// Sauvegarder l'événement
	function saveEvent() {
    	var date = document.getElementById('eventDate').value;
    	var course = document.getElementById('eventCourse').value;
    	var type = document.getElementById('eventType').value;
    	var organizerId = document.getElementById('eventOrganizer').value;
    	var comments = document.getElementById('eventComments').value;
    
    	if (!date || !course) {
        	alert('Veuillez remplir au moins la date et le terrain.');
        	return;
    	}
    
    	// Collecter les heures de départ
    	var teeTimes = [];
    	var teeTimeElements = document.querySelectorAll('[id^="teeTime_"]');
    
    	for (var i = 0; i < teeTimeElements.length; i++) {
        	var teeTimeId = teeTimeElements[i].id;
        	var timeInput = document.getElementById('time_' + teeTimeId);
        	var time = timeInput ? timeInput.value : '';
        
        	if (time) {
            	var foursome = [];
            	for (var slot = 1; slot <= 4; slot++) {
                	var playerSelect = document.getElementById('p' + slot + '_' + teeTimeId);
                	var playerId = playerSelect ? playerSelect.value : '';
                	if (playerId) {
                	    foursome.push(parseInt(playerId));
                	}
            	}
            
            	teeTimes.push({
                	time: time,
                	players: foursome
            	});
        	}
    	}
    
    	// Créer l'événement
    	var newEvent = {
        	id: Date.now(), // ID unique basé sur timestamp
        	date: date,
        	course: course,
        	type: type,
        	organizerId: organizerId ? parseInt(organizerId) : null,
        	organizerName: organizerId ? getPlayerName(parseInt(organizerId)) : 'Non défini',
        	teeTimes: teeTimes,
        	comments: comments,
       		createdAt: new Date().toISOString(),
        	createdBy: 'current_user'
    	};
    
    	calendarEvents.push(newEvent);
    
    	// Sauvegarder dans Firebase
    	saveCalendarToFirebase().then(function() {
        	alert('✅ Partie planifiée avec succès!');
        	showAddEvent(); // Fermer le formulaire
        	refreshCalendarView();
    	}).catch(function(error) {
        	alert('❌ Erreur: ' + error.message);
    	});
	}

	// Vue liste
	function showListView() {
    	var calendarView = document.getElementById('calendarView');
    	var listView = document.getElementById('listView');
    
    	if (calendarView) calendarView.style.display = 'none';
    	if (listView) listView.style.display = 'block';
    
    	var futureEvents = calendarEvents.filter(function(e) {
        	return new Date(e.date) >= new Date();
    	}).sort(function(a, b) {
    	    return new Date(a.date) - new Date(b.date);
    	});
    
    	var html = '<h3>📅 Prochaines Parties</h3>';
    
    	if (futureEvents.length === 0) {
    	    html += '<p style="text-align: center; color: #666;">Aucune partie planifiée</p>';
    	} else {
    	    html += '<div style="max-height: 500px; overflow-y: auto;">';
        
    	    for (var i = 0; i < futureEvents.length; i++) {
    	        var event = futureEvents[i];
        	    var eventDate = new Date(event.date);
            	var dateStr = eventDate.toLocaleDateString('fr-FR', {
                	weekday: 'long',
                	year: 'numeric',
                	month: 'long',
                	day: 'numeric'
            	});
            
            	html += '<div class="card" style="margin: 10px 0; cursor: pointer;" onclick="showEventDetail(' + event.id + ')">' +
                	    '<div style="display: flex; justify-content: space-between; align-items: center;">' +
                    	'<div>' +
                    	'<h4 style="margin: 0;">' + getEventIcon(event.type) + ' ' + dateStr + '</h4>' +
                    	'<p style="margin: 5px 0;"><strong>' + event.course + '</strong></p>' +
                    	'<small>Organisé par: ' + event.organizerName + '</small>' +
                    	'</div>' +
                    	'<div style="text-align: right;">' +
                    	'<strong>' + event.teeTimes.length + ' départ(s)</strong><br>' +
                    	'<small>Premier: ' + (event.teeTimes[0] ? event.teeTimes[0].time : 'N/A') + '</small>' +
                    	'</div>' +
                    	'</div>';
            
            	if (event.comments) {
                	html += '<div style="margin-top: 10px; padding: 10px; background: #f8f9fa; border-radius: 5px;">' +
                    	    '<small>' + event.comments + '</small>' +
                        	'</div>';
            	}
            
            	html += '</div>';
        	}
        
        	html += '</div>';
    	}
    
    	if (listView) {
        	listView.innerHTML = html;
    	}
	}

	// Afficher les détails d'un événement
	function showEventDetail(eventId) {
    	var event = calendarEvents.find(function(e) { return e.id === eventId; });
    	if (!event) return;
    
    	var html = '<div class="event-detail-overlay" onclick="closeEventDetail()"></div>' +
        	       '<div class="event-detail-popup">' +
            	   '<h3>' + getEventIcon(event.type) + ' ' + new Date(event.date).toLocaleDateString('fr-FR') + '</h3>' +
            	   '<p><strong>Terrain:</strong> ' + event.course + '</p>' +
            	   '<p><strong>Organisateur:</strong> ' + event.organizerName + '</p>';
    
    	if (event.comments) {
        	html += '<div style="background: #f8f9fa; padding: 10px; border-radius: 5px; margin: 15px 0;">' +
            	    '<strong>Notes:</strong><br>' + event.comments +
                	'</div>';
    	}
    
    	html += '<h4>⏰ Heures de Départ</h4>';
    
    	for (var i = 0; i < event.teeTimes.length; i++) {
        	var teeTime = event.teeTimes[i];
        	html += '<div style="margin: 10px 0; padding: 10px; background: #e8f5e8; border-radius: 5px;">' +
            	    '<strong>🕒 ' + teeTime.time + '</strong>' +
                	'<div style="display: grid; grid-template-columns: repeat(2, 1fr); gap: 10px; margin-top: 10px;">';
        
        	for (var j = 0; j < teeTime.players.length; j++) {
            	var player = players.find(function(p) { return p.id === teeTime.players[j]; });
            	var playerName = player ? (player.name || (player.firstName + ' ' + player.lastName)) : 'Joueur #' + teeTime.players[j];
            	html += '<div style="background: white; padding: 5px 10px; border-radius: 3px;">' +
                	    (j + 1) + '. ' + playerName +
                    	'</div>';
        	}
        
        	html += '</div></div>';
    	}
    
    	html += '<div style="text-align: center; margin-top: 20px;">' +
        	    '<button class="btn" onclick="editEvent(' + eventId + ')">✏️ Modifier</button>' +
            	'<button class="btn-danger" onclick="deleteEvent(' + eventId + ')">🗑️ Supprimer</button>' +
            	'<button class="btn-secondary" onclick="closeEventDetail()">❌ Fermer</button>' +
            	'</div>' +
            	'</div>';
    
    	// Ajouter à la page
    	var detailDiv = document.createElement('div');
    	detailDiv.id = 'eventDetailPopup';
    	detailDiv.innerHTML = html;
    	document.body.appendChild(detailDiv);
	}

	// Fermer les détails
	function closeEventDetail() {
    	var popup = document.getElementById('eventDetailPopup');
    	if (popup) {
    	    popup.remove();
    	}
	}

	// Fonctions utilitaires
	function getEventIcon(type) {
    	switch(type) {
        	case 'gpr': return '🎯';
        	case 'diablo': return '🏆';
        	case 'felton': return '🏆';
        	case 'doubled': return '🎯';
        	default: return '⛳';
    	}
	}

	function getPlayerName(playerId) {
    	var player = players.find(function(p) { return p.id === playerId; });
    	return player ? (player.name || (player.firstName + ' ' + player.lastName)) : 'Inconnu';
	}

	function cancelAddEvent() {
    	showAddEvent();
	}

	function refreshCalendarView() {
    	// Rafraîchir la vue actuelle
    	if (document.querySelector('.calendar-grid')) {
        	showMonthView();
    	} else {
        	showListView();
    	}
	}

	// Ajouter à hideAllSections
	function hideAllSections() {
    	var sections = ['overview', 'playerScores', 'courses', 'diablo', 'gpr', 'felton', 'doubled', 'progress', 'details', 'handicapEvolution', 'playerManagement', 'addRound', 'calendar'];
    	for (var i = 0; i < sections.length; i++) {
        	var element = document.getElementById(sections[i]);
        	if (element) {
            	element.style.display = 'none';
        	}
    	}
	}

    // Initialisation au chargement
    window.onload = function() {
        // Charger les données depuis Firebase
        loadDataFromFirebase();
	}
	
</script>
</body>
</html>