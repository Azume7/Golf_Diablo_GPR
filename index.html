<!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Gestion Tournois Golf - Scores DÃ©taillÃ©s</title>
    <!-- Firebase SDKs -->
	<script src="https://www.gstatic.com/firebasejs/9.22.0/firebase-app-compat.js"></script>
	<script src="https://www.gstatic.com/firebasejs/9.22.0/firebase-database-compat.js"></script>
	<style>
        body {
            font-family: Arial, sans-serif;
            background: #f0f0f0;
            margin: 0;
            padding: 20px;
        }
        .container {
            max-width: 1400px;
            margin: 0 auto;
            background: white;
            border-radius: 10px;
            padding: 30px;
            box-shadow: 0 4px 8px rgba(0,0,0,0.1);
        }
        h1 { color: #2c5530; text-align: center; margin-bottom: 30px; }
        .nav { text-align: center; margin-bottom: 30px; }
		.nav-row {
    		display: flex;
    		justify-content: center;
    		gap: 10px;
    		margin-bottom: 10px;
    		flex-wrap: wrap;
		}
		.nav-save {
    		display: flex;
    		justify-content: center;
    		margin-top: 15px;
		}
		.nav button {
    		color: white; border: none;
    		padding: 10px 20px; margin: 5px; border-radius: 5px; cursor: pointer;
    		font-size: 14px;
    		transition: all 0.3s ease;
		}
		.nav button:hover { 
    		transform: translateY(-2px);
    		box-shadow: 0 4px 8px rgba(0,0,0,0.2);
		}
		.nav button.active { 
    		box-shadow: 0 0 15px rgba(255,255,255,0.5);
    		font-weight: bold;
		}

		/* Couleurs des boutons */
		.nav-yellow { background: #f39c12; }
		.nav-yellow:hover { background: #e67e22; }
		.nav-purple { background: #9b59b6; }
		.nav-purple:hover { background: #8e44ad; }
		.nav-green { background: #27ae60; }
		.nav-green:hover { background: #229954; }
		.nav-blue { background: #3498db; }
		.nav-blue:hover { background: #2980b9; }
		.nav-save-btn { 
    		background: #e74c3c; 
    		font-weight: bold;
    		padding: 12px 30px;
    		font-size: 16px;
		}
		.nav-save-btn:hover { background: #c0392b; }
        .section { display: none; }
        .section.active { display: block; }
        .btn {
            background: #4a7c59; color: white; border: none;
            padding: 10px 15px; border-radius: 5px; cursor: pointer; margin: 5px;
        }
        .btn:hover { background: #2c5530; }
        .btn-secondary {
            background: #6c757d; color: white; border: none;
            padding: 10px 15px; border-radius: 5px; cursor: pointer; margin: 5px;
        }
        .btn-danger {
            background: #dc3545; color: white; border: none;
            padding: 8px 12px; border-radius: 5px; cursor: pointer; margin: 5px;
        }
        .card {
            background: #f9f9f9; padding: 20px; margin: 15px 0;
            border-radius: 8px; border-left: 4px solid #4a7c59;
        }
        .table {
            width: 100%; border-collapse: collapse; margin: 20px 0;
        }
        .table th, .table td {
            border: 1px solid #ddd; padding: 8px; text-align: left;
        }
        .table th { background: #4a7c59; color: white; }
        .table tr:nth-child(even) { background: #f2f2f2; }
        .alert-success {
            background: #d4edda; color: #155724; border: 1px solid #c3e6cb;
            padding: 15px; margin: 15px 0; border-radius: 5px;
        }
        .alert-danger {
            background: #f8d7da; color: #721c24; border: 1px solid #f5c6cb;
            padding: 15px; margin: 15px 0; border-radius: 5px;
        }
        .form-row {
            margin: 10px 0;
        }
        .form-row label {
            display: inline-block;
            width: 150px;
            font-weight: bold;
        }
        .form-row input, .form-row select {
            padding: 8px;
            border: 1px solid #ddd;
            border-radius: 4px;
        }
        .player-card {
            background: #fff;
            border: 2px solid #4a7c59;
            border-radius: 10px;
            padding: 20px;
            margin: 15px 0;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }
        .player-stats {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 15px;
            margin-top: 15px;
        }
        .stat-box {
            background: #f8f9fa;
            padding: 15px;
            border-radius: 8px;
            text-align: center;
            border: 1px solid #e9ecef;
        }
        .stat-value {
            font-size: 24px;
            font-weight: bold;
            color: #2c5530;
        }
        .stat-label {
            font-size: 14px;
            color: #666;
            margin-top: 5px;
        }
        .score-history {
            max-height: 400px;
            overflow-y: auto;
            margin-top: 20px;
        }
        .score-row {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 10px;
            border-bottom: 1px solid #eee;
        }
        .score-row:nth-child(even) {
            background: #f8f9fa;
        }
        .best-score {
            color: #28a745;
            font-weight: bold;
        }
        .worst-score {
            color: #dc3545;
            font-weight: bold;
        }
        .tournament-badge {
            padding: 3px 8px;
            border-radius: 12px;
            font-size: 12px;
            font-weight: bold;
        }
        .badge-diablo {
            background: #ff6b6b;
            color: white;
        }
        .badge-gpr {
            background: #4ecdc4;
            color: white;
        }
        .course-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(350px, 1fr));
            gap: 20px;
            margin-top: 20px;
        }
        .course-card {
            background: white;
            border: 1px solid #ddd;
            border-radius: 8px;
            padding: 15px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }
        .course-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 10px;
        }
        .course-name {
            font-weight: bold;
            color: #2c5530;
            font-size: 16px;
        }
        .tee-info {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 8px;
            margin: 5px 0;
            background: #f8f9fa;
            border-radius: 5px;
            border-left: 4px solid #4a7c59;
        }
        .tee-color {
            font-weight: bold;
            padding: 2px 8px;
            border-radius: 10px;
            color: white;
            font-size: 12px;
        }
        .tee-blanc { background: #666; }
        .tee-bleu { background: #007bff; }
        .tee-vert { background: #28a745; }
        .tee-jaune { background: #ffc107; color: black; }
        .tee-noir { background: #000; }
        .add-course-form {
            background: #f8f9fa;
            padding: 20px;
            border-radius: 8px;
            border: 2px dashed #4a7c59;
            margin-top: 20px;
        }
        .tee-form-row {
            display: grid;
            grid-template-columns: 1fr 1fr 1fr 1fr auto;
            gap: 10px;
            align-items: center;
            margin: 10px 0;
        }
        .handicap-info {
            background: #e7f3ff;
            padding: 10px;
            border-radius: 5px;
            margin: 10px 0;
            font-size: 14px;
        }
		.calendar-grid {
    		display: grid;
    		grid-template-columns: repeat(7, 1fr);
    		gap: 5px;
    		margin: 20px 0;
		}

		.calendar-header {
    		background: #2c5530;
    		color: white;
    		padding: 10px;
    		text-align: center;
    		font-weight: bold;
		}

		.calendar-day {
    		border: 1px solid #ddd;
    		min-height: 100px;
    		padding: 5px;
    		background: white;
    		position: relative;
		}

		.calendar-day-number {
    		font-weight: bold;
    		margin-bottom: 5px;
		}

		.calendar-event {
    		background: #4a7c59;
    		color: white;
    		padding: 2px 5px;
    		margin: 2px 0;
    		border-radius: 3px;
    		font-size: 11px;
    		cursor: pointer;
    		overflow: hidden;
    		text-overflow: ellipsis;
    		white-space: nowrap;
		}

		.calendar-event:hover {
    		background: #2c5530;
		}

		.tee-time-item {
    		display: flex;
    		align-items: center;
    		justify-content: space-between;
    		padding: 8px;
    		margin: 5px 0;
    		background: #e8f5e8;
    		border-radius: 5px;
		}

		.foursome-slot {
    		display: grid;
    		grid-template-columns: repeat(4, 1fr);
    		gap: 5px;
    		margin-top: 5px;
		}

		.player-slot {
    		padding: 5px;
    		background: white;
    		border: 1px solid #ddd;
    		border-radius: 3px;
    		font-size: 12px;
		}

		.event-detail-popup {
    		position: fixed;
    		top: 50%;
    		left: 50%;
    		transform: translate(-50%, -50%);
    		background: white;
    		padding: 30px;
    		border-radius: 10px;
    		box-shadow: 0 4px 20px rgba(0,0,0,0.3);
    		z-index: 1000;
    		max-width: 600px;
    		width: 90%;
    		max-height: 80vh;
    		overflow-y: auto;
		}

		.event-detail-overlay {
    		position: fixed;
    		top: 0;
    		left: 0;
    		width: 100%;
    		height: 100%;
    		background: rgba(0,0,0,0.5);
    		z-index: 999;
		}
    </style>
</head>
<body>
    <div class="container">
        <h1>ğŸŒï¸ GOLF DIABLO et GPR - Scores DÃ©taillÃ©s ğŸŒï¸</h1>
        
        <div class="nav">
            <!-- PremiÃ¨re ligne -->
            <div class="nav-row">
                <button onclick="showAddRound()" class="nav-yellow">â• Nouvelle Partie</button>
                <button onclick="showDiablo()" class="nav-purple">ğŸ† Coupe Diablo</button>
                <button onclick="showOverview()" class="active nav-green">Vue d'ensemble</button>
                <button onclick="showPlayerScores()" class="nav-green">Scores par Joueur</button>
                <button onclick="showCourses()" class="nav-blue">ğŸŒï¸ Terrains</button>
            </div>
            <!-- DeuxiÃ¨me ligne -->
            <div class="nav-row">
                <button onclick="showProgress()" class="nav-yellow">ğŸ“Š Progression</button>
                <button onclick="showGPR()" class="nav-purple">ğŸ¯ Coupe GPR</button>
                <button onclick="showHandicapEvolution()" class="nav-green">ğŸ“ˆ Ã‰volution Handicaps</button>
                <button onclick="showDetails()" class="nav-green">ğŸ“‹ DÃ©tails</button>
                <button onclick="showPlayerManagement()" class="nav-blue">ğŸ‘¥ Joueurs</button>
            </div>
            <!-- Bouton de sauvegarde centrÃ© -->
            <div class="nav-save">
                <button onclick="saveAllToFirebase()" class="nav-save-btn">ğŸ’¾ Sauvegarder</button>
				<button onclick="showCalendar()" class="nav-blue">ğŸ“… Calendrier</button>
            </div>
        </div>

        <!-- Section Vue d'ensemble -->
        <div id="overview" class="section active">
            <div class="card">
                <h2>ğŸ“Š Statistiques GÃ©nÃ©rales</h2>
                <div id="overviewStats"></div>
            </div>
        </div>

        <!-- Section Scores par Joueur -->
        <div id="playerScores" class="section">
            <div class="card">
                <h2>ğŸ‘¥ SÃ©lectionner un Joueur</h2>
                <select id="playerSelect" style="width: 300px; padding: 10px;" onchange="showPlayerDetail()">
                    <option value="">-- Choisir un joueur --</option>
                </select>
            </div>
            <div id="playerDetail"></div>
        </div>

        <!-- Section Terrains -->
        <div id="courses" class="section">
            <div class="card">
                <h2>ğŸŒï¸ Gestion des Terrains</h2>
                <p>Base de donnÃ©es complÃ¨te avec ratings et slopes pour le calcul des handicaps</p>
                <div class="handicap-info">
                    <strong>â„¹ï¸ Calcul des Handicaps:</strong> Les handicaps de parcours sont calculÃ©s avec la formule officielle complÃ¨te : 
                    <em>(Handicap Index Ã— Slope Rating) Ã· 113 + (Course Rating - Par)</em>. 
                    <br>Rating = difficultÃ© pour un scratch, Slope = difficultÃ© relative, Par = nombre de coups de rÃ©fÃ©rence.
                </div>
                <button class="btn" onclick="toggleAddCourseForm()">â• Ajouter un Terrain</button>
                <button class="btn-secondary" onclick="exportCourses()">ğŸ“ Exporter Terrains</button>
            </div>
            
            <div id="addCourseForm" class="add-course-form" style="display: none;">
                <h3>â• Ajouter un Nouveau Terrain</h3>
                <div class="form-row">
                    <label>Nom du terrain:</label>
                    <input type="text" id="newCourseName" placeholder="Ex: Club de Golf Exemple" style="width: 300px;">
                </div>
                
                <h4>DÃ©parts disponibles:</h4>
                <div id="teeInputs">
                    <div class="tee-form-row">
                        <select>
                            <option value="blanc">Blanc</option>
                            <option value="bleu">Bleu</option>
                            <option value="vert">Vert</option>
                            <option value="jaune">Jaune</option>
                            <option value="noir">Noir</option>
                        </select>
                        <input type="number" placeholder="Rating (ex: 69.5)" step="0.1" min="60" max="80">
                        <input type="number" placeholder="Slope (ex: 123)" min="85" max="155">
                        <button type="button" class="btn-danger" onclick="removeTeeInput(this)">âŒ</button>
                    </div>
                </div>
                
                <button class="btn-secondary" onclick="addTeeInput()">â• Ajouter un DÃ©part</button>
                <br><br>
                <button class="btn" onclick="saveCourse()">ğŸ’¾ Sauvegarder le Terrain</button>
                <button class="btn-secondary" onclick="cancelAddCourse()">âŒ Annuler</button>
            </div>
            
            <div id="coursesList"></div>
        </div>

        <!-- Section Diablo -->
        <div id="diablo" class="section">
            <h2>ğŸ† Coupe Diablo </h2>
            <div class="card">
                <label><strong>SÃ©lectionner l'annÃ©e:</strong></label>
                <select id="diabloYearSelect" style="width: 150px; padding: 8px; margin: 0 10px;" onchange="loadDiablo()">
                    <option value="">-- Toutes les annÃ©es --</option>
                </select>
                <span id="diabloStatus" style="margin-left: 20px; padding: 5px 10px; border-radius: 15px;"></span>
            </div>
            <div id="diabloContent"></div>
        </div>

        <!-- Section GPR -->
        <div id="gpr" class="section">
            <h2>ğŸ¯ Coupe GPR (Mai Ã  Juillet)</h2>
            <div class="card">
                <label><strong>SÃ©lectionner l'annÃ©e:</strong></label>
                <select id="gprYearSelect" style="width: 150px; padding: 8px; margin: 0 10px;" onchange="loadGPR()">
                    <option value="">-- Toutes les annÃ©es --</option>
                </select>
                <span id="gprStatus" style="margin-left: 20px; padding: 5px 10px; border-radius: 15px;"></span>
            </div>
            <div id="gprContent"></div>
        </div>

        <!-- Section Progression -->
        <div id="progress" class="section">
            <h2>ğŸ“ˆ Progression des Coupes En Cours</h2>
            <div id="progressContent"></div>
        </div>

        <!-- Section DÃ©tails -->
        <div id="details" class="section">
            <h2>ğŸ“Š DÃ©tails par Partie</h2>
            <div class="card">
                <select id="roundSelect" style="width: 100%; padding: 8px;" onchange="showRoundDetail()">
                    <button class="btn" onclick="generateTestRound()" style="margin-left: 10px;">ğŸ² GÃ©nÃ©rer Partie Test</button>
					<option value="">-- SÃ©lectionner une partie --</option>
                </select>
            </div>
            <div id="detailsContent"></div>
        </div>
	
	<!-- Section Ã‰volution Handicaps -->
	<div id="handicapEvolution" class="section">
    	    <div class="card">
        	<h2>ğŸ“ˆ Ã‰volution des Handicaps</h2>
        	<p>Suivez la progression des handicaps de chaque joueur au fil des parties</p>
        
        	<div style="margin: 20px 0;">
            	    <label><strong>SÃ©lectionner les joueurs Ã  comparer:</strong></label>
            	    <div id="playerCheckboxes" style="display: grid; grid-template-columns: repeat(auto-fit, minmax(200px, 1fr)); gap: 10px; margin: 15px 0;"></div>
            	    <button class="btn" onclick="updateHandicapChart()">ğŸ”„ Mettre Ã  jour le graphique</button>
            	    <button class="btn-secondary" onclick="selectAllPlayers()">âœ… Tous</button>
            	    <button class="btn-secondary" onclick="clearAllPlayers()">âŒ Aucun</button>
            	    <button class="btn-secondary" onclick="exportHandicapData()">ğŸ“Š Exporter DonnÃ©es</button>
        	</div>
        
        	<div style="background: #f8f9fa; padding: 15px; border-radius: 8px; margin: 15px 0;">
            	    <strong>LÃ©gende:</strong>
            	    <span style="color: #28a745;">ğŸŸ¢ AmÃ©lioration</span> |
            	    <span style="color: #dc3545;">ğŸ”´ DÃ©gradation</span> |
            	    <span style="color: #6c757d;">âšª Stable</span>
        	</div>
    	    </div>
    
    	    <div id="handicapChart" class="card">
        	<canvas id="handicapCanvas" width="1000" height="500" style="max-width: 100%; border: 1px solid #ddd; border-radius: 8px;"></canvas>
    	    </div>
    
    	    <div id="handicapStats" class="card"></div>
	</div>

	<!-- Section Gestion des Joueurs -->
	<div id="playerManagement" class="section">
    	    <div class="card">
        	<h2>ğŸ‘¥ Gestion des Joueurs</h2>
        	<p>Ajouter, modifier et gÃ©rer les informations des joueurs</p>
        
        	<div style="margin: 20px 0;">
            	    <button class="btn" onclick="showAddPlayerForm()">â• Ajouter un Joueur</button>
            	    <button class="btn-secondary" onclick="exportPlayersData()">ğŸ“ Exporter Liste</button>
            	    <button class="btn-secondary" onclick="importPlayersData()">ğŸ“¥ Importer Liste</button>
            	    <input type="file" id="importFile" accept=".json,.csv" style="display: none;" onchange="handleFileImport(event)">
        	</div>
        
        	<div id="addPlayerForm" class="add-course-form" style="display: none;">
            	    <h3>â• Ajouter un Nouveau Joueur</h3>
            	    <div class="form-row">
                	<label>PrÃ©nom:</label>
                	<input type="text" id="newPlayerFirstName" placeholder="Ex: Jean" style="width: 200px;">
            	    </div>
            	    <div class="form-row">
                	<label>Nom:</label>
                	<input type="text" id="newPlayerLastName" placeholder="Ex: Dupont" style="width: 200px;">
            	    </div>
            	    <div class="form-row">
                	<label>TÃ©lÃ©phone:</label>
                	<input type="tel" id="newPlayerPhone" placeholder="Ex: 514-555-1234" style="width: 200px;">
            	    </div>
            	    <div class="form-row">
                	<label>Courriel:</label>
                	<input type="email" id="newPlayerEmail" placeholder="Ex: jean.dupont@example.com" style="width: 300px;">
            	    </div>
            	    <div class="form-row">
                	<label>Handicap Initial:</label>
                	<input type="number" id="newPlayerHandicap" placeholder="Ex: 15.5" step="0.1" min="0" max="36.4" style="width: 100px;">
            	    </div>
            	    <div class="form-row">
                	<label>Date d'adhÃ©sion:</label>
                	<input type="date" id="newPlayerDateJoined" style="width: 200px;">
            	    </div>
            	    <br>
            	    <button class="btn" onclick="saveNewPlayer()">ğŸ’¾ Sauvegarder</button>
            	    <button class="btn-secondary" onclick="cancelAddPlayer()">âŒ Annuler</button>
        	</div>
    	    </div>
    
    	    <div id="playersGrid" class="course-grid"></div>
	</div>

	<!-- Section Ajouter une Partie -->
	<div id="addRound" class="section">
    	    <div class="card">
        	<h2>â• Ajouter une Nouvelle Partie</h2>
        	<p>Enregistrer les scores d'une nouvelle partie de golf</p>
        
        	<!-- Informations de base de la partie -->
        	<div class="card" style="background: #f8f9fa;">
            	    <h3>ğŸ“… Informations de la Partie</h3>
            
            	    <div class="form-row">
                	<label>Date de la partie:</label>
                	<input type="date" id="newRoundDate" style="width: 200px;">
            	    </div>
            
            	    <div class="form-row">
                	<label>Terrain:</label>
                	<select id="newRoundCourse" style="width: 300px;" onchange="updateAvailableTees()">
                    	    <option value="">-- SÃ©lectionner un terrain --</option>
                	</select>
            	    </div>
            
            	    <div class="form-row">
                	<label>DÃ©part par dÃ©faut:</label>
                	<select id="newRoundDefaultTee" style="width: 150px;">
                    	    <option value="">-- Choisir --</option>
                	</select>
                	<small style="margin-left: 10px; color: #666;">Les joueurs peuvent avoir des dÃ©parts individuels</small>
            	    </div>
            
            	    <div class="form-row">
    					<label>Type de partie:</label>
    					<select id="newRoundType" style="width: 200px;" onchange="updateGPROptions()">
        					<option value="gpr">ğŸ¯ GPR (Mai-Juillet)</option>
        					<option value="diablo">ğŸ† Diablo (Septembre)</option>
        					<option value="amicale">â›³ Partie Amicale</option>
    					</select>
					</div>

					<!-- Nouvelles options GPR -->
					<div id="gprOptions" style="display: block; margin-top: 15px; padding: 15px; background: #e7f3ff; border-radius: 8px;">
    					<h4 style="margin-top: 0; color: #2c5530;">âš™ï¸ Configuration GPR</h4>
    
    					<div class="form-row">
        					<label>Phase GPR:</label>
        					<select id="gprPhase" style="width: 200px;" onchange="updateFinaleOptions()">
            					<option value="exhibition">ğŸ“Š Partie d'Exhibition</option>
            					<option value="finale">ğŸ† Partie de Finale</option>
        						</select>
    						</div>
    
    					<div id="finaleOptions" style="display: none; margin-top: 10px;">
        					<div class="form-row">
            					<label>Format finale:</label>
            					<select id="finaleFormat" style="width: 200px;">
                					<option value="2days">ğŸ“… Finale 2 jours (points rÃ©partis)</option>
                					<option value="1day">âš¡ Finale 1 jour (tous les points)</option>
            					</select>
        					</div>
    					</div>
    
    					<div style="margin-top: 15px; padding: 10px; background: #fff3cd; border-radius: 5px;">
        					<strong>â„¹ï¸ Rappel :</strong> Si votre handicap est de 12 et moins, vous partez des bleus
    					</div>
					</div>
        	</div>
        
			<!-- Section Calendrier -->
			<div id="calendar" class="section">
    			<div class="card">
        			<h2>ğŸ“… Calendrier des Parties</h2>
        			<p>Planifiez vos parties de golf et consultez les prochains Ã©vÃ©nements</p>
        
        			<div style="display: flex; gap: 20px; margin: 20px 0;">
            			<button class="btn" onclick="showAddEvent()">â• Planifier une Partie</button>
            			<button class="btn-secondary" onclick="showMonthView()">ğŸ“… Vue Mensuelle</button>
           				<button class="btn-secondary" onclick="showListView()">ğŸ“‹ Vue Liste</button>
            			<button class="btn-secondary" onclick="exportCalendar()">ğŸ“¥ Exporter</button>
        			</div>
    			</div>
    
    			<!-- Formulaire d'ajout d'Ã©vÃ©nement -->
    			<div id="addEventForm" class="card" style="display: none; background: #f8f9fa;">
        			<h3>â• Planifier une Nouvelle Partie</h3>
        
        			<div style="display: grid; grid-template-columns: 1fr 1fr; gap: 20px;">
            			<div>
                			<div class="form-row">
                    			<label>Date de la partie:</label>
                    			<input type="date" id="eventDate" style="width: 100%;">
                			</div>
                
                			<div class="form-row">
                    			<label>Terrain:</label>
                    			<select id="eventCourse" style="width: 100%;">
                        			<option value="">-- SÃ©lectionner un terrain --</option>
                    			</select>
                			</div>
                
                			<div class="form-row">
                    			<label>Type de partie:</label>
                    			<select id="eventType" style="width: 100%;">
                        			<option value="amicale">â›³ Partie Amicale</option>
                        			<option value="gpr">ğŸ¯ Coupe GPR</option>
                        			<option value="diablo">ğŸ† Coupe Diablo</option>
                        			<option value="felton">ğŸ† Coupe FelTon</option>
                        			<option value="doubled">ğŸ¯ Double D's Cup</option>
                    			</select>
                			</div>
                
                			<div class="form-row">
                    			<label>Organisateur:</label>
                    			<select id="eventOrganizer" style="width: 100%;">
                        			<option value="">-- SÃ©lectionner --</option>
                    			</select>
                			</div>
            			</div>
            
            			<div>
                			<div class="form-row">
                    			<label>Heures de dÃ©part:</label>
                    			<div id="teeTimesList" style="max-height: 200px; overflow-y: auto; border: 1px solid #ddd; padding: 10px; border-radius: 5px;">
                        			<!-- Les heures de dÃ©part seront ajoutÃ©es ici -->
                    			</div>
                    			<button class="btn-secondary" onclick="addTeeTime()" style="margin-top: 10px;">â• Ajouter une heure</button>
                			</div>
                
                			<div class="form-row">
                    			<label>Commentaires/Notes:</label>
                    			<textarea id="eventComments" rows="4" style="width: 100%; padding: 8px;" 
                              			placeholder="Ex: Apportez vos balles, terrain difficile, souper aprÃ¨s la partie..."></textarea>
                			</div>
            			</div>
        			</div>
        
        			<div style="text-align: center; margin-top: 20px;">
            			<button class="btn" onclick="saveEvent()">ğŸ’¾ Enregistrer</button>
            			<button class="btn-secondary" onclick="cancelAddEvent()">âŒ Annuler</button>
            			<button class="btn" onclick="saveAndNotify()" style="background: #e74c3c;">ğŸ“¢ Enregistrer et Notifier</button>
        			</div>
    			</div>
    
    			<!-- Vue du calendrier -->
    			<div id="calendarView" class="card">
        			<!-- Le calendrier sera affichÃ© ici -->
    			</div>
			</div>

        	<!-- SÃ©lection des joueurs et scores -->
        	<div class="card">
            	    <h3>ğŸ‘¥ Joueurs et Scores</h3>
            	    <p>SÃ©lectionnez les joueurs prÃ©sents et saisissez leurs scores</p>
            
            	    <div style="margin: 15px 0;">
                	<button class="btn-secondary" onclick="selectAllPlayersForRound()">âœ… Tous les joueurs</button>
                	<button class="btn-secondary" onclick="clearAllPlayersForRound()">âŒ Aucun joueur</button>
                	<button class="btn-secondary" onclick="selectFrequentPlayers()">â­ Joueurs frÃ©quents</button>
            	    </div>
            
            	    <div id="playersScoreGrid" style="display: grid; grid-template-columns: repeat(auto-fit, minmax(350px, 1fr)); gap: 15px; margin-top: 20px;"></div>
        	</div>
        
        	<!-- Boutons d'action -->
        	<div class="card" style="text-align: center;">
            	    <button class="btn" onclick="saveNewRound()">ğŸ’¾ Enregistrer la Partie</button>
            	    <button class="btn-secondary" onclick="previewNewRound()">ğŸ‘ï¸ AperÃ§u</button>
            	    <button class="btn-secondary" onclick="resetNewRoundForm()">ğŸ”„ RÃ©initialiser</button>
        	</div>
        
        	<!-- AperÃ§u de la partie -->
        	<div id="newRoundPreview" class="card" style="display: none;">
            	    <h3>ğŸ‘ï¸ AperÃ§u de la Partie</h3>
            	    <div id="previewContent"></div>
        	</div>
    	    </div>
	</div>
    </div>

    <script>
		// Configuration Firebase
		const firebaseConfig = {
    		apiKey: "AIzaSyCHh6Fb-m18O-_1Ei6sTEdfnJMyNrSl590",
    		authDomain: "golf-scores-app-bba13.firebaseapp.com",
    		databaseURL: "https://golf-scores-app-bba13-default-rtdb.firebaseio.com",
    		projectId: "golf-scores-app-bba13",
    		storageBucket: "golf-scores-app-bba13.firebasestorage.app",
    		messagingSenderId: "170312505084",
    		appId: "1:170312505084:web:074ae5e6d9d74c70efa979"
		};

		// Initialiser Firebase
		firebase.initializeApp(firebaseConfig);
		const database = firebase.database();

		// Ã‰tat de chargement
		var isDataLoaded = false;
		var loadingElement = null;

		// Fonction pour afficher le statut de chargement
		function showLoading(message) {
    		if (!loadingElement) {
        		loadingElement = document.createElement('div');
        		loadingElement.style.cssText = 'position: fixed; top: 50%; left: 50%; transform: translate(-50%, -50%); background: rgba(0,0,0,0.8); color: white; padding: 20px; border-radius: 10px; z-index: 9999;';
        		document.body.appendChild(loadingElement);
    		}
    		loadingElement.innerHTML = '<div style="text-align: center;"><div style="margin-bottom: 10px;">ğŸ”„</div>' + message + '</div>';
    		loadingElement.style.display = 'block';
		}

		function hideLoading() {
    		if (loadingElement) {
        		loadingElement.style.display = 'none';
    		}
		}

        // Base de donnÃ©es des terrains avec ratings, slopes et pars
        var coursesDatabase = {
            "Parcours de l'Ã®le": [
                {tee: "blanc", rating: 68.6, slope: 122, par: 70},
                {tee: "bleu", rating: 70.9, slope: 127, par: 70}
            ],
            "Parcours de l'Irlande": [
                {tee: "blanc", rating: 69.4, slope: 126, par: 71},
                {tee: "bleu", rating: 72.2, slope: 131, par: 71}
            ],
            "Parcours Atlantide": [
                {tee: "blanc", rating: 68.6, slope: 126, par: 72},
                {tee: "bleu", rating: 70.2, slope: 132, par: 72}
            ],
            "Parcours Don Quichotte": [
                {tee: "blanc", rating: 65.9, slope: 113, par: 71},
                {tee: "bleu", rating: 68.4, slope: 117, par: 71}
            ],
            "Triangle D'Or": [
                {tee: "blanc", rating: 69.8, slope: 123, par: 72},
                {tee: "bleu", rating: 70.8, slope: 127, par: 72}
            ],
            "Hemmingford Parcours FrontiÃ¨re": [
                {tee: "blanc", rating: 70.3, slope: 123, par: 71},
                {tee: "bleu", rating: 71.1, slope: 125, par: 71}
            ],
            "VallÃ©e des Forts": [
                {tee: "blanc", rating: 70.2, slope: 127, par: 72},
                {tee: "bleu", rating: 71.9, slope: 135, par: 72}
            ],
            "St-Zotique": [
                {tee: "blanc", rating: 68, slope: 114, par: 72},
                {tee: "bleu", rating: 70.1, slope: 118, par: 72}
            ],
            "Parcours Le PrÃ©sidentiel": [
                {tee: "blanc", rating: 69.7, slope: 118, par: 72},
                {tee: "bleu", rating: 71.5, slope: 123, par: 72}
            ],
            "Parcours Le Doral": [
                {tee: "blanc", rating: 70, slope: 124, par: 72},
                {tee: "bleu", rating: 71.7, slope: 128, par: 72}
            ],
            "Parcours Woodlands": [
                {tee: "blanc", rating: 68.7, slope: 116, par: 72},
                {tee: "bleu", rating: 70.1, slope: 119, par: 72}
            ],
            "Parcours Bellevue": [
                {tee: "blanc", rating: 69, slope: 115, par: 72},
                {tee: "bleu", rating: 70.3, slope: 118, par: 72}
            ],
            "RiviÃ¨re-Rouge": [
                {tee: "blanc", rating: 68.8, slope: 123, par: 71},
                {tee: "bleu", rating: 70.5, slope: 124, par: 71}
            ],
            "Les LÃ©gendes": [
                {tee: "blanc", rating: 70.8, slope: 118, par: 72},
                {tee: "bleu", rating: 72.3, slope: 126, par: 72}
            ],
            "La Seigneurie": [
                {tee: "blanc", rating: 68.5, slope: 123, par: 70},
                {tee: "bleu", rating: 69.5, slope: 126, par: 70}
            ],
            "Napierville": [
                {tee: "blanc", rating: 68.2, slope: 125, par: 72},
                {tee: "bleu", rating: 70.7, slope: 129, par: 72}
            ],
            "St-Polycarpe": [
                {tee: "blanc", rating: 66.8, slope: 118, par: 72},
                {tee: "bleu", rating: 71, slope: 125, par: 72}
            ],
            "Rive-Sud": [
                {tee: "blanc", rating: 71.2, slope: 124, par: 72},
                {tee: "bleu", rating: 72.4, slope: 127, par: 72}
            ],
            "RiviÃ¨re-Beaudette": [
                {tee: "blanc", rating: 69.2, slope: 117, par: 72},
                {tee: "bleu", rating: 70.6, slope: 120, par: 72}
            ],
            "Vaudreuil": [
                {tee: "blanc", rating: 66.5, slope: 108, par: 70},
                {tee: "bleu", rating: 68.2, slope: 112, par: 70}
            ],
            "Brocart": [
                {tee: "blanc", rating: 68, slope: 115, par: 72},
                {tee: "vert", rating: 69.4, slope: 118, par: 72},
                {tee: "jaune", rating: 69.4, slope: 118, par: 72}
            ],
            "Faon": [
                {tee: "vert", rating: 70.7, slope: 122, par: 71},
                {tee: "jaune", rating: 69.2, slope: 123, par: 71}
            ],
            "Beloeil": [
                {tee: "blanc", rating: 67.2, slope: 123, par: 71},
                {tee: "bleu", rating: 70, slope: 132, par: 71}
            ],
            "GolfdesÃles": [
                {tee: "blanc", rating: 66.5, slope: 110, par: 70},
                {tee: "bleu", rating: 68.5, slope: 115, par: 70}
            ],
            "St-CÃ©saire": [
                {tee: "blanc", rating: 70, slope: 122, par: 72},
                {tee: "bleu", rating: 70, slope: 122, par: 72}
            ],
            "Golf Cowansville": [
                {tee: "blanc", rating: 69.6, slope: 118, par: 72},
                {tee: "bleu", rating: 71, slope: 123, par: 72}
            ],
            "ChÃ¢teau Bromont": [
                {tee: "blanc", rating: 69.3, slope: 123, par: 72},
                {tee: "bleu", rating: 69.8, slope: 116, par: 72}
            ],
            "Golf Coaticook": [
                {tee: "blanc", rating: 66.4, slope: 114, par: 71},
                {tee: "bleu", rating: 68, slope: 119, par: 71}
            ],
            "Golf Farnham": [
                {tee: "blanc", rating: 67.8, slope: 121, par: 71},
                {tee: "bleu", rating: 69.4, slope: 124, par: 71}
            ],
            "Milby": [
                {tee: "blanc", rating: 69.5, slope: 123, par: 73},
                {tee: "bleu", rating: 71.1, slope: 131, par: 73}
            ],
            "Manoir des Sables": [
                {tee: "blanc", rating: 69, slope: 118, par: 71},
                {tee: "bleu", rating: 69, slope: 123, par: 71}
            ],
            "Mont Orford": [
                {tee: "blanc", rating: 69, slope: 118, par: 72},
                {tee: "bleu", rating: 69, slope: 126, par: 72}
            ],
            "Royal Bromont": [
                {tee: "blanc", rating: 67, slope: 114, par: 72},
                {tee: "bleu", rating: 69.3, slope: 120, par: 72}
            ],
            "Parcours du Vieux Village": [
                {tee: "blanc", rating: 68.2, slope: 114, par: 72},
                {tee: "bleu", rating: 70.3, slope: 124, par: 72}
            ],
            "Royal Laurentien": [
                {tee: "blanc", rating: 66.2, slope: 115, par: 71},
                {tee: "bleu", rating: 68.6, slope: 121, par: 71}
            ],
            "Le Diable": [
                {tee: "blanc", rating: 69.9, slope: 126, par: 70},
                {tee: "bleu", rating: 72, slope: 131, par: 70}
            ],
            "Le GÃ©ant": [
                {tee: "vert", rating: 68, slope: 123, par: 72},
                {tee: "noir", rating: 70.4, slope: 125, par: 72}
            ],
            "Arundel": [
                {tee: "blanc", rating: 69.7, slope: 126, par: 72},
                {tee: "bleu", rating: 70.7, slope: 128, par: 72}
            ],
            "La Belle": [
                {tee: "blanc", rating: 68, slope: 121, par: 73},
                {tee: "bleu", rating: 69, slope: 124, par: 73}
            ],
            "Le MaÃ®tre": [
                {tee: "blanc", rating: 68.7, slope: 121, par: 72},
                {tee: "bleu", rating: 70.2, slope: 125, par: 72}
            ],
            "La BÃªte": [
                {tee: "blanc", rating: 68.7, slope: 124, par: 72},
                {tee: "bleu", rating: 71.4, slope: 128, par: 72}
            ],
            "Lorraine": [
                {tee: "blanc", rating: 69.5, slope: 123, par: 72},
                {tee: "bleu", rating: 70.4, slope: 124, par: 72}
            ],
            "St-Jean limitÃ©": [
                {tee: "blanc", rating: 69.3, slope: 120, par: 72},
                {tee: "bleu", rating: 71.4, slope: 123, par: 72}
            ]
        };

        // 1. MODIFIER LE TABLEAU PLAYERS pour ajouter la propriÃ©tÃ© 'name' (REMPLACER VOTRE TABLEAU ACTUEL)
		var rounds = [];
		
		var players = [];

        // DonnÃ©es des parties avec dÃ©parts spÃ©cifiques
        var dates = [
            '2023-06-03', '2023-06-10', '2023-07-01', '2023-07-02', '2023-09-01', '2023-09-02', '2023-09-03',
            '2024-05-04', '2024-05-18', '2024-05-25', '2024-06-08', '2024-06-15', '2024-06-29', '2024-06-30',
            '2024-09-06', '2024-09-07', '2024-09-08', '2025-05-03', '2025-05-17', '2025-06-07', '2025-06-14', '2025-06-21'
        ];

        var courses = [
            'RiviÃ¨re-Rouge', 'Hemmingford Parcours FrontiÃ¨re', 'Parcours Don Quichotte', 'Parcours Don Quichotte',
            'Le Diable', 'Le GÃ©ant', 'Le GÃ©ant', 'Vaudreuil', 'Hemmingford Parcours FrontiÃ¨re', 'VallÃ©e des Forts',
            'Parcours Bellevue', 'RiviÃ¨re-Rouge', 'Parcours Don Quichotte', 'Parcours Don Quichotte',
            'Manoir des Sables', 'Manoir des Sables', 'Manoir des Sables', 'Vaudreuil', 'Hemmingford Parcours FrontiÃ¨re',
            'Lorraine', 'Parcours Bellevue', 'St-Jean limitÃ©'
        ];

        // DÃ©parts utilisÃ©s pour chaque partie (Antonio = bleu pour certaines parties, sinon blanc pour tous)
        var teeUsed = [
            'blanc', 'blanc', 'blanc', 'bleu', 'blanc', 'blanc', 'blanc', 'bleu', 'bleu', 'bleu', 'bleu', 'bleu', 'bleu', 'bleu',
            'blanc', 'blanc', 'bleu', 'bleu', 'bleu', 'bleu', 'blanc', 'bleu'
        ];

        // Fonction pour calculer le handicap de parcours avec la formule complÃ¨te
        function calculateCourseHandicap(playerHandicapIndex, courseName, teeColor) {
            if (!coursesDatabase[courseName]) {
                console.warn('Terrain non trouvÃ©:', courseName);
                return playerHandicapIndex; // Fallback vers handicap fixe
            }
            
            var courseData = coursesDatabase[courseName];
            var teeData = courseData.find(t => t.tee === teeColor);
            
            if (!teeData) {
                // Si le dÃ©part spÃ©cifique n'existe pas, prendre le premier disponible
                teeData = courseData[0];
                console.warn('DÃ©part', teeColor, 'non trouvÃ© pour', courseName, ', utilisation de', teeData.tee);
            }
            
            // Formule complÃ¨te: (Handicap Index Ã— Slope Rating) Ã· 113 + (Course Rating - Par)
            var slopeAdjustment = (playerHandicapIndex * teeData.slope) / 113;
            var ratingAdjustment = teeData.rating - teeData.par;
            var courseHandicap = slopeAdjustment + ratingAdjustment;
            
            return Math.round(courseHandicap * 10) / 10; // Arrondir Ã  1 dÃ©cimale
        }

	// Cache pour Ã©viter les recalculs rÃ©pÃ©tÃ©s
	var handicapCache = {};

    // Fonctions Firebase
    function savePlayersToFirebase() {
        return database.ref('players').set(players);
    }

    function saveScoresToFirebase() {
        return database.ref('allScores').set(allScores);
    }

    function saveCoursesToFirebase() {
        return database.ref('coursesDatabase').set(coursesDatabase);
    }

    function saveDatesToFirebase() {
        return database.ref('gameData').set({
            dates: dates,
            courses: courses,
            teeUsed: teeUsed
	    });
    }

	function saveRoundsToFirebase() {
    	// Nettoyer les propriÃ©tÃ©s undefined avant de sauvegarder
    	var cleanedRounds = rounds.map(function(round) {
        	var cleanRound = {
            	id: round.id,
            	date: round.date,
            	course: round.course,
            	tee: round.tee,
            	type: round.type,
            	year: round.year,
            	month: round.month
        	};
        
        	// Ajouter les propriÃ©tÃ©s GPR seulement si elles existent
        	if (round.gprPhase) {
            	cleanRound.gprPhase = round.gprPhase;
        	}
        	if (round.gprFinaleFormat) {
            	cleanRound.gprFinaleFormat = round.gprFinaleFormat;
        	}
        
        	return cleanRound;
   		});
    
    	return database.ref('rounds').set(cleanedRounds);
	}

    function loadDataFromFirebase() {
    	showLoading('Chargement des donnÃ©es...');

    	return Promise.all([
        	database.ref('players').once('value'),
        	database.ref('allScores').once('value'),
        	database.ref('coursesDatabase').once('value'),
        	database.ref('gameData').once('value')
    	]).then(function(snapshots) {
        	// Charger les joueurs
        	if (snapshots[0].exists()) {
            	players = snapshots[0].val();
        	}
    
        	// Charger les scores
        	if (snapshots[1].exists()) {
            	allScores = snapshots[1].val();
        	}
    
        	// Charger les terrains
        	if (snapshots[2].exists()) {
            	coursesDatabase = snapshots[2].val();
        	}
    
        	// Charger les donnÃ©es de parties
        	if (snapshots[3].exists()) {
            	var gameData = snapshots[3].val();
            	if (gameData.dates) dates = gameData.dates;
            	if (gameData.courses) courses = gameData.courses;
            	if (gameData.teeUsed) teeUsed = gameData.teeUsed;
        	}
        
        	// Charger les rounds
        	return database.ref('rounds').once('value');
        
    		}).then(function(snapshot) {
        		if (snapshot.exists()) {
            		rounds = snapshot.val();
            		console.log('Rounds chargÃ©s:', rounds.length);
            
            		// VÃ©rifier les mÃ©tadonnÃ©es GPR
            		var gprRounds = rounds.filter(r => r.type === 'gpr');
            		console.log('Parties GPR trouvÃ©es:', gprRounds.length);
            		var finaleRounds = gprRounds.filter(r => r.gprPhase === 'finale');
            		console.log('Parties finale trouvÃ©es:', finaleRounds.length);
        		}

        		console.log('DonnÃ©es chargÃ©es:', players.length, 'joueurs,', dates.length, 'parties');
        		isDataLoaded = true;
        		hideLoading();
    
        		// Initialiser l'interface aprÃ¨s chargement
        		fixAllPlayerNames();
        		initializeData();
        		loadOverview();
        
    	}).catch(function(error) {
        	console.error('Erreur de chargement:', error);
        	hideLoading();
        	alert('Erreur de chargement des donnÃ©es: ' + error.message);
    	});
	}

	// Fonction pour calculer le diffÃ©rentiel de score
	function calculateScoreDifferentialReal(grossScore, courseName, teeColor) {
    	    if (grossScore <= 0) {
    			return null;
			}
			if (!coursesDatabase[courseName]) {
        	console.warn('Terrain non trouvÃ©:', courseName);
        	return null;
    	    }
    
    	    var courseData = coursesDatabase[courseName];
    	    var teeData = courseData.find(t => t.tee === teeColor);
    
    	    if (!teeData) {
        	teeData = courseData[0];
        	console.warn('DÃ©part', teeColor, 'non trouvÃ© pour', courseName, ', utilisation de', teeData.tee);
    	    }
    
    	    // Score Differential = (Gross Score - Course Rating) Ã— 113 / Slope Rating
    	    var differential = (grossScore - teeData.rating) * 113 / teeData.slope;
    	    return Math.round(differential * 10) / 10;
	}

	// 3. FONCTION POUR CALCULER LE NOUVEAU HANDICAP BASÃ‰ SUR LES DIFFÃ‰RENTIELS
	function calculateNewHandicapFromDifferentials(differentials, initialHandicap) {
    	    if (differentials.length < 5) {
        	// Pas assez de scores, garder le handicap initial
        	return initialHandicap;
    	    }
    
    	    // Trier les diffÃ©rentiels (meilleurs en premier)
    	    var sortedDifferentials = [...differentials].sort((a, b) => a - b);
    
    	    // DÃ©terminer combien de scores utiliser
    	    var scoresToUse = 1;
    	    if (differentials.length >= 20) {
        	scoresToUse = 8;
    	    } else if (differentials.length >= 15) {
        	scoresToUse = 5;
    	    } else if (differentials.length >= 10) {
        	scoresToUse = 3;
    	    } else if (differentials.length >= 7) {
        	scoresToUse = 2;
    	    }
    
    	    // Prendre les meilleurs diffÃ©rentiels
    	    var bestDifferentials = sortedDifferentials.slice(0, scoresToUse);
    
    	    // Calculer la moyenne
    	    var average = bestDifferentials.reduce((sum, d) => sum + d, 0) / scoresToUse;
    
    	    // Appliquer le facteur 0.96 et arrondir
    	    var newHandicap = average * 0.96;
    
    	    // Limiter entre 0 et 36.4
    	    newHandicap = Math.max(0, Math.min(36.4, newHandicap));
    
    	    return Math.round(newHandicap * 10) / 10;
	}

	// 4. FONCTION POUR FORCER LA MISE Ã€ JOUR COMPLÃˆTE
	function forceHandicapEvolutionUpdate() {
    	    console.log("ğŸš€ FORCE MISE Ã€ JOUR Ã‰VOLUTION HANDICAPS");
    	    console.log("=========================================");
    
    	    // Recalculer toutes les donnÃ©es
    	    prepareHandicapEvolutionData();
    
    	    // Mettre Ã  jour l'affichage immÃ©diatement
    	    if (typeof displayHandicapStats === 'function') {
        	displayHandicapStats();
    	    }
    
    	    // Mettre Ã  jour le graphique si des joueurs sont sÃ©lectionnÃ©s
    	    if (typeof selectedPlayers !== 'undefined' && selectedPlayers.length > 0) {
        	if (typeof drawHandicapChart === 'function') {
            	    drawHandicapChart();
        	}
    	    }
    
    	    // Afficher un rÃ©sumÃ© des changements
    	    console.log("\nğŸ“Š RÃ‰SUMÃ‰ DES Ã‰VOLUTIONS:");
    	    console.log("========================");
    
    	    for (var playerId in handicapEvolutionData) {
        	var playerData = handicapEvolutionData[playerId];
        	var evolution = playerData.evolution;
        
        	if (evolution.length >= 2) {
            	    var initial = evolution[0].handicap;
            	    var final = evolution[evolution.length - 1].handicap;
            	    var change = final - initial;
            	    var totalGames = evolution.length - 1;
            
            	    var status = '';
            	    if (change < -1) status = 'ğŸ“ˆ AMÃ‰LIORATION';
            	    else if (change > 1) status = 'ğŸ“‰ DÃ‰GRADATION';
            	    else status = 'â¡ï¸ STABLE';
            
            	    console.log(`${playerData.playerName}:`);
            	    console.log(`  ${initial.toFixed(1)} â†’ ${final.toFixed(1)} (${change > 0 ? '+' : ''}${change.toFixed(1)}) ${status}`);
            	    console.log(`  ${totalGames} parties jouÃ©es`);
        	}
    	    }
    
    	    console.log("\nâœ… MISE Ã€ JOUR TERMINÃ‰E - VÃ©rifiez le tableau des statistiques!");
	}

	// Fonction pour recalculer le handicap d'un joueur basÃ© sur ses scores jusqu'Ã  une date donnÃ©e
	function calculateHandicapAtDate(playerId, upToDate) {
    	    var player = players.find(p => p.id === playerId);
    	    if (!player) return null;
    
    	    var playerIndex = players.findIndex(p => p.id === playerId);
    	    if (playerIndex === -1) return player.handicap;
    
    	    var playerScores = [];
    
    	    // Collecter tous les scores du joueur jusqu'Ã  la date spÃ©cifiÃ©e
    	    for (var i = 0; i < dates.length; i++) {
        	if (new Date(dates[i]) <= new Date(upToDate)) {
            	    var grossScore = allScores[playerIndex][i];
            
            	    if (grossScore > 0) {
                	var courseName = courses[i];
                	var teeForPlayer = (playerId === 1) ? teeUsed[i] : 'blanc';
                	var differential = calculateScoreDifferential(grossScore, courseName, teeForPlayer);
                
                	if (differential > 0) {
                    	    playerScores.push({
                        	date: dates[i],
                        	differential: differential
                    	    });
                	}
            	    }
        	}
    	    }
    
    	    // Calculer le handicap selon les rÃ¨gles officielles
    	    if (playerScores.length < 5) {
        	// Pas assez de scores, garder le handicap initial
        	return player.handicap;
    	    }
    
    	    var differentials = playerScores.map(s => s.differential);
    	    differentials.sort((a, b) => a - b);
    
    	    var scoresToUse = 1;
    	    if (playerScores.length >= 20) scoresToUse = 8;
    	    else if (playerScores.length >= 15) scoresToUse = 5;
    	    else if (playerScores.length >= 10) scoresToUse = 3;
    	    else if (playerScores.length >= 7) scoresToUse = 2;
    
    	    var bestDifferentials = differentials.slice(0, scoresToUse);
    	    var average = bestDifferentials.reduce((sum, d) => sum + d, 0) / scoresToUse;
    
    	    return Math.round(average * 0.96 * 10) / 10;
	}

	// Fonction pour obtenir le handicap d'un joueur Ã  une date donnÃ©e
	function getPlayerHandicapAtDate(playerId, gameDate) {
    	    // Chercher dans le cache first
    	    var cacheKey = playerId + '_' + gameDate;
    	    if (handicapCache[cacheKey]) {
        	return handicapCache[cacheKey];
    	    }
    
    	    // Calculer et mettre en cache
    	    var handicap = calculateHandicapAtDate(playerId, gameDate);
    	    handicapCache[cacheKey] = handicap;
    
    	    return handicap;
	}

	// Fonction pour forcer la recalculation de l'Ã©volution des handicaps
	function fixHandicapEvolution() {
    	    console.log("ğŸ”„ Correction de l'Ã©volution des handicaps...");
    
    	    // Vider le cache
    	    handicapCache = {};
    
    	    // Recalculer les donnÃ©es d'Ã©volution avec les vrais handicaps
    	    handicapEvolutionData = {};
    
    	    for (var i = 0; i < players.length; i++) {
        	var player = players[i];
        	var evolution = [];
        	var playerName = player.name || (player.firstName + ' ' + player.lastName);
        
        	// Handicap initial (avant toute partie)
        	var initialHandicap = player.handicap;
        
        	evolution.push({
            	    date: dates[0] || '2023-01-01',
            	    handicap: initialHandicap,
            	    gameNumber: 0,
            	    change: 0
        	});
        
        	// Calculer l'Ã©volution aprÃ¨s chaque partie
        	for (var j = 0; j < dates.length; j++) {
            	    if (allScores[i][j] > 0) {
                	// Calculer le handicap Ã  cette date
                	var newHandicap = getPlayerHandicapAtDate(player.id, dates[j]);
                	var previousHandicap = j === 0 ? initialHandicap : evolution[evolution.length - 1].handicap;
                	var change = newHandicap - previousHandicap;
                
                	evolution.push({
                    	    date: dates[j],
                    	    handicap: newHandicap,
                    	    gameNumber: j + 1,
                    	    change: change,
                    	    score: allScores[i][j],
                    	    course: courses[j]
                	});
            	    }
        	}
        
        	handicapEvolutionData[player.id] = {
            	    player: player,
            	    playerName: playerName,
            	    evolution: evolution
        	};
    	    }
    
    	    console.log("âœ… Ã‰volution des handicaps corrigÃ©e!");
    
    	    // VÃ©rifier les rÃ©sultats
    	    console.log("ğŸ“Š Nouveaux rÃ©sultats:");
    	    for (var playerId in handicapEvolutionData) {
        	var playerData = handicapEvolutionData[playerId];
        	var evolution = playerData.evolution;
        
        	if (evolution.length >= 2) {
            	    var initial = evolution[0].handicap;
            	    var final = evolution[evolution.length - 1].handicap;
            	    var change = final - initial;
            
            	    console.log(playerData.playerName + ": " + initial.toFixed(1) + " â†’ " + final.toFixed(1) + " (" + (change > 0 ? "+" : "") + change.toFixed(1) + ")");
        	}
    	    }
    
    	    // Recharger l'affichage
    	    displayHandicapStats();
    	    if (selectedPlayers && selectedPlayers.length > 0) {
        	drawHandicapChart();
    	    }
	}

        // Scores rÃ©els pour chaque joueur
        var allScores = [];
           
        var rounds = [];
        var scores = [];
		var gprRoundsData = [];
		var handicapCache = {};
		// SystÃ¨me GPR : tracking des finales
		var gprFinaleData = {};
		var GPR_TOTAL_PLAYERS = 12; // Base de calcul pour les absences
		var gprBest4Data = {}; // Stockage des 4 meilleures parties par joueur
		// Variables globales pour le calcul GPR
		var playerPoints = {};
		var playerBest4Points = {};
		var roundDetails = [];
		// Nouvelles constantes pour le systÃ¨me GPR
		var GPR_TOTAL_PLAYERS = 12; // Base de calcul pour les absences
		var GPR_FINALE_TOTAL_POINTS = 400; // Points fixes pour la finale

		// Fonction pour calculer les points d'absence (derniÃ¨re place)
		function calculateAbsenteePoints(presentPlayers, isNet, isFinale, finaleFormat) {
		    var totalPlayers = GPR_TOTAL_PLAYERS;
		    var absentees = totalPlayers - presentPlayers;
		    
		    if (absentees <= 0) return 0;
		    
		    // Points selon le type de partie
		    var pointsScale = isFinale ? 
    			(isNet ? [225, 190, 165, 140, 125, 110, 90, 75, 60, 45, 35, 25] : 
            			 [175, 140, 120, 100, 85, 70, 60, 50, 40, 30, 20, 10]) :
    			(isNet ? [120, 105, 90, 78, 70, 62, 54, 46, 38, 30, 22, 15] : 
            			 [80, 68, 60, 52, 45, 40, 35, 30, 25, 20, 15, 10]);

			// Calculer la moyenne des points des derniÃ¨res places
			var totalAbsenteePoints = 0;
			for (var i = 0; i < absentees; i++) {
    			var position = presentPlayers + i + 1;
    			totalAbsenteePoints += pointsScale[Math.min(position - 1, pointsScale.length - 1)];
			}

			return Math.round(totalAbsenteePoints / absentees);
		}

		// Fonction pour identifier les parties finale
		function isFinaleRound(round) {
    		return round.type === 'gpr' && round.gprPhase === 'finale';
		}

		// Fonction pour calculer les points d'absence (rÃ¨gle des 12 joueurs)
		function calculateAbsenteePoints(presentPlayers, isNet, isFinale) {
    		var absentees = GPR_TOTAL_PLAYERS - presentPlayers;
    		if (absentees <= 0) return 0;
    
    		var pointsScale = isFinale ? 
        		(isNet ? [225, 190, 165, 140, 125, 110, 90, 75, 60, 45, 35, 25] : 
                		 [175, 140, 120, 100, 85, 70, 60, 50, 40, 30, 20, 10]) :
        		(isNet ? [120, 105, 90, 78, 70, 62, 54, 46, 38, 30, 22, 15] : 
                		 [80, 68, 60, 52, 45, 40, 35, 30, 25, 20, 15, 10]);
    
    		// Calculer la moyenne des points des derniÃ¨res places
    		var totalAbsenteePoints = 0;
    		for (var i = 0; i < absentees; i++) {
        		var position = presentPlayers + i + 1;
        		totalAbsenteePoints += pointsScale[Math.min(position - 1, pointsScale.length - 1)];
    		}
    
    		return Math.round(totalAbsenteePoints / absentees);
		}
		
		// Fonction pour calculer les 4 meilleures parties d'exhibition
		function calculateBest4Exhibition(playerId, year) {
		    console.log('=== calculateBest4Exhibition ===');
    		console.log('Joueur ID:', playerId, 'AnnÃ©e:', year);
			
			// Obtenir toutes les parties exhibition de l'annÃ©e (pas les finales)
			var exhibitionRounds = rounds.filter(r => 
		        r.type === 'gpr' && 
		        r.year === year && 
		        (!r.gprPhase || r.gprPhase === 'exhibition')
		    );

			console.log('Rounds exhibition de l\'annÃ©e:', exhibitionRounds.length);
		    
		    // Calculer les points pour chaque partie (mÃªme si le joueur Ã©tait absent)
		    var partiesWithPoints = [];
		    
		    for (var i = 0; i < exhibitionRounds.length; i++) {
		        var round = exhibitionRounds[i];
		        var roundScores = scores.filter(s => s.roundId === round.id && s.playerId !== 13);
		        
		        // VÃ©rifier si le joueur a participÃ©
		        var playerScore = roundScores.find(s => s.playerId === playerId);
		        
		        var brutPos, netPos, brutPoints, netPoints;
		        
		        if (playerScore) {
		            // Joueur prÃ©sent - calculer sa position rÃ©elle
		            var brutRanking = [...roundScores].sort((a, b) => a.score - b.score);
		            var netRanking = [...roundScores].sort((a, b) => a.net - b.net);
		            
		            brutPos = brutRanking.findIndex(s => s.playerId === playerId) + 1;
		            netPos = netRanking.findIndex(s => s.playerId === playerId) + 1;
		            
		            brutPoints = [80, 68, 60, 52, 45, 40, 35, 30, 25, 20, 15, 10][Math.min(brutPos - 1, 11)];
		            netPoints = [120, 105, 90, 78, 70, 62, 54, 46, 38, 30, 22, 15][Math.min(netPos - 1, 11)];
		        } else {
		            // Joueur absent - calculer les points d'absence
		            var presentPlayers = roundScores.length;
		            brutPoints = calculateAbsenteePoints(presentPlayers, false, false);
		            netPoints = calculateAbsenteePoints(presentPlayers, true, false);
		            brutPos = presentPlayers + 1;
		            netPos = presentPlayers + 1;
		            
		            // CrÃ©er un score fictif pour l'absent
		            playerScore = {
		                playerId: playerId,
		                score: 999,
		                net: 999,
		                absent: true
		            };
		        }
		        
		        partiesWithPoints.push({
		            roundId: round.id,
		            date: round.date,
		            course: round.course,
		            totalPoints: brutPoints + netPoints,
		            brutPoints: brutPoints,
		            netPoints: netPoints,
		            brutPos: brutPos,
		            netPos: netPos,
		            score: playerScore,
		            absent: !roundScores.find(s => s.playerId === playerId)
		        });
		    }
		    
		    console.log('Parties avec points calculÃ©es:', partiesWithPoints.length);
		    
		    // Trier par points dÃ©croissants et prendre les 4 meilleures (ou toutes si moins de 5)
		    partiesWithPoints.sort((a, b) => b.totalPoints - a.totalPoints);
		    var result = partiesWithPoints.length >= 5 ? partiesWithPoints.slice(0, 4) : partiesWithPoints;
		    
		    console.log('Best 4 pour joueur', playerId, ':', result.length, 'parties sÃ©lectionnÃ©es');
		    return result;
		}

		// Fonction pour cumuler les scores de finale
		function calculateFinaleScores(year) {
    		console.log('=== calculateFinaleScores appelÃ©e pour annÃ©e:', year);
    		var finaleRounds = rounds.filter(r => {
    			var yearMatch = !year || r.year == year;
    			return yearMatch && r.type === 'gpr' && r.gprPhase === 'finale';
			});

    		console.log('Rounds finale trouvÃ©s:', finaleRounds);
    		if (finaleRounds.length > 0) {
        		console.log('Format finale:', finaleRounds[0].gprFinaleFormat);
    		}
    
    		var finaleResults = {};
    
    		if (finaleRounds.length === 0) {
        		console.log('Aucune finale trouvÃ©e');
        		return {};
    		}
    
    		// Identifier les joueurs participants (exclure Ã‰ric Gosselin ID 12)
    		for (var i = 0; i < finaleRounds.length; i++) {
        		var round = finaleRounds[i];
        		var roundScores = scores.filter(s => s.roundId === round.id && s.playerId !== 13);
        
        		for (var j = 0; j < roundScores.length; j++) {
            		var score = roundScores[j];
            
            		if (!finaleResults[score.playerId]) {
                		finaleResults[score.playerId] = {
                    		player: players.find(p => p.id === score.playerId),
                    		totalBrut: 0,
                    		totalNet: 0,
                    		daysPlayed: 0
                		};
            		}
            
            		finaleResults[score.playerId].totalBrut += score.score;
            		finaleResults[score.playerId].totalNet += score.net;
            		finaleResults[score.playerId].daysPlayed++;
        		}
    		}
    
			// === AJOUT DES ABSENTS ===
			console.log('=== AJOUT ABSENTS FINALE ' + year + ' ===');

			// Obtenir tous les joueurs GPR de l'annÃ©e
			var allGPRScores = scores.filter(s => 
    			s.year == year && 
    			s.type === 'gpr' && 
    			s.playerId !== 13
			);

			var gprPlayerIds = [];
			for (var i = 0; i < allGPRScores.length; i++) {
    			if (gprPlayerIds.indexOf(allGPRScores[i].playerId) === -1) {
        			gprPlayerIds.push(allGPRScores[i].playerId);
    			}
			}

			console.log('Joueurs GPR trouvÃ©s:', gprPlayerIds.length, 'joueurs');
			console.log('IDs:', gprPlayerIds);

			// Ajouter ceux qui manquent
			for (var i = 0; i < gprPlayerIds.length; i++) {
    			var playerId = gprPlayerIds[i];
    			if (!finaleResults[playerId]) {
        			var player = players.find(p => p.id === playerId);
        			finaleResults[playerId] = {
            			player: player,
            			totalBrut: 999,
            			totalNet: 999,
            			daysPlayed: 0,
            			absent: true
        			};
        			console.log('AJOUT ABSENT:', player.name || (player.firstName + ' ' + player.lastName));
    			}
			}

    		// Distribuer les 400 points fixes de finale
    		var playersArray = [];
    		for (var playerId in finaleResults) {
        		playersArray.push({
            		playerId: parseInt(playerId),
            		data: finaleResults[playerId]
        		});
    		}

    		// Classement finale par score brut cumulÃ©
    		playersArray.sort((a, b) => {
        		if (a.data.daysPlayed === 0 && b.data.daysPlayed === 0) return 0;
        		if (a.data.daysPlayed === 0) return 1;
        		if (b.data.daysPlayed === 0) return -1;
        		return a.data.totalBrut - b.data.totalBrut;
    		});

    		// VÃ©rifier si c'est une finale 1 jour ou 2 jours
    		var isFinale1Day = false;
    		if (finaleRounds.length > 0 && finaleRounds[0].gprFinaleFormat === '1day') {
        		isFinale1Day = true;
    		}

    		// Points finale FIXES - toujours 400 points au total
			var finaleBrutPoints = [175, 140, 120, 100, 85, 70, 60, 50, 40, 30, 20, 10];
			var finaleNetPoints = [225, 190, 165, 140, 125, 110, 90, 75, 60, 45, 35, 25];

			console.log('Format finale:', isFinale1Day ? '1 jour' : '2 jours');
			console.log('Nombre de jours de finale:', finaleRounds.length);
			console.log('Points brut Ã  distribuer:', finaleBrutPoints.reduce((a,b) => a+b, 0));
			console.log('Points net Ã  distribuer:', finaleNetPoints.reduce((a,b) => a+b, 0));

			// Distribution des points brut
			for (var i = 0; i < playersArray.length; i++) {
    			var pointsBrut = finaleBrutPoints[Math.min(i, finaleBrutPoints.length - 1)];
    			playersArray[i].data.pointsBrut = pointsBrut;
    			playersArray[i].data.positionBrut = i + 1;
			}

			// Classement finale par score net cumulÃ©
			playersArray.sort((a, b) => {
    			if (a.data.daysPlayed === 0 && b.data.daysPlayed === 0) return 0;
    			if (a.data.daysPlayed === 0) return 1;
    			if (b.data.daysPlayed === 0) return -1;
    			return a.data.totalNet - b.data.totalNet;
			});

			// Distribution des points net
			for (var i = 0; i < playersArray.length; i++) {
    			var pointsNet = finaleNetPoints[Math.min(i, finaleNetPoints.length - 1)];
    			playersArray[i].data.pointsNet = pointsNet;
    			playersArray[i].data.positionNet = i + 1;
    			playersArray[i].data.totalPointsFinale = playersArray[i].data.pointsBrut + pointsNet;
			}

    		// Debug - VÃ©rifier le total des points
    		var totalBrutDistribue = 0;
    		var totalNetDistribue = 0;
    		for (var i = 0; i < playersArray.length; i++) {
        		totalBrutDistribue += playersArray[i].data.pointsBrut || 0;
        		totalNetDistribue += playersArray[i].data.pointsNet || 0;
    		}
    		console.log('=== DEBUG FINALE ===');
    		console.log('Total points brut distribuÃ©s:', totalBrutDistribue);
    		console.log('Total points net distribuÃ©s:', totalNetDistribue);
    		console.log('TOTAL GÃ‰NÃ‰RAL:', totalBrutDistribue + totalNetDistribue);

    		// Remettre dans l'objet finaleResults
    		for (var i = 0; i < playersArray.length; i++) {
        		var playerId = playersArray[i].playerId;
        		finaleResults[playerId] = playersArray[i].data;
    		}

    		return finaleResults;
		}

	// Fonction pour recalculer le handicap d'un joueur basÃ© sur ses scores jusqu'Ã  une date donnÃ©e
	function calculateHandicapAtDate(playerId, upToDate) {
    	    var playerScores = [];
    
    	    // Collecter tous les scores du joueur jusqu'Ã  la date spÃ©cifiÃ©e
    	    for (var i = 0; i < dates.length; i++) {
        	if (new Date(dates[i]) <= new Date(upToDate)) {
            	    if (grossScore > 0) {
    					var courseName = courses[i];
    					var teeForPlayer = (playerId === 1) ? teeUsed[i] : 'blanc';
    					var differential = calculateScoreDifferential(grossScore, courseName, teeForPlayer);
    
    					if (differential !== null) {
        					playerScores.push({
            					date: dates[i],
            					differential: differential
        					});
    					}
					}
            
            	if (grossScore > 0) {
                    var courseName = courses[i];
                    var teeForPlayer = (playerId === 1) ? teeUsed[i] : 'blanc';
                    var differential = calculateScoreDifferential(grossScore, courseName, teeForPlayer);
                
                    if (differential > 0) {
                        playerScores.push({
                            date: dates[i],
                            differential: differential
                        });
                    }
                }
            }
        }
    
    	// Trier par date (plus rÃ©cent en premier)
    	playerScores.sort((a, b) => new Date(b.date) - new Date(a.date));
    
    	// Calculer le handicap selon les rÃ¨gles officielles
    	if (playerScores.length < 5) {
            // Pas assez de scores, garder le handicap initial
            var initialPlayer = players.find(p => p.id === playerId);
            return initialPlayer ? initialPlayer.handicap : null;
        }
    
    	var differentials = playerScores.map(s => s.differential);
    	differentials.sort((a, b) => a - b);
    
    	var scoresToUse = 1;
    	if (playerScores.length >= 20) scoresToUse = 8;
    	else if (playerScores.length >= 15) scoresToUse = 5;
    	else if (playerScores.length >= 10) scoresToUse = 3;
    	else if (playerScores.length >= 7) scoresToUse = 2;
    
    	var bestDifferentials = differentials.slice(0, scoresToUse);
    	var average = bestDifferentials.reduce((sum, d) => sum + d, 0) / scoresToUse;
    
    	return Math.round(average * 0.96 * 10) / 10;
    }

    // Fonction pour obtenir le handicap d'un joueur Ã  une date donnÃ©e
    function getPlayerHandicapAtDate(playerId, gameDate) {
    	// Chercher dans le cache first
    	var cacheKey = playerId + '_' + gameDate;
    	if (handicapCache[cacheKey]) {
            return handicapCache[cacheKey];
    	}
    
    	// Calculer et mettre en cache
    	var handicap = calculateHandicapAtDate(playerId, gameDate);
    	handicapCache[cacheKey] = handicap;
    
    	return handicap;
    }

    function initializeData() {
    	// Si rounds n'existe pas, le crÃ©er
    	if (typeof rounds === 'undefined' || !rounds || rounds.length === 0) {
        	console.log('Pas de rounds chargÃ©s, crÃ©ation depuis dates/courses');
        	rounds = [];
        
        	// Construire rounds depuis les anciennes donnÃ©es
        	for (var i = 0; i < dates.length; i++) {
            	var courseName = courses[i];
            	var isDiablo = (courseName === 'Le Diable' || courseName === 'Le GÃ©ant' || courseName === 'Manoir des Sables');
            	var gameDate = new Date(dates[i]);
            	var year = gameDate.getFullYear();
            	var month = gameDate.getMonth() + 1;
            
            	rounds.push({
                	id: i + 1,
                	date: dates[i],
                	course: courseName,
                	tee: teeUsed[i],
                	type: isDiablo ? 'diablo' : 'gpr',
                	year: year,
                	month: month
            	});
        	}
    	} else {
        	console.log('Rounds dÃ©jÃ  chargÃ©s depuis Firebase, conservation complÃ¨te');
        	console.log('Nombre de rounds:', rounds.length);
        	var gprFinales = rounds.filter(r => r.gprPhase === 'finale');
        	console.log('Dont finales GPR:', gprFinales.length);
    	}
    
    	// Toujours reconstruire scores
    	scores = [];
    	handicapCache = {};
    
    	// Reconstruire les scores basÃ©s sur rounds existants
    	for (var i = 0; i < rounds.length; i++) {
        	var round = rounds[i];
        	var roundIndex = i; // L'index dans allScores correspond Ã  l'ordre des rounds
        
        	// Ajouter les scores pour cette partie
        	for (var j = 0; j < players.length; j++) {
            	var grossScore = allScores[j][roundIndex];
            
            	if (grossScore > 0) {
                	var player = players[j];
                	var teeForPlayer = teeUsed[roundIndex];
                
                	// Antonio (id=1) joue des bleus pour certaines parties
                	if (player.id !== 1) {
                    	teeForPlayer = 'blanc';
                	}
                
                	var courseHandicap = calculateCourseHandicap(player.handicap, round.course, teeForPlayer);
                	var netScore = grossScore - courseHandicap;
                
                	scores.push({
                    	roundId: round.id,
                    	playerId: player.id,
                    	playerName: player.name || (player.firstName + ' ' + player.lastName),
                    	score: grossScore,
                    	courseHandicap: courseHandicap,
                    	net: netScore,
                    	tee: teeForPlayer,
                    	type: round.type,
                    	year: round.year,
                    	month: round.month
                	});
            	}
        	}
    	}
    
    	console.log('InitializeData terminÃ© - Scores reconstruits:', scores.length);
	}

	// Fonction pour calculer le diffÃ©rentiel de score (Score Differential)
	function calculateScoreDifferential(grossScore, courseName, teeColor) {
    	    if (!coursesDatabase[courseName]) {
        	console.warn('Terrain non trouvÃ©:', courseName);
        	return null;
    	    }
    
    	    var courseData = coursesDatabase[courseName];
    	    var teeData = courseData.find(t => t.tee === teeColor);
    
    	    if (!teeData) {
        	teeData = courseData[0];
        	console.warn('DÃ©part', teeColor, 'non trouvÃ© pour', courseName, ', utilisation de', teeData.tee);
    	    }
    
    	    // Score Differential = (Gross Score - Course Rating) Ã— 113 / Slope Rating
    	    var differential = (grossScore - teeData.rating) * 113 / teeData.slope;
    	    return Math.round(differential * 10) / 10;
	}

        // Fonctions de navigation
        function showOverview() {
            hideAllSections();
            document.getElementById('overview').style.display = 'block';
            setActiveButton('showOverview');
            loadOverview();
        }

        function showPlayerScores() {
            hideAllSections();
            document.getElementById('playerScores').style.display = 'block';
            setActiveButton('showPlayerScores');
            loadPlayerSelector();
        }

        function showCourses() {
            hideAllSections();
            document.getElementById('courses').style.display = 'block';
            setActiveButton('showCourses');
            loadCoursesList();
        }

        function showDiablo() {
            hideAllSections();
            document.getElementById('diablo').style.display = 'block';
            setActiveButton('showDiablo');
            loadDiablo();
        }

        function showGPR() {
            hideAllSections();
            document.getElementById('gpr').style.display = 'block';
            setActiveButton('showGPR');
            loadGPR();
        }

        function showProgress() {
            hideAllSections();
            document.getElementById('progress').style.display = 'block';
            setActiveButton('showProgress');
            loadProgress();
        }

        function showDetails() {
            hideAllSections();
            document.getElementById('details').style.display = 'block';
            setActiveButton('showDetails');
            loadDetails();
        }

		function showHandicapEvolution() {
            hideAllSections();
            document.getElementById('handicapEvolution').style.display = 'block';
            setActiveButton('showHandicapEvolution');
            loadDetails();
        }

		function showPlayerManagement() {
            hideAllSections();
            document.getElementById('playerManagement').style.display = 'block';
            setActiveButton('showPlayerManagement');
            loadDetails();
        }

		function showAddRound() {
            hideAllSections();
            document.getElementById('addRound').style.display = 'block';
            setActiveButton('showAddRound');
            loadDetails();
        }

        function hideAllSections() {
            var sections = ['overview', 'playerScores', 'courses', 'diablo', 'gpr', 'progress', 'details', 'handicapEvolution', 'playerManagement', 'addRound', 'calendar'];
            for (var i = 0; i < sections.length; i++) {
                document.getElementById(sections[i]).style.display = 'none';
            }
        }

        function setActiveButton(buttonFunction) {
    		var buttons = document.querySelectorAll('.nav button:not(.nav-save-btn)');
    		for (var i = 0; i < buttons.length; i++) {
        		buttons[i].classList.remove('active');
    		}
    
    		// Ajouter active au bon bouton selon la fonction
    		var activeSelector = '';
    		switch(buttonFunction) {
        		case 'showAddRound': activeSelector = 'button[onclick="showAddRound()"]'; break;
        		case 'showProgress': activeSelector = 'button[onclick="showProgress()"]'; break;
        		case 'showDiablo': activeSelector = 'button[onclick="showDiablo()"]'; break;
        		case 'showGPR': activeSelector = 'button[onclick="showGPR()"]'; break;
        		case 'showOverview': activeSelector = 'button[onclick="showOverview()"]'; break;
        		case 'showHandicapEvolution': activeSelector = 'button[onclick="showHandicapEvolution()"]'; break;
        		case 'showPlayerScores': activeSelector = 'button[onclick="showPlayerScores()"]'; break;
        		case 'showDetails': activeSelector = 'button[onclick="showDetails()"]'; break;
        		case 'showCourses': activeSelector = 'button[onclick="showCourses()"]'; break;
        		case 'showPlayerManagement': activeSelector = 'button[onclick="showPlayerManagement()"]'; break;
				case 'showCalendar': activeSelector = 'button[onclick="showCalendar()"]'; break;
    		}
    
    		if (activeSelector) {
        		var activeButton = document.querySelector('.nav ' + activeSelector);
        		if (activeButton) {
            		activeButton.classList.add('active');
        		}
    		}
		}

        // FONCTION loadOverview() - TROUVEZ ET REMPLACEZ CETTE PARTIE :

	function loadOverview() {
    	var totalGames = rounds.length;
    	var totalScores = scores.length;
    	var activePlayers = getUniquePlayersCount(scores);
    	var totalCourses = Object.keys(coursesDatabase).length;

    	var diabloGames = rounds.filter(r => r.type === 'diablo').length;
    	var gprGames = rounds.filter(r => r.type === 'gpr').length;

    	var html = '<div class="player-stats">' +
        	       '<div class="stat-box">' +
            	   '<div class="stat-value">' + totalGames + '</div>' +
                   '<div class="stat-label">Parties Total</div>' +
            	   '</div>' +
            	   '<div class="stat-box">' +
            	   '<div class="stat-value">' + activePlayers + '</div>' +
            	   '<div class="stat-label">Joueurs Actifs</div>' +
            	   '</div>' +
            	   '<div class="stat-box">' +
            	   '<div class="stat-value">' + totalCourses + '</div>' +
            	   '<div class="stat-label">Terrains en Base</div>' +
            	   '</div>' +
            	   '<div class="stat-box">' +
            	   '<div class="stat-value">' + diabloGames + '</div>' +
            	   '<div class="stat-label">Parties Diablo</div>' +
            	   '</div>' +
            	   '<div class="stat-box">' +
            	   '<div class="stat-value">' + gprGames + '</div>' +
            	   '<div class="stat-label">Parties GPR</div>' +
            	   '</div>' +
            	   '</div>';

    	// CLASSEMENT COMPLET DE TOUS LES JOUEURS
    	var allPlayerStats = [];
    	for (var i = 0; i < players.length; i++) {
        	var player = players[i];
        	var playerScores = scores.filter(s => s.playerId === player.id);
        	if (playerScores.length > 0) {
            	var avgGross = playerScores.reduce((sum, s) => sum + s.score, 0) / playerScores.length;
            	var avgNet = playerScores.reduce((sum, s) => sum + s.net, 0) / playerScores.length;
            	var bestGross = Math.min(...playerScores.map(s => s.score));
            	var bestNet = Math.min(...playerScores.map(s => s.net));
            
            	allPlayerStats.push({
                	player: player,
                	playerName: player.name || (player.firstName + ' ' + player.lastName),
                	games: playerScores.length,
                	avgGross: avgGross,
                	avgNet: avgNet,
                	bestGross: bestGross,
                	bestNet: bestNet
            	});
        	}
    	}

    	allPlayerStats.sort((a, b) => a.avgNet - b.avgNet);

    	html += '<h3>ğŸ† CLASSEMENT COMPLET DE TOUS LES JOUEURS</h3>' +
        	    '<p style="background: #e7f3ff; padding: 10px; border-radius: 5px; margin: 10px 0;">ClassÃ© par score net moyen (plus bas = meilleur). Total: ' + allPlayerStats.length + ' joueurs avec au moins 1 partie.</p>' +
        	    '<table class="table">' +
        	    '<thead><tr><th>ğŸ† Rang</th><th>ğŸ‘¤ Joueur</th><th>ğŸ® Parties</th><th>ğŸŒï¸ Handicap</th><th>ğŸ“Š Moy. Brut</th><th>â­ Moy. Net</th><th>ğŸ¯ Meilleur Net</th><th>ğŸ’ª Meilleur Brut</th></tr></thead>' +
        	    '<tbody>';

    	for (var i = 0; i < allPlayerStats.length; i++) {
        	var stat = allPlayerStats[i];
        	var rowStyle = '';
        	var rankIcon = '';
        
        	// Podium avec icÃ´nes
        	if (i === 0) {
            	rowStyle = ' style="background: linear-gradient(45deg, #FFD700, #FFF8DC); font-weight: bold;"';
            	rankIcon = 'ğŸ¥‡';
        	} else if (i === 1) {
            	rowStyle = ' style="background: linear-gradient(45deg, #C0C0C0, #F5F5F5); font-weight: bold;"';
            	rankIcon = 'ğŸ¥ˆ';
        	} else if (i === 2) {
            	rowStyle = ' style="background: linear-gradient(45deg, #CD7F32, #F4E4BC); font-weight: bold;"';
            	rankIcon = 'ğŸ¥‰';
        	} else if (i < 5) {
            	rowStyle = ' style="background: #e8f4fd; font-weight: 500;"';
            	rankIcon = 'â­';
        	} else if (i >= allPlayerStats.length - 3 && allPlayerStats.length > 5) {
            	rowStyle = ' style="background: #ffe8e8;"';
            	rankIcon = 'ğŸ“ˆ';
        	}
        
        	html += '<tr' + rowStyle + '>' +
            	    '<td><strong>' + rankIcon + ' ' + (i + 1) + '</strong></td>' +
            	    '<td><strong>' + stat.playerName + '</strong></td>' +
            	    '<td>' + stat.games + '</td>' +
            	    '<td>' + stat.player.handicap.toFixed(1) + '</td>' +
            	    '<td>' + stat.avgGross.toFixed(1) + '</td>' +
            	    '<td><strong style="color: ' + (i < 3 ? '#28a745' : '#333') + ';">' + stat.avgNet.toFixed(1) + '</strong></td>' +
            	    '<td>' + stat.bestNet.toFixed(1) + '</td>' +
            	    '<td>' + stat.bestGross + '</td>' +
            	    '</tr>';
    	}

    	html += '</tbody></table>';

    	// ANALYSE STATISTIQUE DÃ‰TAILLÃ‰E
    	if (allPlayerStats.length > 0) {
        	html += '<div class="card" style="background: #f8f9fa; margin-top: 20px;">' +
            	    '<h4>ğŸ“Š Analyse Statistique ComplÃ¨te</h4>' +
            	    '<div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(250px, 1fr)); gap: 15px;">';
        
        	var bestPlayer = allPlayerStats[0];
        	var worstPlayer = allPlayerStats[allPlayerStats.length - 1];
        	var avgNetAll = allPlayerStats.reduce((sum, stat) => sum + stat.avgNet, 0) / allPlayerStats.length;
        	var medianIndex = Math.floor(allPlayerStats.length / 2);
        	var medianNet = allPlayerStats[medianIndex].avgNet;
        	var spread = worstPlayer.avgNet - bestPlayer.avgNet;
        
        	html += '<div class="stat-box" style="background: #e8f5e8; border-left: 5px solid #28a745;">' +
            	    '<div class="stat-value" style="color: #28a745;">ğŸ¥‡ ' + bestPlayer.avgNet.toFixed(1) + '</div>' +
            	    '<div class="stat-label">Champion<br><strong>' + bestPlayer.playerName + '</strong></div>' +
            	    '</div>' +
                
            	    '<div class="stat-box" style="background: #ffe8e8; border-left: 5px solid #dc3545;">' +
            	    '<div class="stat-value" style="color: #dc3545;">ğŸ“ˆ ' + worstPlayer.avgNet.toFixed(1) + '</div>' +
            	    '<div class="stat-label">Ã€ AmÃ©liorer<br><strong>' + worstPlayer.playerName + '</strong></div>' +
            	    '</div>' +
                
            	    '<div class="stat-box" style="background: #e3f2fd; border-left: 5px solid #2196f3;">' +
            	    '<div class="stat-value" style="color: #2196f3;">ğŸ“Š ' + avgNetAll.toFixed(1) + '</div>' +
            	    '<div class="stat-label">Moyenne Groupe</div>' +
            	    '</div>' +
                
            	    '<div class="stat-box" style="background: #f3e5f5; border-left: 5px solid #9c27b0;">' +
            	    '<div class="stat-value" style="color: #9c27b0;">ğŸ“ ' + medianNet.toFixed(1) + '</div>' +
            	    '<div class="stat-label">Score MÃ©dian</div>' +
            	    '</div>' +
                
            	    '<div class="stat-box" style="background: #fff3e0; border-left: 5px solid #ff9800;">' +
            	    '<div class="stat-value" style="color: #ff9800;">ğŸ“ ' + spread.toFixed(1) + '</div>' +
            	    '<div class="stat-label">Ã‰cart Total</div>' +
            	    '</div>';
        
        	// Distribution par niveau
        	var excellent = allPlayerStats.filter(s => s.avgNet < avgNetAll - 2).length;
        	var good = allPlayerStats.filter(s => s.avgNet >= avgNetAll - 2 && s.avgNet < avgNetAll).length;
        	var average = allPlayerStats.filter(s => s.avgNet >= avgNetAll && s.avgNet < avgNetAll + 2).length;
        	var improving = allPlayerStats.filter(s => s.avgNet >= avgNetAll + 2).length;
        
        	html += '<div class="stat-box" style="background: #f0f0f0; border-left: 5px solid #666;">' +
            	    '<div class="stat-value" style="color: #666; font-size: 16px;">ğŸ“ˆ Distribution</div>' +
                	'<div class="stat-label" style="font-size: 12px; line-height: 1.3;">' +
                	'ğŸŒŸ Excellent: <strong>' + excellent + '</strong><br>' +
                	'ğŸ‘ Bon: <strong>' + good + '</strong><br>' +
                	'ğŸ“Š Moyen: <strong>' + average + '</strong><br>' +
                	'ğŸ”„ Ã€ amÃ©liorer: <strong>' + improving + '</strong>' +
                	'</div>' +
                	'</div>';
        
        	html += '</div></div>';
    	}

    	document.getElementById('overviewStats').innerHTML = html;
	}

        // VOIR LES TERRAINS

	function loadCoursesList() {
    	    var html = '';
    	    console.log('=== CHARGEMENT DES TERRAINS ===');
			var courseNames = Object.keys(coursesDatabase).sort();
    
    	    // Afficher les statistiques
    	    var totalTees = 0;
    	    for (var courseName in coursesDatabase) {
        	totalTees += coursesDatabase[courseName].length;
    	    }
    
    	    html += '<div style="background: #f8f9fa; padding: 15px; border-radius: 8px; margin-bottom: 20px;">' +
            	    '<strong>ğŸ“Š RÃ©sumÃ©:</strong> ' + courseNames.length + ' terrains avec ' + totalTees + ' dÃ©parts au total' +
            	    '</div>';
    
    	    html += '<div class="course-grid">';
    
    	    for (var i = 0; i < courseNames.length; i++) {
        	var courseName = courseNames[i];
        	var tees = coursesDatabase[courseName];
        
        	html += '<div class="course-card">' +
        			'<div class="course-header">' +
        			'<div class="course-name">ğŸŒï¸ ' + courseName + '</div>' +
        			'<div>' +
        			'<button class="btn-secondary" onclick="editCourse(\'' + courseName + '\')" style="margin-right: 5px;">âœï¸ Modifier</button>' +
        			'<button class="btn-danger" onclick="deleteCourse(\'' + courseName + '\')">ğŸ—‘ï¸ Supprimer</button>' +
        			'</div>' +
        			'</div>';
        
        	// Afficher chaque dÃ©part avec ses dÃ©tails
        	for (var j = 0; j < tees.length; j++) {
            	    var tee = tees[j];
            
            	    // DÃ©terminer la couleur du dÃ©part
            	    var teeIcon = '';
            	    switch(tee.tee) {
                	case 'blanc': teeIcon = 'âšª'; break;
                	case 'bleu': teeIcon = 'ğŸ”µ'; break;
                	case 'vert': teeIcon = 'ğŸŸ¢'; break;
                	case 'jaune': teeIcon = 'ğŸŸ¡'; break;
                	case 'noir': teeIcon = 'âš«'; break;
                	default: teeIcon = 'ğŸŒï¸'; break;
            	    }
            
            	    // Niveau de difficultÃ© basÃ© sur le slope
            	    var difficulty = '';
            	    var difficultyColor = '';
            	    if (tee.slope < 113) {
                	difficulty = 'Facile';
                	difficultyColor = '#28a745';
            	    } else if (tee.slope < 125) {
                	difficulty = 'Moyen';
                	difficultyColor = '#ffc107';
            	    } else if (tee.slope < 135) {
                	difficulty = 'Difficile';
                	difficultyColor = '#fd7e14';
            	    } else {
                	difficulty = 'TrÃ¨s difficile';
                	difficultyColor = '#dc3545';
            	    }
            
            	    html += '<div class="tee-info" style="border-left: 4px solid ' + difficultyColor + ';">' +
                    	    '<div style="display: flex; align-items: center; gap: 10px;">' +
                    	    '<span style="font-size: 18px;">' + teeIcon + '</span>' +
                    	    '<div>' +
                    	    '<span class="tee-color tee-' + tee.tee + '" style="padding: 3px 8px; border-radius: 12px; font-size: 11px; font-weight: bold;">' + 
                    	    tee.tee.toUpperCase() + '</span>' +
                    	    '<br><small style="color: ' + difficultyColor + '; font-weight: bold;">' + difficulty + '</small>' +
                    	    '</div>' +
                    	    '</div>' +
                    	    '<div style="text-align: right; font-family: monospace;">' +
                    	    '<div><strong>Rating:</strong> ' + tee.rating + '</div>' +
                    	    '<div><strong>Slope:</strong> ' + tee.slope + '</div>' +
                    	    '<div><strong>Par:</strong> ' + tee.par + '</div>' +
                    	    '</div>' +
                    	    '</div>';
        	}
        
        	html += '</div>';
    	    }
    
    	    html += '</div>';
    
			console.log('HTML gÃ©nÃ©rÃ©:', html.substring(0, 500));
    	    document.getElementById('coursesList').innerHTML = html;
	}

    function toggleAddCourseForm() {
        var form = document.getElementById('addCourseForm');
        if (form.style.display === 'none') {
            form.style.display = 'block';
            document.getElementById('newCourseName').value = '';
            // Reset form with one tee input
            document.getElementById('teeInputs').innerHTML = 
                '<div class="tee-form-row">' +
                '<select>' +
                '<option value="blanc">Blanc</option>' +
                '<option value="bleu">Bleu</option>' +
                '<option value="vert">Vert</option>' +
                '<option value="jaune">Jaune</option>' +
                '<option value="noir">Noir</option>' +
                '</select>' +
                '<input type="number" placeholder="Rating (ex: 69.5)" step="0.1" min="60" max="80">' +
                '<input type="number" placeholder="Slope (ex: 123)" min="85" max="155">' +
                '<input type="number" placeholder="Par (ex: 72)" min="68" max="76">' +
                '<button type="button" class="btn-danger" onclick="removeTeeInput(this)">âŒ</button>' +
                '</div>';
        } else {
            form.style.display = 'none';
        }
    }

    function addTeeInput() {
        var container = document.getElementById('teeInputs');
        var newRow = document.createElement('div');
        newRow.className = 'tee-form-row';
        newRow.innerHTML = 
            '<select>' +
            '<option value="blanc">Blanc</option>' +
            '<option value="bleu">Bleu</option>' +
            '<option value="vert">Vert</option>' +
            '<option value="jaune">Jaune</option>' +
            '<option value="noir">Noir</option>' +
            '</select>' +
            '<input type="number" placeholder="Rating (ex: 69.5)" step="0.1" min="60" max="80">' +
            '<input type="number" placeholder="Slope (ex: 123)" min="85" max="155">' +
            '<input type="number" placeholder="Par (ex: 72)" min="68" max="76">' +
            '<button type="button" class="btn-danger" onclick="removeTeeInput(this)">âŒ</button>';
        container.appendChild(newRow);
    }

    function removeTeeInput(button) {
        var container = document.getElementById('teeInputs');
        if (container.children.length > 1) {
            button.parentElement.remove();
        }
    }

    function saveCourse() {
        var courseName = document.getElementById('newCourseName').value.trim();
        if (!courseName) {
            alert('Veuillez saisir le nom du terrain.');
            return;
        }
            
        if (coursesDatabase[courseName]) {
            if (!confirm('Ce terrain existe dÃ©jÃ . Voulez-vous le remplacer?')) {
                return;
            }
        }
            
        var teeRows = document.querySelectorAll('#teeInputs .tee-form-row');
        var tees = [];
            
        for (var i = 0; i < teeRows.length; i++) {
            var row = teeRows[i];
            var select = row.querySelector('select');
            var ratingInput = row.querySelectorAll('input')[0];
            var slopeInput = row.querySelectorAll('input')[1];
            var parInput = row.querySelectorAll('input')[2];
                
            var teeColor = select.value;
            var rating = parseFloat(ratingInput.value);
            var slope = parseInt(slopeInput.value);
            var par = parseInt(parInput.value);
                
            if (!rating || !slope || !par || rating < 60 || rating > 80 || slope < 85 || slope > 155 || par < 68 || par > 76) {
                alert('Veuillez remplir tous les champs avec des valeurs valides (Rating: 60-80, Slope: 85-155, Par: 68-76).');
                return;
            }
                
            tees.push({
                tee: teeColor,
                rating: rating,
                slope: slope,
                par: par
            });
        }
            
        coursesDatabase[courseName] = tees;
        // Sauvegarder dans Firebase
        saveCoursesToFirebase().then(function() {
            console.log('Terrain sauvegardÃ© dans Firebase');
        }).catch(function(error) {
            console.error('Erreur de sauvegarde terrain:', error);
            alert('Erreur de sauvegarde: ' + error.message);
        });
        saveCourseData();
        loadCoursesList();
        toggleAddCourseForm();
            
        document.getElementById('coursesList').insertAdjacentHTML('afterbegin',
            '<div class="alert-success">âœ… Terrain "' + courseName + '" ajoutÃ© avec succÃ¨s!</div>'
        );
            
        setTimeout(function() {
            var alert = document.querySelector('#coursesList .alert-success');
            if (alert) alert.remove();
        }, 3000);
    }

    function cancelAddCourse() {
        toggleAddCourseForm();
    }

    function deleteCourse(courseName) {
    	if (confirm('ÃŠtes-vous sÃ»r de vouloir supprimer le terrain "' + courseName + '"?')) {
        	delete coursesDatabase[courseName];
        
        	// Sauvegarder dans Firebase
        	saveCoursesToFirebase().then(function() {
            	console.log('Terrain supprimÃ© de Firebase');
        	}).catch(function(error) {
            	console.error('Erreur de suppression terrain:', error);
            	alert('Erreur de suppression: ' + error.message);
        	});
        
        	saveCourseData();
        	loadCoursesList();
        
        	document.getElementById('coursesList').insertAdjacentHTML('afterbegin',
            	'<div class="alert-danger">ğŸ—‘ï¸ Terrain "' + courseName + '" supprimÃ©.</div>'
       		);
        
        	setTimeout(function() {
            	var alert = document.querySelector('#coursesList .alert-danger');
            	if (alert) alert.remove();
        	}, 3000);
    	}
	}

	// Nouvelle fonction pour Ã©diter un terrain existant
	function editCourse(courseName) {
    	var courseData = coursesDatabase[courseName];
    	if (!courseData) {
        	alert('Terrain non trouvÃ©!');
        	return;
    	}

    	// CrÃ©er le formulaire d'Ã©dition
    	var formHtml = 
    		'<div style="position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.5); z-index: 1000; overflow-y: auto;">' +
    		'<div style="background: white; padding: 30px; margin: 50px auto; border-radius: 10px; box-shadow: 0 4px 20px rgba(0,0,0,0.3); max-width: 700px; width: 90%;">' +
        	'<h3 style="margin-top: 0; color: #2c5530;">âœï¸ Modifier le Terrain</h3>' +
    
    		'<div style="margin: 15px 0;">' +
        	'<label style="display: block; font-weight: bold; margin-bottom: 5px;">Nom du terrain:</label>' +
        	'<input type="text" id="editCourseName" value="' + courseName.replace(/"/g, '&quot;') + '" style="width: 100%; padding: 8px; border: 1px solid #ddd; border-radius: 4px;">' +
    		'</div>' +
        
    		'<h4>DÃ©parts disponibles:</h4>' +
        	'<div id="editTeeInputs">';

    	// Ajouter les dÃ©parts existants
    	for (var i = 0; i < courseData.length; i++) {
        	var tee = courseData[i];
        	formHtml += '<div class="tee-form-row">' +
            	'<select>' +
            	'<option value="blanc"' + (tee.tee === 'blanc' ? ' selected' : '') + '>Blanc</option>' +
            	'<option value="bleu"' + (tee.tee === 'bleu' ? ' selected' : '') + '>Bleu</option>' +
        		'<option value="vert"' + (tee.tee === 'vert' ? ' selected' : '') + '>Vert</option>' +
        		'<option value="jaune"' + (tee.tee === 'jaune' ? ' selected' : '') + '>Jaune</option>' +
        		'<option value="noir"' + (tee.tee === 'noir' ? ' selected' : '') + '>Noir</option>' +
            	'</select>' +
            	'<input type="number" value="' + tee.rating + '" step="0.1" min="60" max="80" placeholder="Rating">' +
        		'<input type="number" value="' + tee.slope + '" min="85" max="155" placeholder="Slope">' +
        		'<input type="number" value="' + tee.par + '" min="68" max="76" placeholder="Par">' +
        		'<button type="button" class="btn-danger" onclick="removeEditTeeInput(this)">âŒ</button>' +
            	'</div>';
    	}

    	formHtml += '</div>' +
        	'<button class="btn-secondary" onclick="addEditTeeInput()">â• Ajouter un DÃ©part</button>' +
        	'<br><br>' +
    		'<div style="margin-top: 25px; text-align: center;">' +
    		'<button onclick="saveCourseEdit(\'' + courseName + '\')" style="background: #4a7c59; color: white; border: none; padding: 12px 24px; border-radius: 5px; margin: 5px; cursor: pointer; font-size: 16px;">ğŸ’¾ Sauvegarder</button>' +
        	'<button onclick="cancelCourseEdit()" style="background: #6c757d; color: white; border: none; padding: 12px 24px; border-radius: 5px; margin: 5px; cursor: pointer; font-size: 16px;">âŒ Annuler</button>' +
        	'</div>' +
    		'</div></div>';

    	// Ajouter la popup au body
    	var popup = document.createElement('div');
    	popup.id = 'editCoursePopup';
    	popup.innerHTML = formHtml;
    	document.body.appendChild(popup);
	}

	// Ajouter un nouveau dÃ©part dans l'Ã©dition
	function addEditTeeInput() {
    	var container = document.getElementById('editTeeInputs');
   		var newRow = document.createElement('div');
    	newRow.className = 'tee-form-row';
    	newRow.innerHTML = 
        	'<select>' +
        	'<option value="blanc">Blanc</option>' +
    		'<option value="bleu">Bleu</option>' +
    		'<option value="vert">Vert</option>' +
        	'<option value="jaune">Jaune</option>' +
        	'<option value="noir">Noir</option>' +
    		'</select>' +
    		'<input type="number" placeholder="Rating (ex: 69.5)" step="0.1" min="60" max="80">' +
        	'<input type="number" placeholder="Slope (ex: 123)" min="85" max="155">' +
        	'<input type="number" placeholder="Par (ex: 72)" min="68" max="76">' +
    		'<button type="button" class="btn-danger" onclick="removeEditTeeInput(this)">âŒ</button>';
    	container.appendChild(newRow);
	}

	// Supprimer un dÃ©part dans l'Ã©dition
	function removeEditTeeInput(button) {
    	var container = document.getElementById('editTeeInputs');
    	if (container.children.length > 1) {
        	button.parentElement.remove();
    	} else {
        	alert('Un terrain doit avoir au moins un dÃ©part.');
    	}
	}

	// Sauvegarder les modifications du terrain
	function saveCourseEdit(originalCourseName) {
    	var newCourseName = document.getElementById('editCourseName').value.trim();
    	if (!newCourseName) {
        	alert('Veuillez saisir le nom du terrain.');
        	return;
    	}
    
    	// VÃ©rifier si le nouveau nom existe dÃ©jÃ  (sauf si c'est le mÃªme)
    	if (newCourseName !== originalCourseName && coursesDatabase[newCourseName]) {
        	alert('Un terrain avec ce nom existe dÃ©jÃ .');
        	return;
    	}
    
    	var teeRows = document.querySelectorAll('#editTeeInputs .tee-form-row');
    	var tees = [];
    
    	for (var i = 0; i < teeRows.length; i++) {
        	var row = teeRows[i];
        	var select = row.querySelector('select');
    		var ratingInput = row.querySelectorAll('input')[0];
   			var slopeInput = row.querySelectorAll('input')[1];
        	var parInput = row.querySelectorAll('input')[2];
        
        	var teeColor = select.value;
    		var rating = parseFloat(ratingInput.value);
    		var slope = parseInt(slopeInput.value);
			var par = parseInt(parInput.value);
        
        	if (!rating || !slope || !par || rating < 60 || rating > 80 || slope < 85 || slope > 155 || par < 68 || par > 76) {
        		alert('Veuillez remplir tous les champs avec des valeurs valides (Rating: 60-80, Slope: 85-155, Par: 68-76).');
        		return;
        		}
        
        	tees.push({
        		tee: teeColor,
        		rating: rating,
        		slope: slope,
            	par: par
        	});
    	}
    
    	// Si le nom a changÃ©, supprimer l'ancien
    	if (newCourseName !== originalCourseName) {
    		delete coursesDatabase[originalCourseName];
        
        	// Mettre Ã  jour toutes les rÃ©fÃ©rences dans les parties existantes
        	for (var i = 0; i < courses.length; i++) {
        		if (courses[i] === originalCourseName) {
            		courses[i] = newCourseName;
            	}
        	}
        
        	// Mettre Ã  jour les rounds
        	for (var i = 0; i < rounds.length; i++) {
        		if (rounds[i].course === originalCourseName) {
            		rounds[i].course = newCourseName;
            	}
        	}
    	}
    
    	// Sauvegarder le terrain (nouveau nom ou modifiÃ©)
    	coursesDatabase[newCourseName] = tees;
    
		// Sauvegarder dans Firebase
    	Promise.all([
    		saveCoursesToFirebase(),
    		saveDatesToFirebase()
    	]).then(function() {
        	console.log('Terrain modifiÃ© dans Firebase');
        	var action = newCourseName !== originalCourseName ? 'renommÃ© et modifiÃ©' : 'modifiÃ©';
    		alert('âœ… Terrain "' + newCourseName + '" ' + action + ' avec succÃ¨s!');
    		cancelCourseEdit();
			loadCoursesList();
        
    	}).catch(function(error) {
    		console.error('Erreur de modification terrain:', error);
    		alert('Erreur de modification: ' + error.message);
    	});
	}

	// Fermer la popup d'Ã©dition
	function cancelCourseEdit() {
    	var popup = document.getElementById('editCoursePopup');
    	if (popup) {
        	popup.remove();
    	}
	}
    function exportCourses() {
        var dataToExport = {
            courses: coursesDatabase,
            exportDate: new Date().toISOString(),
            totalCourses: Object.keys(coursesDatabase).length
        };
            
        var dataStr = JSON.stringify(dataToExport, null, 2);
        var dataBlob = new Blob([dataStr], {type: 'application/json'});
            
        var link = document.createElement('a');
        link.href = URL.createObjectURL(dataBlob);
        link.download = 'terrains-golf-' + new Date().toISOString().split('T')[0] + '.json';
        link.click();
    }

    function saveCourseData() {
        try {
            var dataString = JSON.stringify(coursesDatabase);
            // Simulate saving to storage
            console.log('Courses saved:', Object.keys(coursesDatabase).length + ' terrains');
        } catch (e) {
            console.error('Erreur de sauvegarde:', e);
        }
    }

    // Scores par joueur
    function loadPlayerSelector() {
    	var select = document.getElementById('playerSelect');
    	select.innerHTML = '<option value="">-- Choisir un joueur --</option>';
    
    	for (var i = 0; i < players.length; i++) {
        var player = players[i];
        var option = document.createElement('option');
        option.value = player.id;
        option.textContent = player.name || (player.firstName + ' ' + player.lastName); // CORRECTION
        select.appendChild(option);
    	}
	}

    function showPlayerDetail() {
    	var playerId = parseInt(document.getElementById('playerSelect').value);
    	var container = document.getElementById('playerDetail');
    
    	if (!playerId) {
        container.innerHTML = '';
        return;
    	}
    
    	var player = players.find(p => p.id === playerId);
    	var playerScores = scores.filter(s => s.playerId === playerId);
    
    	if (playerScores.length === 0) {
        container.innerHTML = '<div class="card"><p>Aucun score enregistrÃ© pour ce joueur.</p></div>';
        return;
    	}
    
    	var playerName = player.name || (player.firstName + ' ' + player.lastName); // CORRECTION
    
    	// Statistiques du joueur
    	var avgGross = playerScores.reduce((sum, s) => sum + s.score, 0) / playerScores.length;
    	var avgNet = playerScores.reduce((sum, s) => sum + s.net, 0) / playerScores.length;
    	var bestGross = Math.min(...playerScores.map(s => s.score));
    	var worstGross = Math.max(...playerScores.map(s => s.score));
    	var bestNet = Math.min(...playerScores.map(s => s.net));
    	var worstNet = Math.max(...playerScores.map(s => s.net));
    
    	var diabloScores = playerScores.filter(s => s.type === 'diablo');
    	var gprScores = playerScores.filter(s => s.type === 'gpr');
    
    	var html = '<div class="player-card">' +
               	   '<h3>ğŸŒï¸ ' + playerName + ' (Handicap Index: ' + player.handicap + ')</h3>' +  // UTILISER playerName
               
               	   '<div class="player-stats">' +
                   '<div class="stat-box">' +
           	       '<div class="stat-value">' + playerScores.length + '</div>' +
           	       '<div class="stat-label">Parties JouÃ©es</div>' +
           	       '</div>' +
                   '<div class="stat-box">' +
               	   '<div class="stat-value">' + avgGross.toFixed(1) + '</div>' +
                   '<div class="stat-label">Score Brut Moyen</div>' +
           	       '</div>' +
           	       '<div class="stat-box">' +
           	       '<div class="stat-value">' + avgNet.toFixed(1) + '</div>' +
               	   '<div class="stat-label">Score Net Moyen</div>' +
               	   '</div>' +
                   '<div class="stat-box">' +
           	       '<div class="stat-value">' + bestGross + '</div>' +
           	       '<div class="stat-label">Meilleur Score Brut</div>' +
           	       '</div>' +
               	   '<div class="stat-box">' +
               	   '<div class="stat-value">' + bestNet.toFixed(1) + '</div>' +
                   '<div class="stat-label">Meilleur Score Net</div>' +
           	       '</div>' +
           	       '<div class="stat-box">' +
           	       '<div class="stat-value">' + diabloScores.length + '</div>' +
               	   '<div class="stat-label">Parties Diablo</div>' +
               	   '</div>' +
                   '<div class="stat-box">' +
           	       '<div class="stat-value">' + gprScores.length + '</div>' +
           	       '<div class="stat-label">Parties GPR</div>' +
           	       '</div>' +
               	   '</div>' +
               
               	   '<h4>ğŸ“‹ Historique des Scores</h4>' +
                   '<div class="score-history">';
    
    	// Trier les scores par date (plus rÃ©cents en premier)
        playerScores.sort((a, b) => {
        var roundA = rounds.find(r => r.id === a.roundId);
        var roundB = rounds.find(r => r.id === b.roundId);
        return new Date(roundB.date) - new Date(roundA.date);
    	});
    
    	for (var i = 0; i < playerScores.length; i++) {
        var score = playerScores[i];
        var round = rounds.find(r => r.id === score.roundId);
        
        var scoreClass = '';
        if (score.score === bestGross) scoreClass = 'best-score';
        else if (score.score === worstGross) scoreClass = 'worst-score';
        
        var badgeClass = score.type === 'diablo' ? 'badge-diablo' : 'badge-gpr';
        var badgeText = score.type === 'diablo' ? 'ğŸ† Diablo' : 'ğŸ¯ GPR';
        
        var teeIcon = score.tee === 'bleu' ? 'ğŸ”µ' : 'âšª';
        
        html += '<div class="score-row">' +
                '<div>' +
                '<strong>' + round.date.split('-').reverse().join('/') + '</strong><br>' +
            	'<small>' + round.course + ' ' + teeIcon + ' ' + score.tee + '</small>' +
            	'</div>' +
            	'<div class="tournament-badge ' + badgeClass + '">' + badgeText + '</div>' +
            	'<div style="text-align: right;">' +
                '<span class="' + scoreClass + '">Brut: ' + score.score + '</span><br>' +
            	'<small>Handicap: ' + score.courseHandicap.toFixed(1) + ' | Net: ' + score.net.toFixed(1) + '</small>' +
            	'</div>' +
            	'</div>';
    	}
    
    	html += '</div></div>';
    	container.innerHTML = html;
	}

        // 1. REMPLACER LA FONCTION loadDiablo() par celle-ci :

	function loadDiablo() {
    	loadYearSelectors();
    
    	var selectedYear = document.getElementById('diabloYearSelect').value;
    
    	var diabloScores = scores.filter(s => {
        	return s.type === 'diablo' && (!selectedYear || s.year == selectedYear);
    	});

    	if (diabloScores.length === 0) {
        	document.getElementById('diabloContent').innerHTML = '<p>Aucune partie Diablo trouvÃ©e pour cette pÃ©riode.</p>';
        	document.getElementById('diabloStatus').innerHTML = '';
        	return;
    	}

    	updateDiabloStatus(selectedYear);

    	var playerStats = {};
    
    	for (var i = 0; i < diabloScores.length; i++) {
        	var score = diabloScores[i];
        	if (!playerStats[score.playerId]) {
            	var player = players.find(p => p.id === score.playerId);
            	var playerName = player ? (player.name || (player.firstName + ' ' + player.lastName)) : ('Joueur #' + score.playerId);
            
            	playerStats[score.playerId] = {
                	player: player,
                	playerName: playerName,
                	totalRounds: 0,
                	totalNet: 0
            	};
        	}
        	playerStats[score.playerId].totalRounds++;
        	playerStats[score.playerId].totalNet += score.net;
    	}

    	var leaderboard = [];
    	for (var playerId in playerStats) {
        	var stats = playerStats[playerId];
        	leaderboard.push({
            	player: stats.player,
            	playerName: stats.playerName,
            	rounds: stats.totalRounds,
            	avgNet: stats.totalNet / stats.totalRounds
        	});
    	}

    	leaderboard.sort((a, b) => a.avgNet - b.avgNet);

    	var yearText = selectedYear ? selectedYear : 'Toutes les annÃ©es';
    	var html = '';
    
    	// === TABLEAU RÃ‰CAPITULATIF DIABLO (existant) ===
    	html += '<div class="card" style="margin-top: 30px;">' +
        	    '<h4>ğŸ“Š Tableau RÃ©capitulatif - Scores par Partie</h4>' +
            	'<div style="overflow-x: auto;">' +
            	'<table class="table" style="font-size: 12px;">' +
            	'<thead><tr><th>Joueur</th>';

    	var diabloRounds = rounds.filter(r => {
        	return r.type === 'diablo' && (!selectedYear || r.year == selectedYear);
    	});
    
    	diabloRounds.sort((a, b) => new Date(a.date) - new Date(b.date));
    
    	for (var i = 0; i < diabloRounds.length; i++) {
        	var round = diabloRounds[i];
        	var dateStr = round.date.split('-').reverse().join('/');
        	html += '<th style="writing-mode: vertical-rl; text-orientation: mixed; padding: 5px; min-width: 60px;">' + 
            	    dateStr + '</th>';
    	}
    
    	if (selectedYear && diabloRounds.length >= 3) {
        	html += '<th style="background: #8b1a1a !important; color: white !important; font-weight: bold; text-align: center;">Total Diablo</th>';
    	}
    
    	html += '</tr></thead><tbody>';
    	    
    	    // Construire les donnÃ©es pour chaque joueur
    	    var playerDiabloData = {};
    	    
    	    for (var i = 0; i < diabloScores.length; i++) {
        	    var score = diabloScores[i];
        	    if (!playerDiabloData[score.playerId]) {
            	    var player = players.find(p => p.id === score.playerId);
            	    var playerName = player ? (player.name || (player.firstName + ' ' + player.lastName)) : ('Joueur #' + score.playerId);
            	    
            	    playerDiabloData[score.playerId] = {
                	    playerName: playerName,
                	    scores: {},
                	    totalNet: 0,
                	    totalDiff: 0,
                	    gamesPlayed: 0
            	    };
        	    }
        	    
        	    // Calculer le diffÃ©rentiel
        	    var round = rounds.find(r => r.id === score.roundId);
        	    var differential = calculateScoreDifferentialReal(score.score, round.course, score.tee);
        	    
        	    playerDiabloData[score.playerId].scores[score.roundId] = {
            	    score: score.score,
            	    net: score.net,
            	    differential: differential
        	    };
        	    
        	    playerDiabloData[score.playerId].totalNet += score.net;
        	    playerDiabloData[score.playerId].totalDiff += differential || 0;
        	    playerDiabloData[score.playerId].gamesPlayed++;
    	    }
    	    
    	    // Convertir en array et trier
    	    var playersArray = [];
    	    for (var playerId in playerDiabloData) {
        	    playersArray.push({
            	    playerId: parseInt(playerId),
            	    data: playerDiabloData[playerId]
        	    });
    	    }
    	    
    	    // Trier par moyenne net ou total selon l'annÃ©e
    	    if (selectedYear && diabloRounds.length >= 3) {
        	    // Trier par total des 3 parties - ceux qui n'ont pas jouÃ© les 3 parties vont Ã  la fin
        	    playersArray.sort((a, b) => {
            	    // Compter les parties jouÃ©es pour l'annÃ©e
            	    var aPlayed = 0;
            	    var bPlayed = 0;
            	    
            	    for (var i = 0; i < diabloRounds.length; i++) {
                	    if (a.data.scores[diabloRounds[i].id]) aPlayed++;
                	    if (b.data.scores[diabloRounds[i].id]) bPlayed++;
            	    }
            	    
            	    // Si un joueur n'a pas jouÃ© toutes les parties, il va Ã  la fin (12e position)
            	    if (aPlayed < diabloRounds.length && bPlayed === diabloRounds.length) return 1;
            	    if (bPlayed < diabloRounds.length && aPlayed === diabloRounds.length) return -1;
            	    
            	    // Sinon, trier par total net
            	    return a.data.totalNet - b.data.totalNet;
        	    });
    	    } else {
        	    // Trier par moyenne
        	    playersArray.sort((a, b) => {
            	    var avgA = a.data.gamesPlayed > 0 ? a.data.totalNet / a.data.gamesPlayed : 999;
            	    var avgB = b.data.gamesPlayed > 0 ? b.data.totalNet / b.data.gamesPlayed : 999;
            	    return avgA - avgB;
        	    });
    	    }
    	    
    	    // Afficher les lignes
    	    for (var p = 0; p < playersArray.length; p++) {
        	    var playerData = playersArray[p];
        	    var data = playerData.data;
        	    
        	    // Style de ligne selon le rang
        	    var rowStyle = '';
        	    if (p === 0) rowStyle = ' style="background: #fff4e6;"'; // Or
        	    else if (p === 1) rowStyle = ' style="background: #f0f0f0;"'; // Argent
        	    else if (p === 2) rowStyle = ' style="background: #fff0e6;"'; // Bronze
        	    
        	    html += '<tr' + rowStyle + '><td><strong>' + (p + 1) + '. ' + data.playerName + '</strong></td>';
        	    
        	    // Scores pour chaque partie
        	    var partiesTotalNet = 0;
        	    var partiesTotalDiff = 0;
        	    var partiesCount = 0;
        	    
        	    for (var i = 0; i < diabloRounds.length; i++) {
            	    var round = diabloRounds[i];
            	    var scoreData = data.scores[round.id];
            	    
            	    if (scoreData) {
                	    // Obtenir le par du terrain
                	    var round = diabloRounds[i];
                	    var coursePar = 72; // Par dÃ©faut
                	    if (coursesDatabase[round.course]) {
                    	    var courseData = coursesDatabase[round.course];
                    	    var teeData = courseData.find(t => t.tee === (scoreData.tee || round.tee));
                    	    if (teeData && teeData.par) {
                        	    coursePar = teeData.par;
                    	    }
                	    }
                	    
                	    // Calculer le diffÃ©rentiel (score net - par)
                	    var differential = Math.round(scoreData.net) - coursePar;
                	    var differentialStr = differential > 0 ? '+' + differential : differential.toString();
                	    
                	    html += '<td style="text-align: center;">' +
                    	        '<span style="font-size: 16px; font-weight: bold;">' + differentialStr + '</span> ' +
                    	        '<span style="font-size: 12px;">(' + scoreData.score + ')</span></td>';
                    	        
                	    // Pour le calcul du total Diablo
                	    if (selectedYear) {
                    	    partiesTotalNet += scoreData.net;
                    	    partiesCount++;
                	    }
            	    } else {
                	    html += '<td style="text-align: center; color: #ccc;">-</td>';
            	    }
        	    }
        	    
        	    // Colonne Total si annÃ©e spÃ©cifique et au moins 3 parties
        	    if (selectedYear && diabloRounds.length >= 3) {
            	    if (partiesCount === diabloRounds.length) {
                	    // Calculer le total des pars pour les parties jouÃ©es
                	    var totalPar = 0;
                	    var totalScore = 0;
                	    
                	    for (var i = 0; i < diabloRounds.length; i++) {
                    	    var round = diabloRounds[i];
                    	    var scoreData = data.scores[round.id];
                    	    
                    	    if (scoreData) {
                        	    totalScore += scoreData.score;
                        	    
                        	    // Obtenir le par du terrain
                        	    var coursePar = 72; // Par dÃ©faut
                        	    if (coursesDatabase[round.course]) {
                            	        var courseData = coursesDatabase[round.course];
                            	        var teeData = courseData.find(t => t.tee === (scoreData.tee || round.tee));
                            	        if (teeData && teeData.par) {
                                	        coursePar = teeData.par;
                            	        }
                        	    }
                        	    totalPar += coursePar;
                    	    }
                	    }
                	    
                	    // DiffÃ©rentiel total (score net total - par total)
                	    var totalDifferential = Math.round(partiesTotalNet) - totalPar;
                	    var totalDiffStr = totalDifferential > 0 ? '+' + totalDifferential : totalDifferential.toString();
                	    
                	    html += '<td style="text-align: center; background: #8b1a1a; color: white;">' +
                    	        '<span style="font-size: 20px; font-weight: bold;">' + totalDiffStr + '</span> ' +
                    	        '<span style="font-size: 14px;">(' + totalScore + ')</span></td>';
            	    } else {
                	    html += '<td style="text-align: center; background: #8b1a1a; color: #999;">-</td>';
            	    }
        	    }
        	    
        	    html += '</tr>';
    	    }
    	    
    	    html += '</tbody></table></div>' +
            		'<div style="margin-top: 10px; font-size: 12px; color: #666;">' +
            		'<strong>LÃ©gende:</strong> Score brut (DiffÃ©rentiel) | ' +
            		'Le diffÃ©rentiel mesure la performance relative au parcours' +
            		'</div></div>';
    
    		// === NOUVEAU : DÃ‰TAILS DE CHAQUE PARTIE DIABLO ===
    		html += '<div class="card" style="margin-top: 30px;">' +
            		'<h4>ğŸ“‹ DÃ©tails de chaque Partie</h4>';

    		for (var i = 0; i < diabloRounds.length; i++) {
       			var round = diabloRounds[i];
        		var roundScores = scores.filter(s => s.roundId === round.id);
        
        		if (roundScores.length === 0) continue;
        
        		// Obtenir le par du terrain
        		var coursePar = 72; // Par dÃ©faut
        		if (coursesDatabase[round.course]) {
            		var courseData = coursesDatabase[round.course];
            		var teeData = courseData.find(t => t.tee === round.tee);
            		if (teeData && teeData.par) {
                		coursePar = teeData.par;
            		}
        		}
        
        		html += '<div style="margin: 15px 0; padding: 15px; border: 2px solid #8b1a1a; border-radius: 10px; background: #fff8f8;">' +
                		'<div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 15px;">' +
                		'<div>' +
                		'<strong style="color: #8b1a1a; font-size: 16px;">ğŸ† ' + round.date.split('-').reverse().join('/') + ' - ' + round.course + '</strong>' +
                		'<br><small>DÃ©part: ' + round.tee + ' | Par: ' + coursePar + ' | ' + roundScores.length + ' joueurs</small>' +
                		'</div>' +
                		'<button class="btn-secondary" onclick="toggleDiabloRoundDetail(\'diablo_round_' + round.id + '\')">ğŸ‘ï¸ Voir/Masquer</button>' +
                		'</div>';

        		html += '<div id="diablo_round_' + round.id + '" style="display: block;">' +
                		'<table class="table" style="font-size: 13px;">' +
                		'<thead>' +
                		'<tr style="background: #8b1a1a; color: white;">' +
                		'<th>Pos</th>' +
                		'<th>Joueur</th>' +
                		'<th>Score Brut</th>' +
                		'<th>Diff. Brut</th>' +
                		'<th>Hcp Parcours</th>' +
                		'<th>Score Net</th>' +
                		'<th>Diff. Net</th>' +
                		'<th>DiffÃ©rentiel</th>' +
                		'</tr>' +
                		'</thead>' +
                		'<tbody>';
        
        		// Trier par score net
        		roundScores.sort((a, b) => a.net - b.net);
        
        		for (var j = 0; j < roundScores.length; j++) {
            		var score = roundScores[j];
            
            		// Calculer les diffÃ©rentiels
            		var brutDiff = score.score - coursePar;
            		var netDiff = Math.round(score.net) - coursePar;
            		var differential = calculateScoreDifferentialReal(score.score, round.course, score.tee);
            
            		// Style pour le podium
            		var rowStyle = '';
            		if (j === 0) rowStyle = ' style="background: #fff4e6;"'; // Or
            		else if (j === 1) rowStyle = ' style="background: #f0f0f0;"'; // Argent
            		else if (j === 2) rowStyle = ' style="background: #fff0e6;"'; // Bronze
            
            		// Formatage des diffÃ©rentiels
            		var brutDiffStr = brutDiff > 0 ? '+' + brutDiff : brutDiff.toString();
            		var netDiffStr = netDiff > 0 ? '+' + netDiff : netDiff.toString();
            		var diffStr = differential ? differential.toFixed(1) : 'N/A';
            
            		// IcÃ´ne selon la position
            		var posIcon = '';
            		if (j === 0) posIcon = 'ğŸ¥‡ ';
            		else if (j === 1) posIcon = 'ğŸ¥ˆ ';
            		else if (j === 2) posIcon = 'ğŸ¥‰ ';
            
            		html += '<tr' + rowStyle + '>' +
                    		'<td><strong>' + posIcon + (j + 1) + '</strong></td>' +
                    		'<td><strong>' + score.playerName + '</strong></td>' +
                    		'<td style="text-align: center; font-weight: bold;">' + score.score + '</td>' +
                    		'<td style="text-align: center; color: ' + (brutDiff < 0 ? '#28a745' : brutDiff > 0 ? '#dc3545' : '#333') + ';">' +
                    		'<strong>' + brutDiffStr + '</strong></td>' +
                    		'<td style="text-align: center;">' + score.courseHandicap.toFixed(1) + '</td>' +
                    		'<td style="text-align: center; font-weight: bold; color: #8b1a1a;">' + Math.round(score.net) + '</td>' +
                    		'<td style="text-align: center; color: ' + (netDiff < 0 ? '#28a745' : netDiff > 0 ? '#dc3545' : '#333') + ';">' +
                    		'<strong>' + netDiffStr + '</strong></td>' +
                    		'<td style="text-align: center;">' + diffStr + '</td>' +
                    		'</tr>';
        		}
        
        		html += '</tbody></table>';
        
        		// Statistiques de la partie
        		var avgBrut = roundScores.reduce((sum, s) => sum + s.score, 0) / roundScores.length;
        		var avgNet = roundScores.reduce((sum, s) => sum + s.net, 0) / roundScores.length;
        		var bestBrut = Math.min(...roundScores.map(s => s.score));
        		var bestNet = Math.min(...roundScores.map(s => s.net));
        
        		html += '<div style="margin-top: 10px; padding: 10px; background: #ffe8e8; border-radius: 5px; font-size: 12px;">' +
                		'<strong>ğŸ“Š Statistiques de la partie:</strong><br>' +
                		'<div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(150px, 1fr)); gap: 10px; margin-top: 5px;">' +
                		'<div>ğŸŒï¸ Meilleur brut: <strong>' + bestBrut + '</strong></div>' +
                		'<div>ğŸ¯ Meilleur net: <strong>' + Math.round(bestNet) + '</strong></div>' +
                		'<div>ğŸ“ˆ Moyenne brut: <strong>' + avgBrut.toFixed(1) + '</strong></div>' +
                		'<div>ğŸ“Š Moyenne net: <strong>' + avgNet.toFixed(1) + '</strong></div>' +
                		'</div>' +
                		'</div>';
        
        		html += '</div></div>';
    		}
    
    		// Statistiques globales du tournoi
    		if (diabloRounds.length > 0) {
        		html += '<div style="margin-top: 20px; padding: 15px; background: #8b1a1a; color: white; border-radius: 8px;">' +
                		'<h5 style="margin: 0 0 10px 0;">ğŸ† RÃ©sumÃ© du Tournoi Diablo ' + yearText + '</h5>' +
                		'<div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(200px, 1fr)); gap: 15px;">' +
                		'<div>ğŸ“… Nombre de parties: <strong>' + diabloRounds.length + '</strong></div>' +
                		'<div>ğŸ‘¥ Participants uniques: <strong>' + leaderboard.length + '</strong></div>' +
                		'<div>ğŸ¥‡ Leader actuel: <strong>' + (leaderboard[0] ? leaderboard[0].playerName : 'N/A') + '</strong></div>' +
                		'<div>ğŸ¯ Meilleur moyenne net: <strong>' + (leaderboard[0] ? leaderboard[0].avgNet.toFixed(1) : 'N/A') + '</strong></div>' +
                		'</div>' +
                		'</div>';
    		}
    
    		html += '</div>';
    
    		document.getElementById('diabloContent').innerHTML = html;
		}

		// Fonction pour afficher/masquer les dÃ©tails d'une partie Diablo
		function toggleDiabloRoundDetail(roundId) {
    		var element = document.getElementById(roundId);
    		if (element.style.display === 'none') {
        		element.style.display = 'block';
    		} else {
        		element.style.display = 'none';
    		}
		}

	// FONCTION loadGPR
	function loadGPR() {
	    loadYearSelectors();
    	console.log('=== DÃ‰BUT loadGPR ===');

    	// DÃ‰CLARER TOUTES LES VARIABLES AU DÃ‰BUT DE LA FONCTION
    	playerPoints = {};
    	playerBest4Points = {};
    	roundDetails = [];

    	var selectedYear = document.getElementById('gprYearSelect').value;

    	var gprScores = scores.filter(s => {
        	return s.type === 'gpr' && (!selectedYear || s.year == selectedYear);
    	});

    	if (gprScores.length === 0) {
        	document.getElementById('gprContent').innerHTML = '<p>Aucune partie GPR trouvÃ©e pour cette pÃ©riode.</p>';
        	document.getElementById('gprStatus').innerHTML = '';
        	return;
    	}

    	updateGPRStatus(selectedYear);

    	var gprRounds = rounds.filter(r => {
        	return r.type === 'gpr' && (!selectedYear || r.year == selectedYear);
    	});
    
    	console.log('=== FILTRAGE PAR ANNÃ‰E ===');
    	console.log('AnnÃ©e sÃ©lectionnÃ©e:', selectedYear);
    	console.log('Scores GPR trouvÃ©s:', gprScores.length);

    	// SÃ©parer les parties Exhibition et Finale
    	var exhibitionRounds = gprRounds.filter(r => !r.gprPhase || r.gprPhase === 'exhibition');
    	var finaleRounds = gprRounds.filter(r => r.gprPhase === 'finale');
    
    	// Pour le tableau rÃ©capitulatif, on veut TOUTES les finales si "Toutes les annÃ©es"
    	var allFinaleRoundsForTable = finaleRounds;
    	if (!selectedYear) {
        	// Si "Toutes les annÃ©es", prendre toutes les finales GPR
        	allFinaleRoundsForTable = rounds.filter(r => 
            	r.type === 'gpr' && 
            	r.gprPhase === 'finale'
        	);
    	}
    
    	console.log('Finales pour le tableau:', allFinaleRoundsForTable.length);
    	console.log('=== SÃ‰PARATION DES ROUNDS GPR ===');
    	console.log('Total rounds GPR:', gprRounds.length);
    	console.log('Rounds exhibition:', exhibitionRounds.length);
    	console.log('Rounds finale:', finaleRounds.length);

    	// IMPORTANT : Filtrer pour avoir SEULEMENT les vraies exhibitions (pas les finales)
    	exhibitionRounds = exhibitionRounds.filter(r => r.gprPhase !== 'finale');
    	console.log('Rounds exhibition aprÃ¨s filtrage:', exhibitionRounds.length);

    	// === TRAITEMENT DES PARTIES EXHIBITION ===
    	var pointsScale = [120, 105, 90, 78, 70, 62, 54, 46, 38, 30, 22, 15];
    	var grossPointsScale = [80, 68, 60, 52, 45, 40, 35, 30, 25, 20, 15, 10];

    	// Points pour les finales
    	var finaleNetPointsScale = [225, 190, 165, 140, 125, 110, 90, 75, 60, 45, 35, 25];
    	var finaleBrutPointsScale = [175, 140, 120, 100, 85, 70, 60, 50, 40, 30, 20, 10];

    	for (var i = 0; i < exhibitionRounds.length; i++) {
        	var round = exhibitionRounds[i];
        	var roundScores = gprScores.filter(s => s.roundId === round.id && s.playerId !== 13);

        	// Identifier TOUS les joueurs GPR de l'annÃ©e (pour les absents)
        	var allGPRPlayers = scores.filter(s => 
            	s.year === round.year && 
            	s.type === 'gpr' && 
            	s.playerId !== 13
        	).map(s => s.playerId).filter((v, i, a) => a.indexOf(v) === i);

        	// Ajouter les absents avec score fictif Ã©levÃ©
        	var presentPlayers = roundScores.map(s => s.playerId);
        	for (var p = 0; p < allGPRPlayers.length; p++) {
            	var playerId = allGPRPlayers[p];
            	if (!presentPlayers.includes(playerId)) {
                	var player = players.find(p => p.id === playerId);
                	// Ajouter un score fictif pour l'absent
                	roundScores.push({
                    	playerId: playerId,
                    	playerName: player.name || (player.firstName + ' ' + player.lastName),
                    	score: 999, // Score trÃ¨s Ã©levÃ©
                    	net: 999,   // Net trÃ¨s Ã©levÃ©
                    	absent: true
                	});
            	}
        	}

        	console.log('Partie du', round.date, '- Joueurs:', roundScores.length, '(dont absents)');

        	// Classement par score net avec gestion des ex-Ã¦quo
        	var netGroups = {};
        	roundScores.forEach(function(score, index) {
            	var netValue = score.net;
            	if (!netGroups[netValue]) {
                	netGroups[netValue] = [];
            	}
            	netGroups[netValue].push({score: score, originalIndex: index});
        	});

        	// Trier les groupes
        	var sortedNetGroups = Object.keys(netGroups).sort((a, b) => parseFloat(a) - parseFloat(b));

        	var netRanking = [];
        	var currentPosition = 0;

        	for (var g = 0; g < sortedNetGroups.length; g++) {
            	var group = netGroups[sortedNetGroups[g]];
            	var totalPoints = 0;

            	// Calculer les points totaux pour ce groupe
            	for (var j = 0; j < group.length; j++) {
                	totalPoints += pointsScale[Math.min(currentPosition + j, pointsScale.length - 1)];
            	}

            	var pointsPerPlayer = Math.round(totalPoints / group.length);

            	// Attribuer les points
            	for (var j = 0; j < group.length; j++) {
                	netRanking.push({
                    	player: group[j].score,
                    	position: currentPosition + 1,
                    	points: pointsPerPlayer
                	});
            	}

            	currentPosition += group.length;
        	}

        	// Faire la mÃªme chose pour le classement brut
        	var grossGroups = {};
        	roundScores.forEach(function(score, index) {
            	var grossValue = score.score;
            	if (!grossGroups[grossValue]) {
                	grossGroups[grossValue] = [];
            	}
            	grossGroups[grossValue].push({score: score, originalIndex: index});
        	});

        	var sortedGrossGroups = Object.keys(grossGroups).sort((a, b) => parseFloat(a) - parseFloat(b));

        	var grossRanking = [];
        	currentPosition = 0;

        	for (var g = 0; g < sortedGrossGroups.length; g++) {
            	var group = grossGroups[sortedGrossGroups[g]];
            	var totalPoints = 0;

            	for (var j = 0; j < group.length; j++) {
                	totalPoints += grossPointsScale[Math.min(currentPosition + j, grossPointsScale.length - 1)];
            	}

            	var pointsPerPlayer = Math.round(totalPoints / group.length);

            	for (var j = 0; j < group.length; j++) {
                	grossRanking.push({
                    	player: group[j].score,
                    	position: currentPosition + 1,
                    	points: pointsPerPlayer
                	});
            	}

            	currentPosition += group.length;
        	}

        	// CRÃ‰ER LE ROUNDDETAIL
        	var roundDetail = {
            	round: round,
            	netRanking: netRanking,
            	grossRanking: grossRanking,
            	isExhibition: true,
            	isFinale: false
        	};

        	roundDetails.push(roundDetail);

        	// ACCUMULER LES POINTS POUR CHAQUE JOUEUR
        	for (var k = 0; k < roundScores.length; k++) {
            	var score = roundScores[k];

            	// Ne pas Ignorer les absents - ils doivent recevoir leur points!
                    
            	if (!playerPoints[score.playerId]) {
                	var player = players.find(p => p.id === score.playerId);
                	var playerName = player ? (player.name || (player.firstName + ' ' + player.lastName)) : ('Joueur #' + score.playerId);

                	playerPoints[score.playerId] = {
                    	player: player,
                    	playerName: playerName,
                    	totalPoints: 0,
                    	rounds: 0,
                    	exhibitionPoints: 0,
                    	finalePoints: 0,
                    	details: []
                	};
            	}

            	if (!playerBest4Points[score.playerId]) {
                	var player = players.find(p => p.id === score.playerId);
                	var playerName = player ? (player.name || (player.firstName + ' ' + player.lastName)) : ('Joueur #' + score.playerId);

                	playerBest4Points[score.playerId] = {
                    	player: player,
                    	playerName: playerName,
                    	best4Points: 0,
                    	finalePoints: 0,
                    	totalBest4: 0,
                    	best4Details: []
                	};
            	}

            	// Trouver les points pour ce joueur dans cette partie
            	var netResult = netRanking.find(r => r.player.playerId === score.playerId);
            	var grossResult = grossRanking.find(r => r.player.playerId === score.playerId);

            	var netPoints = netResult ? netResult.points : 0;
            	var grossPoints = grossResult ? grossResult.points : 0;
            	var totalRoundPoints = netPoints + grossPoints;

            	playerPoints[score.playerId].totalPoints += totalRoundPoints;
            	playerPoints[score.playerId].exhibitionPoints += totalRoundPoints;
            	playerPoints[score.playerId].rounds++;

            	// Stocker les dÃ©tails de cette partie exhibition
            	playerPoints[score.playerId].details.push({
                	round: round,
                	grossScore: score.score,
                	netScore: score.net,
                	grossPosition: grossResult ? grossResult.position : '-',
                	netPosition: netResult ? netResult.position : '-',
                	grossPoints: grossPoints,
                	netPoints: netPoints,
                	totalRoundPoints: totalRoundPoints,
                	courseHandicap: score.courseHandicap,
                	type: 'exhibition'
            	});
        	}
    	} // FIN DE LA BOUCLE DES EXHIBITIONS

    	// === CALCUL DES 4 MEILLEURES PARTIES ===
		var yearToCalculate = selectedYear ? parseInt(selectedYear) : new Date().getFullYear();
		console.log('AnnÃ©e pour calcul best4:', yearToCalculate, 'Type:', typeof yearToCalculate);
    	console.log('=== DEBUG CALCUL FINALE ===');
    	console.log('AnnÃ©e pour calcul finale:', yearToCalculate);
    	console.log('Type de yearToCalculate:', typeof yearToCalculate);
    	console.log('selectedYear:', selectedYear, 'type:', typeof selectedYear);
    
    	// DEBUG: VÃ©rifier les finales
    	console.log('=== DEBUG FINALES ===');
    	console.log('AnnÃ©e calculÃ©e:', yearToCalculate);
    	var testFinaleRounds = rounds.filter(r => r.year === yearToCalculate && r.gprPhase === 'finale');
    	console.log('Parties finale trouvÃ©es:', testFinaleRounds);
    
    	for (var playerId in playerPoints) {
    		var playerIdInt = parseInt(playerId);
    
    		// S'assurer que playerBest4Points[playerId] existe
    		if (!playerBest4Points[playerId]) {
        		var player = players.find(p => p.id === playerIdInt);
        		playerBest4Points[playerId] = {
            		player: player,
            		playerName: player.name || (player.firstName + ' ' + player.lastName),
            		best4Points: 0,
            		finalePoints: 0,
            		totalBest4: 0,
            		best4Details: []
        		};
    		}
    
    		// Calculer les 4 meilleures exhibitions
    		var yearForCalculation = selectedYear ? parseInt(selectedYear) : new Date().getFullYear();
    		var best4Results = calculateBest4Exhibition(playerIdInt, yearForCalculation);
    
    		console.log('Calcul best4 pour joueur', playerId, 'annÃ©e', yearForCalculation, ':', best4Results.length, 'parties');
    
    		var best4Total = 0;
    		playerBest4Points[playerId].best4Details = []; // RÃ©initialiser
    
    		for (var i = 0; i < best4Results.length; i++) {
        		best4Total += best4Results[i].totalPoints;
        
        		playerBest4Points[playerId].best4Details.push({
            		round: rounds.find(r => r.id === best4Results[i].roundId),
            		grossScore: best4Results[i].score.score,
            		netScore: best4Results[i].score.net,
            		grossPosition: best4Results[i].brutPos,
            		netPosition: best4Results[i].netPos,
            		grossPoints: best4Results[i].brutPoints,
            		netPoints: best4Results[i].netPoints,
            		totalRoundPoints: best4Results[i].totalPoints,
            		isSelected: true,
            		roundId: best4Results[i].roundId // Ajouter l'ID pour faciliter la vÃ©rification
        		});
    		}
    
    		playerBest4Points[playerId].best4Points = best4Total;
    		playerBest4Points[playerId].totalBest4 = best4Total;
    
    		console.log('Best4 total pour', playerBest4Points[playerId].playerName, ':', best4Total);
		}

    	// === TRAITEMENT DES FINALES (400 POINTS FIXES) ===
    	if (finaleRounds.length > 0) {
        	var finaleResults = calculateFinaleScores(yearToCalculate);

        	// Ajouter les points finale aux totaux des joueurs
        	for (var playerId in finaleResults) {
            	var finaleData = finaleResults[playerId];

            	if (!playerPoints[playerId]) {
                	playerPoints[playerId] = {
                    	player: finaleData.player,
                    	playerName: finaleData.player.name || (finaleData.player.firstName + ' ' + finaleData.player.lastName),
                    	totalPoints: 0,
                    	rounds: 0,
                    	exhibitionPoints: 0,
                    	finalePoints: 0,
                    	details: []
                	};
            	}

            	if (!playerBest4Points[playerId]) {
                	playerBest4Points[playerId] = {
                    	player: finaleData.player,
                    	playerName: finaleData.player.name || (finaleData.player.firstName + ' ' + finaleData.player.lastName),
                    	best4Points: 0,
                    	finalePoints: 0,
                    	totalBest4: 0,
                    	best4Details: []
                	};
            	}

            	// Les points finale sont dÃ©jÃ  corrects (400 points total)
            	var finalePoints = finaleData.totalPointsFinale || 0;
            	console.log('=== DEBUG MULTIPLICATION ===');
            	console.log('Joueur:', finaleData.player.name);
            	console.log('finaleData.totalPointsFinale:', finaleData.totalPointsFinale);
            	console.log('finaleData.daysPlayed:', finaleData.daysPlayed);
            	console.log('finalePoints utilisÃ©s:', finalePoints);

            	console.log('Joueur', finaleData.player.name, 'Points finale:', finalePoints);

            	playerPoints[playerId].totalPoints += finalePoints;
            	playerPoints[playerId].finalePoints = finalePoints;

            	playerBest4Points[playerId].finalePoints = finalePoints;
            	playerBest4Points[playerId].totalBest4 += finalePoints;

            	// Ajouter dÃ©tail finale
            	var finaleDetail = {
                	type: 'finale',
                	totalBrut: finaleData.totalBrut,
                	totalNet: finaleData.totalNet,
                	daysPlayed: finaleData.daysPlayed,
                	brutPosition: finaleData.positionBrut,
                	netPosition: finaleData.positionNet,
                	brutPoints: finaleData.pointsBrut,
                	netPoints: finaleData.pointsNet,
               		totalRoundPoints: finalePoints,
                	absent: finaleData.daysPlayed === 0
            	};

            	playerPoints[playerId].details.push(finaleDetail);
        	}

        	// Debug
        	console.log('=== VÃ‰RIFICATION FINALE GPR ===');
        	var totalPointsDistribues = 0;
        	for (var playerId in finaleResults) {
            	totalPointsDistribues += finaleResults[playerId].totalPointsFinale || 0;
        	}
        	console.log('Total points finale distribuÃ©s:', totalPointsDistribues);

        	// Debug pour voir qui manque
        	console.log('=== DEBUG JOUEURS MANQUANTS ===');
        	for (var playerId in finaleResults) {
            	if (!playerPoints[playerId]) {
                	console.log('Joueur manquant dans playerPoints:', playerId, finaleResults[playerId].player.name);
            	}
        	}

        	// Ajouter les joueurs qui ont SEULEMENT des points de finale (absents Ã  toutes les exhibitions)
        	for (var playerId in finaleResults) {
            	if (!playerPoints[playerId]) {
                	var finaleData = finaleResults[playerId];

                	playerPoints[playerId] = {
                    	player: finaleData.player,
                    	playerName: finaleData.player.name || (finaleData.player.firstName + ' ' + finaleData.player.lastName),
                    	totalPoints: 0,
                    	rounds: 0,
                    	exhibitionPoints: 0,
                    	finalePoints: 0,
                    	details: []
                	};

                	console.log('Ajout joueur absent exhibitions:', playerPoints[playerId].playerName);
            	}

            	if (!playerBest4Points[playerId]) {
                	var finaleData = finaleResults[playerId];

                	playerBest4Points[playerId] = {
                    	player: finaleData.player,
                    	playerName: finaleData.player.name || (finaleData.player.firstName + ' ' + finaleData.player.lastName),
                    	best4Points: 0,
                    	finalePoints: 0,
                    	totalBest4: 0,
                    	best4Details: []
                	};
            	}
        	}
    	}

    	// CrÃ©er les classements
    	var leaderboardComplete = [];
    	var leaderboardBest4 = [];

    	for (var playerId in playerPoints) {
        	var stats = playerPoints[playerId];
        	leaderboardComplete.push({
            	player: stats.player,
            	playerName: stats.playerName,
            	rounds: stats.rounds,
            	totalPoints: stats.totalPoints,
            	exhibitionPoints: stats.exhibitionPoints,
            	finalePoints: stats.finalePoints,
            	details: stats.details,
            	averagePoints: stats.rounds > 0 ? stats.totalPoints / stats.rounds : 0
        	});
    	}

    	for (var playerId in playerBest4Points) {
        	var stats = playerBest4Points[playerId];
        	leaderboardBest4.push({
            	player: stats.player,
            	playerName: stats.playerName,
            	best4Points: stats.best4Points,
            	finalePoints: stats.finalePoints,
            	totalBest4: stats.totalBest4,
            	best4Details: stats.best4Details,
            	partiesCount: stats.best4Details.length
        	});
    	}

    	leaderboardComplete.sort((a, b) => b.totalPoints - a.totalPoints);
    	leaderboardBest4.sort((a, b) => b.totalBest4 - a.totalBest4);

    	var yearText = selectedYear ? selectedYear : 'Toutes les annÃ©es';

    	// Affichage du classement gÃ©nÃ©ral
    	var html = '<div class="card"><h3>Coupe GPR - ' + yearText
        	       
    	// === TABLEAU RÃ‰CAPITULATIF DES POINTS PAR PARTIE ===
    	html += '<div class="card">' +
        	    '<h4>ğŸ“Š Tableau RÃ©capitulatif - Points par Partie</h4>' +
            	'<p style="font-size: 14px; color: #666;">Les 4 meilleures parties d\'exhibition sont marquÃ©es d\'une â­</p>' +
            	'<div style="overflow-x: auto;">' +
            	'<table class="table" style="font-size: 12px;">' +
            	'<thead><tr><th>Joueur</th>';

    	// Combiner toutes les parties (exhibitions + finales) et trier par date
    	var allGameRounds = [];
    	
    	// Ajouter les exhibitions
    	for (var i = 0; i < exhibitionRounds.length; i++) {
        	var round = exhibitionRounds[i];
        	allGameRounds.push({
            	round: round,
            	type: 'exhibition',
            	date: round.date,
            	dateObj: new Date(round.date)
        	});
    	}
    	
    	// Ajouter les finales
    	for (var i = 0; i < allFinaleRoundsForTable.length; i++) {
        	var finaleRound = allFinaleRoundsForTable[i];
        	allGameRounds.push({
            	round: finaleRound,
            	type: 'finale',
            	date: finaleRound.date,
            	dateObj: new Date(finaleRound.date)
        	});
    	}
    	
    	// Trier par date chronologique
    	allGameRounds.sort((a, b) => a.dateObj - b.dateObj);

    	// En-tÃªtes des colonnes (toutes les parties par ordre chronologique)
		for (var i = 0; i < allGameRounds.length; i++) {
    		var gameRound = allGameRounds[i];
    		var dateStr = gameRound.date.split('-').reverse().join('/');
    
    		if (gameRound.type === 'finale') {
        		var year = gameRound.round.year;
        		html += '<th style="background: #1e3a8a; color: white; font-weight: bold; text-align: center; padding: 8px;">Finale ' + year + '<br>' + dateStr + '</th>';
    		} else {
        		html += '<th style="writing-mode: vertical-rl; text-orientation: mixed; padding: 5px; min-width: 60px;">' + dateStr + '</th>';
    		}
		}

		// Ajouter les colonnes Best4 et Total SEULEMENT si une annÃ©e spÃ©cifique est sÃ©lectionnÃ©e
		if (selectedYear) {
    		html += '<th style="background: #ff6b35; color: white; font-weight: bold; text-align: center;">Best 4</th>';
    		html += '<th style="background: #8b1a1a; color: white; font-weight: bold; text-align: center;">Total</th>';
		}

		html += '</tr></thead><tbody>';

    	// Trier les joueurs par total de points dÃ©croissant
    	var allPlayers = Object.keys(playerPoints).map(id => ({
        	id: parseInt(id),
        	data: playerPoints[id],
        	best4Data: playerBest4Points[id]
    	}));
    	
    	// Trier selon que c'est une annÃ©e spÃ©cifique ou toutes les annÃ©es
    	if (selectedYear) {
        	// Pour une annÃ©e spÃ©cifique, trier par Best4 + Finale
        	allPlayers.sort((a, b) => {
            	var totalA = (a.best4Data ? (a.best4Data.best4Points + a.best4Data.finalePoints) : 0);
            	var totalB = (b.best4Data ? (b.best4Data.best4Points + b.best4Data.finalePoints) : 0);
            	return totalB - totalA;
        	});
    	} else {
        	// Pour toutes les annÃ©es, trier par total de tous les points
        	allPlayers.sort((a, b) => b.data.totalPoints - a.data.totalPoints);
    	}

    	// Lignes pour chaque joueur
    	for (var p = 0; p < allPlayers.length; p++) {
        	var playerData = allPlayers[p];
        	var playerId = playerData.id;
        	var player = playerData.data;
        	var best4Info = playerData.best4Data;

        	// Style de ligne selon le rang
        	var rowStyle = '';
        	if (p === 0) rowStyle = ' style="background: #fff4e6;"'; // Or
        	else if (p === 1) rowStyle = ' style="background: #f0f0f0;"'; // Argent
        	else if (p === 2) rowStyle = ' style="background: #fff0e6;"'; // Bronze

        	html += '<tr' + rowStyle + '><td><strong>' + (p + 1) + '. ' + player.playerName + '</strong></td>';

        	// Points pour chaque partie dans l'ordre chronologique
			for (var i = 0; i < allGameRounds.length; i++) {
    			var gameRound = allGameRounds[i];
    
    			if (gameRound.type === 'exhibition') {
        			// Traitement des parties exhibition
        			var round = gameRound.round;
        			var roundDetail = roundDetails.find(rd => rd.round.id === round.id);

        			// Chercher si le joueur a participÃ©
        			var netResult = roundDetail ? roundDetail.netRanking.find(r => r.player.playerId === playerId) : null;
        			var grossResult = roundDetail ? roundDetail.grossRanking.find(r => r.player.playerId === playerId) : null;

        			if (netResult || grossResult) {
            			var netPts = netResult ? netResult.points : 0;
            			var grossPts = grossResult ? grossResult.points : 0;
            			var total = Math.round(netPts + grossPts);
            			var isAbsent = netResult && netResult.player.absent;
    
            			// Style pour les absents
            			var cellStyle = 'text-align: center;';
            			if (isAbsent) {
                			cellStyle += ' font-style: italic; color: #999;';
            			}
    
            			// Afficher les Ã©toiles et barrÃ©s SEULEMENT si une annÃ©e est sÃ©lectionnÃ©e
            			if (selectedYear) {
                			// VÃ©rifier si cette partie fait partie des 4 meilleures
                			var isBest4 = false;
                			var best4Info = playerBest4Points[playerId];
        
                			if (best4Info && best4Info.best4Details) {
                    			isBest4 = best4Info.best4Details.some(detail => 
                        			detail.roundId === round.id
                    			);
                			}
        
                			// Barrer si plus de 4 parties et pas dans best4
                			if (!isAbsent && best4Info && best4Info.best4Details.length >= 4 && !isBest4) {
                    			cellStyle += ' text-decoration: line-through; color: #ccc;';
                			}
        
                			html += '<td style="' + cellStyle + '">' + 
                        			(isBest4 ? 'â­ ' : '') + total + 
                        			'<br><small>(' + Math.round(grossPts) + '+' + Math.round(netPts) + ')</small></td>';
            			} else {
                			// Pas d'Ã©toiles ni de barrÃ©s pour "Toutes les annÃ©es"
                			html += '<td style="' + cellStyle + '">' + 
                        			total + 
                        			'<br><small>(' + Math.round(grossPts) + '+' + Math.round(netPts) + ')</small></td>';
            			}
        			} else {
            			html += '<td style="text-align: center; color: #ccc;">-</td>';
        			}
    
    			} else if (gameRound.type === 'finale') {
        			// Traitement des parties finale
        			var finaleRound = gameRound.round;
        			var year = finaleRound.year;

        			// Chercher les points de cette annÃ©e de finale
        			var finaleDetail = player.details.find(d => 
            			d.type === 'finale' && 
            			rounds.find(r => r.year == year && r.gprPhase === 'finale')
        			);

        			if (finaleDetail && finaleRound.year == year) {
            			var brutPts = Math.round(finaleDetail.brutPoints || 0);
            			var netPts = Math.round(finaleDetail.netPoints || 0);
            			// Pour finale multi-jours, diviser par le nombre de jours
            			var nbJoursFinale = allFinaleRoundsForTable.filter(r => r.year == year).length;
            			var totalPts = Math.round((finaleDetail.brutPoints + finaleDetail.netPoints) / nbJoursFinale);

            			html += '<td style="text-align: center; background: #1e3a8a; color: white; font-size: 16px; font-weight: bold;' + 
                    			(finaleDetail.absent ? ' font-style: italic; opacity: 0.7;' : '') + '">' +
                    			totalPts + '<br>' +
                    			'<small style="color: #cbd5e1; font-weight: normal;">(' + Math.round(brutPts/nbJoursFinale) + '+' + Math.round(netPts/nbJoursFinale) + ')</small></td>';
        			} else {
            			html += '<td style="text-align: center; background: #1e3a8a; color: #64748b; font-size: 16px; font-weight: bold;">-</td>';
        			}
    			}
			}

			// Afficher Best4 et Total SEULEMENT si une annÃ©e spÃ©cifique est sÃ©lectionnÃ©e
			if (selectedYear) {
    			// Total Best 4
    			var playerBest4Info = playerBest4Points[playerId];
    			var best4Points = playerBest4Info ? playerBest4Info.best4Points : 0;
    			var finalePoints = playerBest4Info ? playerBest4Info.finalePoints : 0;
    			
    			html += '<td style="text-align: center; background: #ff6b35; color: white; font-size: 16px; font-weight: bold;">' + 
            			Math.round(best4Points) + '</td>';
    
    			// Total FINAL = Best 4 + Finale (c'est ce qui dÃ©termine le vainqueur)
    			var totalFinal = best4Points + finalePoints;
    			html += '<td style="text-align: center; background: #8b1a1a; color: white; font-size: 16px; font-weight: bold;">' + 
            			Math.round(totalFinal) + '</td>';
			}

			html += '</tr>';
    	}

    	html += '</tbody></table></div>' +
        	    '<div style="margin-top: 10px; font-size: 12px; color: #666;">' +
            	'<strong>LÃ©gende:</strong> Total (Brut+Net) | <em>Italique = Absent</em>' +
				(selectedYear ? ' | â­ = Compte dans les 4 meilleures | <s>BarrÃ©</s> = Ne compte pas' : '') +
            	'</div></div>';

    	// Affichage des parties individuelles
    	html += '<div class="card">' +
        	    '<h4>ğŸ“… DÃ©tails de chaque Partie</h4>';

    	for (var i = 0; i < roundDetails.length; i++) {
        	var roundDetail = roundDetails[i];
        	var round = roundDetail.round;

        	html += '<div style="margin: 15px 0; padding: 15px; border: 1px solid #ddd; border-radius: 8px; background: #f9f9f9;">' +
            	    '<div style="display: flex; justify-content: space-between; align-items: center;">' +
                	'<div>' +
                	'<strong>' + round.date.split('-').reverse().join('/') + ' - ' + round.course + ' (Exhibition)</strong>' +
                	'<br><small>' + roundDetail.netRanking.length + ' joueurs</small>' +
                	'</div>' +
                	'<button class="btn" onclick="toggleRoundDetail(\'round_' + round.id + '\')">ğŸ‘ï¸ Voir classements</button>' +
                	'</div>' +

                	'<div id="round_' + round.id + '" style="display: none; margin-top: 15px;">' +
                	'<div style="display: grid; grid-template-columns: 1fr 1fr; gap: 20px;">' +

                	// Classement net
                	'<div>' +
                	'<h5>ğŸ¯ Classement Score Net</h5>' +
                	'<table class="table" style="font-size: 14px;">' +
                	'<thead><tr><th>Pos</th><th>Joueur</th><th>Score Net</th><th>Points</th></tr></thead>' +
                	'<tbody>';

        	for (var j = 0; j < roundDetail.netRanking.length; j++) {
            	var result = roundDetail.netRanking[j];
            	var playerScore = result.player;

            	html += '<tr>' +
                	    '<td><strong>' + result.position + '</strong></td>' +
                    	'<td>' + playerScore.playerName + '</td>' +
                    	'<td><strong>' + (playerScore.net ? playerScore.net.toFixed(1) : 'N/A') + '</strong></td>' +
                    	'<td><span style="background: #28a745; color: white; padding: 2px 6px; border-radius: 10px;">' + result.points + '</span></td>' +
                    	'</tr>';
        	}

        	html += '</tbody></table></div>' +

            	    // Classement brut
                	'<div>' +
                	'<h5>ğŸŒï¸ Classement Score Brut</h5>' +
                	'<table class="table" style="font-size: 14px;">' +
                	'<thead><tr><th>Pos</th><th>Joueur</th><th>Score Brut</th><th>Points</th></tr></thead>' +
                	'<tbody>';

        	for (var j = 0; j < roundDetail.grossRanking.length; j++) {
            	var result = roundDetail.grossRanking[j];
            	var playerScore = result.player;

            	html += '<tr>' +
                	    '<td><strong>' + result.position + '</strong></td>' +
                    	'<td>' + playerScore.playerName + '</td>' +
                    	'<td><strong>' + playerScore.score + '</strong></td>' +
                    	'<td><span style="background: #17a2b8; color: white; padding: 2px 6px; border-radius: 10px;">' + result.points + '</span></td>' +
                		'</tr>';
    		}

    		html += '</tbody></table></div>' +
            		'</div></div></div>';
		}

		html += '</div>';
		document.getElementById('gprContent').innerHTML = html;
	}

	// 2. FONCTION POUR AFFICHER/MASQUER LES DÃ‰TAILS D'UNE PARTIE
	function toggleRoundDetail(roundId) {
    	    var element = document.getElementById(roundId);
    	    if (element.style.display === 'none') {
        	element.style.display = 'block';
    	    } else {
        	element.style.display = 'none';
    	    }
	}

	// 3. FONCTION POUR AFFICHER LES DÃ‰TAILS D'UN JOUEUR GPR
	function showGPRPlayerDetails(playerId, selectedYear) {
    	    var gprScores = scores.filter(s => {
        	return s.type === 'gpr' && s.playerId === playerId && (!selectedYear || s.year == selectedYear);
    	    });
    
    	    if (gprScores.length === 0) {
        	alert('Aucune partie GPR trouvÃ©e pour ce joueur.');
        	return;
    	    }
    
    	    var player = players.find(p => p.id === playerId);
    	    var playerName = player ? (player.name || (player.firstName + ' ' + player.lastName)) : 'Joueur #' + playerId;
    
    	    var pointsScale = [120, 105, 90, 78, 70, 62, 54, 46, 38, 30, 22, 15];
    	    var grossPointsScale = [80, 68, 60, 52, 45, 40, 35, 30, 25, 20, 15, 10];
    
    	    var html = '<div style="position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.5); z-index: 1000; display: flex; justify-content: center; align-items: center;">' +
               	       '<div style="background: white; padding: 30px; border-radius: 10px; box-shadow: 0 4px 20px rgba(0,0,0,0.3); max-width: 800px; width: 90%; max-height: 80%; overflow-y: auto;">' +
               	       '<h3 style="margin-top: 0; color: #2c5530;">ğŸ“Š DÃ©tails GPR - ' + playerName + '</h3>' +
               
               	       '<table class="table">' +
               	       '<thead><tr><th>Date</th><th>Terrain</th><th>Score Brut</th><th>Pos. Brut</th><th>Pts Brut</th><th>Score Net</th><th>Pos. Net</th><th>Pts Net</th><th>Total Pts</th></tr></thead>' +
               	       '<tbody>';
    
    	    var totalPoints = 0;
    
    	    // Trier par date
    	    gprScores.sort((a, b) => new Date(a.roundId) - new Date(b.roundId));
    
    	    for (var i = 0; i < gprScores.length; i++) {
        	var score = gprScores[i];
        	var round = rounds.find(r => r.id === score.roundId);
        
        	if (!round) continue;
        
        	// Trouver tous les scores de cette partie pour calculer les positions
        	var roundScores = scores.filter(s => s.roundId === score.roundId);
        
        	// Position brute
        	var grossRanking = [...roundScores].sort((a, b) => a.score - b.score);
        	var grossPosition = grossRanking.findIndex(s => s.playerId === playerId) + 1;
        	var grossPoints = grossPointsScale[Math.min(grossPosition - 1, grossPointsScale.length - 1)];
        
        	// Position nette
        	var netRanking = [...roundScores].sort((a, b) => a.net - b.net);
        	var netPosition = netRanking.findIndex(s => s.playerId === playerId) + 1;
        	var netPoints = pointsScale[Math.min(netPosition - 1, pointsScale.length - 1)];
        
        	var roundTotal = grossPoints + netPoints;
        	totalPoints += roundTotal;
        
        	html += '<tr>' +
                	'<td>' + round.date.split('-').reverse().join('/') + '</td>' +
                	'<td><small>' + round.course + '</small></td>' +
                	'<td><strong>' + score.score + '</strong></td>' +
                	'<td>' + grossPosition + '</td>' +
                	'<td><span style="background: #17a2b8; color: white; padding: 1px 5px; border-radius: 8px; font-size: 12px;">' + grossPoints + '</span></td>' +
                	'<td><strong>' + score.net.toFixed(1) + '</strong></td>' +
                	'<td>' + netPosition + '</td>' +
                	'<td><span style="background: #28a745; color: white; padding: 1px 5px; border-radius: 8px; font-size: 12px;">' + netPoints + '</span></td>' +
                	'<td><strong>' + roundTotal + '</strong></td>' +
                	'</tr>';
    	    }
    
    	    html += '</tbody></table>' +
            
            	    '<div style="margin-top: 20px; padding: 15px; background: #f8f9fa; border-radius: 8px; text-align: center;">' +
            	    '<strong>RÃ©sumÃ©:</strong> ' + gprScores.length + ' parties GPR | ' +
            	    '<strong>Total: ' + totalPoints + ' points</strong> | ' +
            	    '<strong>Moyenne: ' + (totalPoints / gprScores.length).toFixed(1) + ' pts/partie</strong>' +
            	    '</div>' +
            
            	    '<div style="margin-top: 25px; text-align: center;">' +
            	    '<button onclick="closeGPRPlayerDetails()" style="background: #6c757d; color: white; border: none; padding: 10px 20px; border-radius: 5px; cursor: pointer;">âŒ Fermer</button>' +
            	    '</div>' +
            
            	    '</div></div>';
    
    	    // Ajouter la popup au body
    	    var popup = document.createElement('div');
    	    popup.id = 'gprPlayerDetailsPopup';
    	    popup.innerHTML = html;
    	    document.body.appendChild(popup);
	}

	// 4. FONCTION POUR FERMER LA POPUP DES DÃ‰TAILS
	function closeGPRPlayerDetails() {
    	    var popup = document.getElementById('gprPlayerDetailsPopup');
    	    if (popup) {
        	popup.remove();
    	    }
	}
    
	function showGPRTab(tabName) {
    	// Fonction vide - plus nÃ©cessaire
    	return;
	}

	// Fonction pour afficher les dÃ©tails des 4 meilleures parties
	function showGPRBest4Details(playerId, selectedYear) {
    	var yearToCheck = selectedYear || new Date().getFullYear();
    	var best4Results = calculateBest4Exhibition(playerId, yearToCheck);
    
    	if (best4Results.length === 0) {
        	alert('Aucune partie exhibition trouvÃ©e pour ce joueur.');
        	return;
    	}
    
    	var player = players.find(p => p.id === playerId);
    	var playerName = player ? (player.name || (player.firstName + ' ' + player.lastName)) : 'Joueur #' + playerId;
    
    	var html = '<div style="position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.5); z-index: 1000; display: flex; justify-content: center; align-items: center;">' +
        	       '<div style="background: white; padding: 30px; border-radius: 10px; box-shadow: 0 4px 20px rgba(0,0,0,0.3); max-width: 900px; width: 90%; max-height: 80%; overflow-y: auto;">' +
            	   '<h3 style="margin-top: 0; color: #2c5530;">ğŸ† SÃ©lection des 4 Meilleures Parties - ' + playerName + '</h3>' +
               
            	   '<div style="background: #e7f3ff; padding: 15px; border-radius: 8px; margin-bottom: 20px;">' +
            	   '<strong>RÃ¨gle:</strong> Les 4 parties avec le plus de points totaux (brut + net) sont automatiquement sÃ©lectionnÃ©es. ' +
            	   'Si moins de 5 parties jouÃ©es, toutes les parties comptent.' +
            	   '</div>' +
               
            	   '<table class="table">' +
            	   '<thead><tr><th>ğŸ†</th><th>Date</th><th>Terrain</th><th>Score Brut</th><th>Pos. Brut</th><th>Pts Brut</th><th>Score Net</th><th>Pos. Net</th><th>Pts Net</th><th>Total Pts</th></tr></thead>' +
            	   '<tbody>';
    
    	var totalPoints = 0;
    
    	for (var i = 0; i < best4Results.length; i++) {
        	var result = best4Results[i];
        	var round = rounds.find(r => r.id === result.roundId);
        
        	totalPoints += result.totalPoints;
        
        	html += '<tr style="background: #f8fff8;">' +
            	    '<td style="text-align: center;"><span style="color: #28a745; font-size: 16px;">âœ…</span></td>' +
            	    '<td>' + round.date.split('-').reverse().join('/') + '</td>' +
            	    '<td><small>' + round.course + '</small></td>' +
            	    '<td><strong>' + result.score.score + '</strong></td>' +
            	    '<td>' + result.brutPos + '</td>' +
            	    '<td><span style="background: #17a2b8; color: white; padding: 1px 5px; border-radius: 8px; font-size: 12px;">' + result.brutPoints + '</span></td>' +
            	    '<td><strong>' + result.score.net.toFixed(1) + '</strong></td>' +
           		    '<td>' + result.netPos + '</td>' +
            	    '<td><span style="background: #28a745; color: white; padding: 1px 5px; border-radius: 8px; font-size: 12px;">' + result.netPoints + '</span></td>' +
            	    '<td><strong style="color: #2c5530;">' + result.totalPoints + '</strong></td>' +
            	    '</tr>';
    	}
    
    	html += '</tbody></table>' +
		
        	    '<div style="margin-top: 20px; padding: 15px; background: #f8f9fa; border-radius: 8px; text-align: center;">' +
            	'<strong>RÃ©sumÃ©:</strong> ' + best4Results.length + ' partie(s) sÃ©lectionnÃ©e(s) | ' +
            	'<strong>Total Exhibition: ' + totalPoints + ' points</strong>';
    
    	// Ajouter les points de finale s'ils existent
    	var finalePoints = 0;
    	var finaleRounds = rounds.filter(r => r.type === 'gpr' && r.gprPhase === 'finale' && r.year === yearToCheck);
    
    	if (finaleRounds.length > 0) {
        	var finaleResults = calculateFinaleScores(yearToCheck);
        	if (finaleResults[playerId]) {
            	finalePoints = (finaleResults[playerId].pointsBrut || 0) + (finaleResults[playerId].pointsNet || 0);
            	html += ' | <strong>Points Finale: ' + finalePoints + '</strong>';
        	}
    	}
    
    	html += ' | <strong style="color: #e74c3c;">TOTAL OFFICIEL: ' + (totalPoints + finalePoints) + ' points</strong>' +
        	    '</div>' +
            
            	'<div style="margin-top: 25px; text-align: center;">' +
            	'<button onclick="closeGPRBest4Details()" style="background: #6c757d; color: white; border: none; padding: 10px 20px; border-radius: 5px; cursor: pointer;">âŒ Fermer</button>' +
            	'</div>' +
            
            	'</div></div>';
    
    	// Ajouter la popup au body
    	var popup = document.createElement('div');
    	popup.id = 'gprBest4DetailsPopup';
    	popup.innerHTML = html;
    	document.body.appendChild(popup);
	}

	// Fonction pour fermer la popup des dÃ©tails best4
	function closeGPRBest4Details() {
    	var popup = document.getElementById('gprBest4DetailsPopup');
    	if (popup) {
        	popup.remove();
    	}
	}

	// Fonctions utilitaires
        function loadYearSelectors() {
            var years = [];
            for (var i = 0; i < rounds.length; i++) {
                if (years.indexOf(rounds[i].year) === -1) {
                    years.push(rounds[i].year);
                }
            }
            years.sort();

            var diabloSelect = document.getElementById('diabloYearSelect');
            var gprSelect = document.getElementById('gprYearSelect');
            
            var currentDiabloYear = diabloSelect.value;
            var currentGprYear = gprSelect.value;
            
            diabloSelect.innerHTML = '<option value="">-- Toutes les annÃ©es --</option>';
            gprSelect.innerHTML = '<option value="">-- Toutes les annÃ©es --</option>';
            
            for (var i = 0; i < years.length; i++) {
                var year = years[i];
                
                var diabloOption = document.createElement('option');
                diabloOption.value = year;
                diabloOption.textContent = year;
                if (year == currentDiabloYear) diabloOption.selected = true;
                diabloSelect.appendChild(diabloOption);
                
                var gprOption = document.createElement('option');
                gprOption.value = year;
                gprOption.textContent = year;
                if (year == currentGprYear) gprOption.selected = true;
                gprSelect.appendChild(gprOption);
            }
        }

        function updateDiabloStatus(selectedYear) {
            var statusElement = document.getElementById('diabloStatus');
            var currentDate = new Date();
            var currentYear = currentDate.getFullYear();
            var currentMonth = currentDate.getMonth() + 1;
            
            if (!selectedYear || selectedYear == currentYear) {
                if (currentMonth >= 9) {
                    statusElement.innerHTML = 'ğŸ”´ En cours';
                    statusElement.style.background = '#28a745';
                    statusElement.style.color = 'white';
                } else {
                    statusElement.innerHTML = 'â³ Ã€ venir (Septembre)';
                    statusElement.style.background = '#ffc107';
                    statusElement.style.color = 'black';
                }
            } else if (selectedYear < currentYear) {
                statusElement.innerHTML = 'âœ… TerminÃ©e';
                statusElement.style.background = '#6c757d';
                statusElement.style.color = 'white';
            } else {
                statusElement.innerHTML = 'ğŸ“… Future';
                statusElement.style.background = '#17a2b8';
                statusElement.style.color = 'white';
            }
        }

        function updateGPRStatus(selectedYear) {
            var statusElement = document.getElementById('gprStatus');
            var currentDate = new Date();
            var currentYear = currentDate.getFullYear();
            var currentMonth = currentDate.getMonth() + 1;
            
            if (!selectedYear || selectedYear == currentYear) {
                if (currentMonth >= 5 && currentMonth <= 7) {
                    statusElement.innerHTML = 'ğŸ”´ En cours';
                    statusElement.style.background = '#28a745';
                    statusElement.style.color = 'white';
                } else if (currentMonth < 5) {
                    statusElement.innerHTML = 'â³ Ã€ venir (Mai-Juillet)';
                    statusElement.style.background = '#ffc107';
                    statusElement.style.color = 'black';
                } else {
                    statusElement.innerHTML = 'âœ… TerminÃ©e';
                    statusElement.style.background = '#6c757d';
                    statusElement.style.color = 'white';
                }
            } else if (selectedYear < currentYear) {
                statusElement.innerHTML = 'âœ… TerminÃ©e';
                statusElement.style.background = '#6c757d';
                statusElement.style.color = 'white';
            } else {
                statusElement.innerHTML = 'ğŸ“… Future';
                statusElement.style.background = '#17a2b8';
                statusElement.style.color = 'white';
            }
        }

        function getUniquePlayersCount(scoresList) {
            var playerIds = [];
            for (var i = 0; i < scoresList.length; i++) {
                if (playerIds.indexOf(scoresList[i].playerId) === -1) {
                    playerIds.push(scoresList[i].playerId);
                }
            }
            return playerIds.length;
        }

        function loadProgress() {
            var currentDate = new Date();
            var currentYear = currentDate.getFullYear();
            var currentMonth = currentDate.getMonth() + 1;
            
            var html = '<div class="card">' +
                       '<h3>Ã‰tat des Coupes ' + currentYear + '</h3>' +
                       '</div>';
            
            // Progression GPR
            var gprRounds = rounds.filter(r => r.type === 'gpr' && r.year === currentYear);
            var gprScores = scores.filter(s => s.type === 'gpr' && s.year === currentYear);
            
            html += '<div class="card">' +
                    '<h4>ğŸ¯ Coupe GPR ' + currentYear + ' (Mai - Juillet)</h4>';
            
            if (currentMonth >= 5 && currentMonth <= 7) {
                html += '<p style="color: #28a745;"><strong>ğŸ”´ EN COURS</strong></p>';
            } else if (currentMonth < 5) {
                html += '<p style="color: #ffc107;"><strong>â³ Ã€ VENIR</strong></p>';
            } else {
                html += '<p style="color: #6c757d;"><strong>âœ… TERMINÃ‰E</strong></p>';
            }
            
            html += '<p><strong>Parties jouÃ©es:</strong> ' + gprRounds.length + '</p>' +
                    '<p><strong>Participants:</strong> ' + getUniquePlayersCount(gprScores) + '</p>';
            
            if (gprScores.length > 0) {
                var gprLeader = getGPRLeader(gprRounds, gprScores);
                html += '<p><strong>Leader actuel:</strong> ' + gprLeader + '</p>';
            }
            
            html += '</div>';
            
            // Progression Diablo
            var diabloRounds = rounds.filter(r => r.type === 'diablo' && r.year === currentYear);
            var diabloScores = scores.filter(s => s.type === 'diablo' && s.year === currentYear);
            
            html += '<div class="card">' +
                    '<h4>ğŸ† Coupe Diablo ' + currentYear + ' (Septembre)</h4>';
            
            if (currentMonth >= 9) {
                html += '<p style="color: #28a745;"><strong>ğŸ”´ EN COURS</strong></p>';
            } else {
                html += '<p style="color: #ffc107;"><strong>â³ Ã€ VENIR</strong></p>';
            }
            
            html += '<p><strong>Parties jouÃ©es:</strong> ' + diabloRounds.length + '</p>' +
                    '<p><strong>Participants:</strong> ' + getUniquePlayersCount(diabloScores) + '</p>';
            
            if (diabloScores.length > 0) {
                var diabloLeader = getDiabloLeader(diabloScores);
                html += '<p><strong>Leader actuel:</strong> ' + diabloLeader + '</p>';
            }
            
            html += '</div>';
            
            document.getElementById('progressContent').innerHTML = html;
        }

        function getGPRLeader(gprRounds, gprScores) {
    		var tempPlayerPoints = {};  // Utiliser une variable locale
    		var pointsScale = [120, 105, 90, 78, 70, 62, 54, 46, 38, 30, 22, 15];
    		var grossPointsScale = [80, 68, 60, 52, 45, 40, 35, 30, 25, 20, 15, 10];

    		for (var i = 0; i < gprRounds.length; i++) {
        		var round = gprRounds[i];
        		var roundScores = gprScores.filter(s => s.roundId === round.id);
        
        		roundScores.sort((a, b) => a.net - b.net);
        
        		for (var k = 0; k < roundScores.length; k++) {
            		var score = roundScores[k];
            		if (!tempPlayerPoints[score.playerId]) {
                		var player = players.find(p => p.id === score.playerId);
                		var playerName = player ? (player.name || (player.firstName + ' ' + player.lastName)) : ('Joueur #' + score.playerId);
                
                		tempPlayerPoints[score.playerId] = {
                    		playerName: playerName,
                    		totalPoints: 0
                		};
            		}
            
            		var netPoints = pointsScale[Math.min(k, pointsScale.length - 1)];
            		var grossPoints = grossPointsScale[Math.min(k, grossPointsScale.length - 1)];
            
            		tempPlayerPoints[score.playerId].totalPoints += netPoints + grossPoints;
        		}
    		}

    		var maxPoints = 0;
    		var leader = 'Aucun';
    		for (var playerId in tempPlayerPoints) {
        		if (tempPlayerPoints[playerId].totalPoints > maxPoints) {
            		maxPoints = tempPlayerPoints[playerId].totalPoints;
            		leader = tempPlayerPoints[playerId].playerName + ' (' + maxPoints + ' pts)';
        		}
    		}
    
    		return leader;
		}

	function getDiabloLeader(diabloScores) {
    	    var playerStats = {};
    
    	    for (var i = 0; i < diabloScores.length; i++) {
        	var score = diabloScores[i];
        	if (!playerStats[score.playerId]) {
            	    // CORRECTION : MÃªme logique que dans l'overview
            	    var player = players.find(p => p.id === score.playerId);
            	    var playerName = player ? (player.name || (player.firstName + ' ' + player.lastName)) : ('Joueur #' + score.playerId);
            
            	    playerStats[score.playerId] = {
                	playerName: playerName,  // UTILISER le nom calculÃ©
                	totalNet: 0,
                	rounds: 0
            	    };
        	}
        	playerStats[score.playerId].totalNet += score.net;
        	playerStats[score.playerId].rounds++;
    	    }

    	    var bestAvg = 999;
    	    var leader = 'Aucun';
    	    for (var playerId in playerStats) {
        	var avg = playerStats[playerId].totalNet / playerStats[playerId].rounds;
        	if (avg < bestAvg) {
            	    bestAvg = avg;
            	    leader = playerStats[playerId].playerName + ' (' + avg.toFixed(1) + ' net)';  // UTILISER playerName
        	}
    	    }
    
    	    return leader;
	}

        function loadDetails() {
            var select = document.getElementById('roundSelect');
            select.innerHTML = '<option value="">-- SÃ©lectionner une partie --</option>';
            
            for (var i = 0; i < rounds.length; i++) {
                var round = rounds[i];
                var icon = round.type === 'diablo' ? 'ğŸ†' : 'ğŸ¯';
                var date = round.date.split('-').reverse().join('/');
                
                var option = document.createElement('option');
                option.value = round.id;
                option.textContent = icon + ' ' + date + ' - ' + round.course;
                select.appendChild(option);
            }
        }

        function showRoundDetail() {
            var roundId = parseInt(document.getElementById('roundSelect').value);
            if (!roundId) {
                document.getElementById('detailsContent').innerHTML = '';
                return;
            }

            var round = rounds.find(r => r.id === roundId);
            var roundScores = scores.filter(s => s.roundId === roundId);

            if (!round || roundScores.length === 0) {
                document.getElementById('detailsContent').innerHTML = '<p>Aucun score pour cette partie.</p>';
                return;
            }

            console.log('DEBUG: round =', round);
            console.log('DEBUG: roundScores =', roundScores);
            console.log('DEBUG: round.type =', round.type);

            var html = '<div class="card">' +
                       '<h3>' + round.date.split('-').reverse().join('/') + ' - ' + round.course + '</h3>' +
                       '<p><strong>Type:</strong> ' + (round.type === 'diablo' ? 'ğŸ† Coupe Diablo' : 'ğŸ¯ Coupe GPR') + '</p>' +
                       '<p><strong>DÃ©part:</strong> ' + (round.tee === 'bleu' ? 'ğŸ”µ Bleu' : 'âšª Blanc') + ' (Antonio: ' + (teeUsed[round.id-1] === 'bleu' ? 'ğŸ”µ Bleu' : 'âšª Blanc') + ', Autres: âšª Blanc)</p>' +
                       '<div style="margin: 15px 0; text-align: center; background: #f8f9fa; padding: 15px; border-radius: 8px;">' +
					   '<h4 style="margin: 0 0 10px 0; color: #2c5530;">âš™ï¸ Actions sur cette partie</h4>' +
					   '<button class="btn-secondary" onclick="editRound(' + round.id + ')" style="margin: 5px;">âœï¸ Modifier Scores</button>' +
					   '<button class="btn-danger" onclick="deleteRound(' + round.id + ')" style="margin: 5px;">ğŸ—‘ï¸ Supprimer Partie</button>' +
					   '<button class="btn" onclick="duplicateRound(' + round.id + ')" style="margin: 5px;">ğŸ“‹ Dupliquer Partie</button>' +
					   '</div>' +
					   '</div>';

            if (round.type === 'diablo') {
                console.log('DEBUG: GÃ©nÃ©ration dÃ©tails Diablo');
                html += generateDiabloRoundDetail(round, roundScores);
            } else {
                console.log('DEBUG: GÃ©nÃ©ration dÃ©tails GPR');
                html += generateGPRRoundDetail(round, roundScores);
            }

            console.log('DEBUG: HTML final =', html);
            document.getElementById('detailsContent').innerHTML = html;
        }

        // GÃ©nÃ©rer les dÃ©tails pour une partie Diablo
        function generateDiabloRoundDetail(round, roundScores) {
            var html = '';
            
            // Classement de la partie
            roundScores.sort((a, b) => a.net - b.net);
            
            html += '<div class="card">' +
                    '<h4>ğŸ† Classement de la Partie</h4>' +
                    '<table class="table">' +
                    '<thead><tr><th>Position</th><th>Joueur</th><th>Score Brut</th><th>Score Net</th><th>DiffÃ©rentiel</th></tr></thead>' +
                    '<tbody>';

            for (var i = 0; i < roundScores.length; i++) {
                var score = roundScores[i];
                var rowStyle = '';
                if (i === 0) rowStyle = ' style="background: gold;"';
                else if (i === 1) rowStyle = ' style="background: silver;"';
                else if (i === 2) rowStyle = ' style="background: #cd7f32;"';
                
                // Calculer le diffÃ©rentiel
                var differential = calculateScoreDifferentialReal(score.score, round.course, score.tee);
                
                html += '<tr' + rowStyle + '>' +
                        '<td><strong>' + (i + 1) + '</strong></td>' +
                        '<td><strong>' + score.playerName + '</strong></td>' +
                        '<td>' + score.score + '</td>' +
                        '<td><strong>' + score.net.toFixed(1) + '</strong></td>' +
                        '<td>' + (differential ? differential.toFixed(1) : 'N/A') + '</td>' +
                        '</tr>';
            }

            html += '</tbody></table></div>';
            
            // Pointage global du tournoi Diablo pour cette annÃ©e
            html += generateDiabloTournamentStandings(round.year);
            
            return html;
        }

        // GÃ©nÃ©rer les dÃ©tails pour une partie GPR
        function generateGPRRoundDetail(round, roundScores) {
            var html = '';
            
            // Points scale
            var brutPointsScale = [80, 68, 60, 52, 45, 40, 35, 30, 25, 20, 15, 10];
            var netPointsScale = [120, 105, 90, 78, 70, 62, 54, 46, 38, 30, 22, 15];
            
            // Exclure Ã‰ric Gosselin (ID 12) des classements GPR
            var gprScores = roundScores.filter(s => s.playerId !== 13);
            
            // 1. Classement Brut avec pointage
            var brutRanking = [...gprScores].sort((a, b) => a.score - b.score);
            
            html += '<div class="card">' +
                    '<h4>ğŸŒï¸ Classement Score Brut</h4>' +
                    '<table class="table">' +
                    '<thead><tr><th>Position</th><th>Joueur</th><th>Score Brut</th><th>Points</th></tr></thead>' +
                    '<tbody>';

            for (var i = 0; i < brutRanking.length; i++) {
                var score = brutRanking[i];
                var points = brutPointsScale[Math.min(i, brutPointsScale.length - 1)];
                var rowStyle = '';
                if (i === 0) rowStyle = ' style="background: gold;"';
                else if (i === 1) rowStyle = ' style="background: silver;"';
                else if (i === 2) rowStyle = ' style="background: #cd7f32;"';
                
                html += '<tr' + rowStyle + '>' +
                        '<td><strong>' + (i + 1) + '</strong></td>' +
                        '<td><strong>' + score.playerName + '</strong></td>' +
                        '<td>' + score.score + '</td>' +
                        '<td><span style="background: #17a2b8; color: white; padding: 2px 8px; border-radius: 10px;">' + points + '</span></td>' +
                        '</tr>';
            }

            html += '</tbody></table></div>';
            
            // 2. Classement Net avec pointage
            var netRanking = [...gprScores].sort((a, b) => a.net - b.net);
            
            html += '<div class="card">' +
                    '<h4>ğŸ¯ Classement Score Net</h4>' +
                    '<table class="table">' +
                    '<thead><tr><th>Position</th><th>Joueur</th><th>Score Net</th><th>Points</th></tr></thead>' +
                    '<tbody>';

            for (var i = 0; i < netRanking.length; i++) {
                var score = netRanking[i];
                var points = netPointsScale[Math.min(i, netPointsScale.length - 1)];
                var rowStyle = '';
                if (i === 0) rowStyle = ' style="background: gold;"';
                else if (i === 1) rowStyle = ' style="background: silver;"';
                else if (i === 2) rowStyle = ' style="background: #cd7f32;"';
                
                html += '<tr' + rowStyle + '>' +
                        '<td><strong>' + (i + 1) + '</strong></td>' +
                        '<td><strong>' + score.playerName + '</strong></td>' +
                        '<td><strong>' + score.net.toFixed(1) + '</strong></td>' +
                        '<td><span style="background: #28a745; color: white; padding: 2px 8px; border-radius: 10px;">' + points + '</span></td>' +
                        '</tr>';
            }

            html += '</tbody></table></div>';
            
            // 3. Points totaux pour cette partie
            var roundTotals = [];
            
            for (var i = 0; i < gprScores.length; i++) {
                var score = gprScores[i];
                var brutPos = brutRanking.findIndex(s => s.playerId === score.playerId) + 1;
                var netPos = netRanking.findIndex(s => s.playerId === score.playerId) + 1;
                var brutPoints = brutPointsScale[Math.min(brutPos - 1, brutPointsScale.length - 1)];
                var netPoints = netPointsScale[Math.min(netPos - 1, netPointsScale.length - 1)];
                var totalPoints = brutPoints + netPoints;
                
                roundTotals.push({
                    player: score,
                    brutPoints: brutPoints,
                    netPoints: netPoints,
                    totalPoints: totalPoints
                });
            }
            
            roundTotals.sort((a, b) => b.totalPoints - a.totalPoints);
            
            html += '<div class="card">' +
                    '<h4>ğŸ† Points Totaux de la Partie</h4>' +
                    '<table class="table">' +
                    '<thead><tr><th>Position</th><th>Joueur</th><th>Points Brut</th><th>Points Net</th><th>Total</th></tr></thead>' +
                    '<tbody>';

            for (var i = 0; i < roundTotals.length; i++) {
                var total = roundTotals[i];
                var rowStyle = '';
                if (i === 0) rowStyle = ' style="background: gold;"';
                else if (i === 1) rowStyle = ' style="background: silver;"';
                else if (i === 2) rowStyle = ' style="background: #cd7f32;"';
                
                html += '<tr' + rowStyle + '>' +
                        '<td><strong>' + (i + 1) + '</strong></td>' +
                        '<td><strong>' + total.player.playerName + '</strong></td>' +
                        '<td>' + total.brutPoints + '</td>' +
                        '<td>' + total.netPoints + '</td>' +
                        '<td><strong>' + total.totalPoints + '</strong></td>' +
                        '</tr>';
            }

            html += '</tbody></table></div>';
            
            // 4. Pointage global du tournoi GPR pour cette annÃ©e
            html += generateGPRTournamentStandings(round.year);
            
            return html;
        }

        // GÃ©nÃ©rer le classement global Diablo pour une annÃ©e
        function generateDiabloTournamentStandings(year) {
            var diabloScores = scores.filter(s => s.type === 'diablo' && s.year === year);
            
            if (diabloScores.length === 0) {
                return '<div class="card"><h4>ğŸ† Classement Global Diablo ' + year + '</h4><p>Aucune partie Diablo pour cette annÃ©e.</p></div>';
            }
            
            var playerStats = {};
            
            for (var i = 0; i < diabloScores.length; i++) {
                var score = diabloScores[i];
                if (!playerStats[score.playerId]) {
                    playerStats[score.playerId] = {
                        playerName: score.playerName,
                        totalNet: 0,
                        rounds: 0
                    };
                }
                playerStats[score.playerId].totalNet += score.net;
                playerStats[score.playerId].rounds++;
            }
            
            var leaderboard = [];
            for (var playerId in playerStats) {
                var stats = playerStats[playerId];
                leaderboard.push({
                    playerName: stats.playerName,
                    rounds: stats.rounds,
                    avgNet: stats.totalNet / stats.rounds
                });
            }
            
            leaderboard.sort((a, b) => a.avgNet - b.avgNet);
            
            var html = '<div class="card">' +
                       '<h4>ğŸ† Classement Global Diablo ' + year + '</h4>' +
                       '<table class="table">' +
                       '<thead><tr><th>Position</th><th>Joueur</th><th>Parties</th><th>Score Net Moyen</th></tr></thead>' +
                       '<tbody>';
            
            for (var i = 0; i < leaderboard.length; i++) {
                var stats = leaderboard[i];
                var rowStyle = '';
                if (i === 0) rowStyle = ' style="background: gold;"';
                else if (i === 1) rowStyle = ' style="background: silver;"';
                else if (i === 2) rowStyle = ' style="background: #cd7f32;"';
                
                html += '<tr' + rowStyle + '>' +
                        '<td><strong>' + (i + 1) + '</strong></td>' +
                        '<td><strong>' + stats.playerName + '</strong></td>' +
                        '<td>' + stats.rounds + '</td>' +
                        '<td><strong>' + stats.avgNet.toFixed(1) + '</strong></td>' +
                        '</tr>';
            }
            
            html += '</tbody></table></div>';
            
            return html;
        }

        // GÃ©nÃ©rer le classement global GPR pour une annÃ©e
        function generateGPRTournamentStandings(year) {
            var gprScores = scores.filter(s => s.type === 'gpr' && s.year === year && s.playerId !== 13); // Exclure Gosselin
            
            if (gprScores.length === 0) {
                return '<div class="card"><h4>ğŸ¯ Classement Global GPR ' + year + '</h4><p>Aucune partie GPR pour cette annÃ©e.</p></div>';
            }
            
            var gprRounds = rounds.filter(r => r.type === 'gpr' && r.year === year);
            var playerPoints = {};
            var brutPointsScale = [80, 68, 60, 52, 45, 40, 35, 30, 25, 20, 15, 10];
            var netPointsScale = [120, 105, 90, 78, 70, 62, 54, 46, 38, 30, 22, 15];
            
            for (var i = 0; i < gprRounds.length; i++) {
                var round = gprRounds[i];
                var roundScores = gprScores.filter(s => s.roundId === round.id);
                
                // Classement brut pour cette partie
                var brutRanking = [...roundScores].sort((a, b) => a.score - b.score);
                // Classement net pour cette partie
                var netRanking = [...roundScores].sort((a, b) => a.net - b.net);
                
                for (var j = 0; j < roundScores.length; j++) {
                    var score = roundScores[j];
                    if (!playerPoints[score.playerId]) {
                        playerPoints[score.playerId] = {
                            playerName: score.playerName,
                            totalPoints: 0,
                            rounds: 0
                        };
                    }
                    
                    var brutPos = brutRanking.findIndex(s => s.playerId === score.playerId) + 1;
                    var netPos = netRanking.findIndex(s => s.playerId === score.playerId) + 1;
                    var brutPoints = brutPointsScale[Math.min(brutPos - 1, brutPointsScale.length - 1)];
                    var netPoints = netPointsScale[Math.min(netPos - 1, netPointsScale.length - 1)];
                    
                    playerPoints[score.playerId].totalPoints += brutPoints + netPoints;
                    playerPoints[score.playerId].rounds++;
                }
            }
            
            var leaderboard = [];
            for (var playerId in playerPoints) {
                var stats = playerPoints[playerId];
                leaderboard.push({
                    playerName: stats.playerName,
                    rounds: stats.rounds,
                    totalPoints: stats.totalPoints
                });
            }
            
            leaderboard.sort((a, b) => b.totalPoints - a.totalPoints);
            
            var html = '<div class="card">' +
                       '<h4>ğŸ¯ Classement Global GPR ' + year + '</h4>' +
                       '<table class="table">' +
                       '<thead><tr><th>Position</th><th>Joueur</th><th>Parties</th><th>Points Totaux</th></tr></thead>' +
                       '<tbody>';
            
            for (var i = 0; i < leaderboard.length; i++) {
                var stats = leaderboard[i];
                var rowStyle = '';
                if (i === 0) rowStyle = ' style="background: gold;"';
                else if (i === 1) rowStyle = ' style="background: silver;"';
                else if (i === 2) rowStyle = ' style="background: #cd7f32;"';
                
                html += '<tr' + rowStyle + '>' +
                        '<td><strong>' + (i + 1) + '</strong></td>' +
                        '<td><strong>' + stats.playerName + '</strong></td>' +
                        '<td>' + stats.rounds + '</td>' +
                        '<td><strong>' + stats.totalPoints + '</strong></td>' +
                        '</tr>';
            }
            
            html += '</tbody></table></div>';
            
            return html;
        }

	// Variables globales pour le graphique
	var selectedPlayers = [];
	var handicapEvolutionData = {};

	// Fonction pour afficher la section Ã©volution des handicaps
	function showHandicapEvolution() {
    	    hideAllSections();
    	    document.getElementById('handicapEvolution').style.display = 'block';
    	    setActiveButton(6); // Ajustez l'index selon votre navigation
    	    loadHandicapEvolution();
	}

	// Charger l'interface d'Ã©volution des handicaps
	function loadHandicapEvolution() {
    	    // PrÃ©parer les donnÃ©es d'Ã©volution pour tous les joueurs
    	    prepareHandicapEvolutionData();
    
    	    // CrÃ©er les checkboxes pour sÃ©lectionner les joueurs
    	    createPlayerCheckboxes();
    
    	    // SÃ©lectionner automatiquement les 3 premiers joueurs
    	    selectDefaultPlayers();
    
    	    // Afficher le graphique initial
    	    updateHandicapChart();
    
    	    // CORRECTION : Toujours afficher les statistiques, mÃªme sans sÃ©lection
    	    displayHandicapStats();
	}

	// PrÃ©parer les donnÃ©es d'Ã©volution des handicaps
	function prepareHandicapEvolutionData() {
    	    console.log("ğŸ”„ PrÃ©paration des donnÃ©es d'Ã©volution avec calculs rÃ©els...");
    
    	    handicapEvolutionData = {};
    
    	    // Vider le cache pour Ã©viter les conflits
    	    if (typeof handicapCache !== 'undefined') {
        	handicapCache = {};
    	    }
    
    	    for (var i = 0; i < players.length; i++) {
        	var player = players[i];
        	var evolution = [];
        	var playerName = player.name || (player.firstName + ' ' + player.lastName);
        
        	console.log("Calcul pour:", playerName);
        
        	// Handicap de dÃ©part (avant toute partie)
        	var currentHandicap = player.handicap;
        
        	// Point de dÃ©part
        	evolution.push({
            	    date: dates[0] || '2023-01-01',
            	    handicap: currentHandicap,
            	    gameNumber: 0,
            	    change: 0
        	});
        
        	// CORRECTION : Calculer l'Ã©volution RÃ‰ELLE aprÃ¨s chaque partie
        	var scoresCount = 0;
        	var allDifferentials = [];
        
        	for (var j = 0; j < dates.length; j++) {
            	    if (allScores[i][j] > 0) {
                	scoresCount++;
                	var grossScore = allScores[i][j];
                	var courseName = courses[j];
                	var teeForPlayer = (player.id === 1) ? teeUsed[j] : 'blanc';
                
                	// Calculer le diffÃ©rentiel pour ce score
                	var differential = calculateScoreDifferentialReal(grossScore, courseName, teeForPlayer);
                	if (differential > 0) {
                    	    allDifferentials.push(differential);
                	}
                
                	// Calculer le nouveau handicap basÃ© sur tous les scores jusqu'ici
                	var newHandicap = calculateNewHandicapFromDifferentials(allDifferentials, player.handicap);
                	var change = newHandicap - currentHandicap;
                
                	evolution.push({
                    	    date: dates[j],
                    	    handicap: newHandicap,
                    	    gameNumber: j + 1,
                    	    change: change,
                    	    score: grossScore,
                    	    course: courseName,
                    	    differential: differential,
                    	    totalDifferentials: allDifferentials.length
                	});
                
                	currentHandicap = newHandicap;
                
                	console.log(`  Partie ${j+1}: Score ${grossScore} â†’ Handicap ${newHandicap.toFixed(1)} (${change > 0 ? '+' : ''}${change.toFixed(1)})`);
            	    }
        	}
        
        	handicapEvolutionData[player.id] = {
            	    player: player,
            	    playerName: playerName,
            	    evolution: evolution
        	};
        
        	var finalChange = evolution.length > 1 ? evolution[evolution.length-1].handicap - evolution[0].handicap : 0;
        	console.log(`${playerName} - Changement total: ${finalChange > 0 ? '+' : ''}${finalChange.toFixed(1)}`);
    	    }
    
    	    console.log("âœ… DonnÃ©es d'Ã©volution prÃ©parÃ©es avec calculs rÃ©els!");
	}

	// 1. FONCTION DE DIAGNOSTIC POUR COMPRENDRE LE PROBLÃˆME
	function diagnoseHandicapProgression() {
    	    console.log("ğŸ” DIAGNOSTIC DE LA PROGRESSION DES HANDICAPS");
    	    console.log("=============================================");
    
    	    // Prendre Antonio comme exemple
    	    var antonio = players.find(p => p.id === 1);
    	    if (!antonio || !allScores[0]) {
        	console.log("âŒ Pas de donnÃ©es pour Antonio");
        	return;
    	    }
    
    	    console.log("Analyse pour Antonio Coccaro:");
    	    console.log("Handicap initial:", antonio.handicap);
    
    	    var progressiveDifferentials = [];
    
    	    for (var i = 0; i < Math.min(10, dates.length); i++) {
        	if (allScores[0][i] > 0) {
            	    var score = allScores[0][i];
            	    var course = courses[i];
            	    var tee = teeUsed[i]; // Antonio joue des bleus parfois
            
            	    // Calculer le diffÃ©rentiel pour ce score
            	    var diff = calculateScoreDifferentialReal(score, course, tee);
            	    if (diff > 0) {
                	progressiveDifferentials.push(diff);
                
                	// Calculer le handicap avec SEULEMENT les scores jusqu'ici
                	var handicapAtThisPoint = calculateNewHandicapFromDifferentials(progressiveDifferentials, antonio.handicap);
                
                	console.log(`Partie ${i+1} (${dates[i]}):`);
                	console.log(`  Score: ${score} au ${course} (${tee})`);
                	console.log(`  DiffÃ©rentiel: ${diff}`);
                	console.log(`  DiffÃ©rentiels accumulÃ©s: ${progressiveDifferentials.length}`);
                	console.log(`  Handicap calculÃ©: ${handicapAtThisPoint}`);
                	console.log(`  ---`);
            	    }
        	}
    	    }
    
    	    console.log("\nğŸ¯ Si les handicaps sont identiques, c'est que le calcul ne progresse pas correctement!");
	}

	// 2. FONCTION CORRIGÃ‰E POUR CALCULER L'Ã‰VOLUTION PROGRESSIVE
	function prepareHandicapEvolutionDataProgressive() {
    	    console.log("ğŸ”„ PrÃ©paration PROGRESSIVE des donnÃ©es d'Ã©volution...");
    
    	    handicapEvolutionData = {};
    
    	    for (var i = 0; i < players.length; i++) {
        	var player = players[i];
        	var evolution = [];
        	var playerName = player.name || (player.firstName + ' ' + player.lastName);
        
        	console.log(`\nCalcul progressif pour: ${playerName}`);
        
        	// Handicap de dÃ©part
        	var currentHandicap = player.handicap;
        
        	// Point de dÃ©part
        	evolution.push({
            	    date: dates[0] || '2023-01-01',
            	    handicap: currentHandicap,
            	    gameNumber: 0,
            	    change: 0,
            	    scoresUsed: 0,
            	    status: 'Initial'
        	});
        
        	// CORRECTION : Accumuler progressivement les diffÃ©rentiels
        	var progressiveDifferentials = [];
        	var gameNumber = 0;
        
        	for (var j = 0; j < dates.length; j++) {
            	    if (allScores[i][j] > 0) {
                	gameNumber++;
                	var grossScore = allScores[i][j];
                	var courseName = courses[j];
                	var teeForPlayer = (player.id === 1) ? teeUsed[j] : 'blanc';
                
                	// Calculer le diffÃ©rentiel pour cette partie
                	var differential = calculateScoreDifferentialReal(grossScore, courseName, teeForPlayer);
                
                	if (differential > 0) {
                    	    // AJOUTER ce diffÃ©rentiel Ã  la liste progressive
                    	    progressiveDifferentials.push({
                        	date: dates[j],
                        	differential: differential,
                        	score: grossScore,
                        	course: courseName
                    	    });
                    
                    	    // Calculer le nouveau handicap avec SEULEMENT les scores jusqu'Ã  cette date
                    	    var newHandicap;
                    
                    	    if (progressiveDifferentials.length < 5) {
                        	// Pas assez de scores, garder le handicap prÃ©cÃ©dent
                        	newHandicap = currentHandicap;
                        	var status = `Pas assez de scores (${progressiveDifferentials.length}/5)`;
                    	    } else {
                        	// Calculer avec les diffÃ©rentiels disponibles jusqu'ici
                        	var diffValues = progressiveDifferentials.map(d => d.differential);
                        	newHandicap = calculateNewHandicapFromDifferentials(diffValues, player.handicap);
                        	var status = `CalculÃ© avec ${progressiveDifferentials.length} scores`;
                    	    }
                    
                    	    var change = newHandicap - currentHandicap;
                    
                    	    evolution.push({
                        	date: dates[j],
                        	handicap: newHandicap,
                        	gameNumber: gameNumber,
                        	change: change,
                        	score: grossScore,
                        	course: courseName,
                        	differential: differential,
                        	scoresUsed: progressiveDifferentials.length,
                        	status: status
                    	    });
                    
                    	    console.log(`  Partie ${gameNumber}: ${grossScore} â†’ H=${newHandicap.toFixed(1)} (${progressiveDifferentials.length} scores)`);
                    
                    	    currentHandicap = newHandicap;
                	}
            	    }
        	}
        
        	handicapEvolutionData[player.id] = {
            	    player: player,
            	    playerName: playerName,
            	    evolution: evolution
        	};
        
        	// RÃ©sumÃ© pour ce joueur
        	if (evolution.length > 1) {
            	    var initialH = evolution[0].handicap;
            	    var finalH = evolution[evolution.length - 1].handicap;
            	    // Trouver l'handicap Ã  la 6e partie JOUÃ‰E par ce joueur
					var initialHandicapForDisplay = evolution[0].handicap;
					var partiesJouees = 0;
					for (var k = 0; k < evolution.length; k++) {
    					// VÃ©rifier s'il a jouÃ© cette partie (a un score)
    					if (evolution[k].score && evolution[k].score > 0) {
        					partiesJouees++;
        					if (partiesJouees === 6) {
            					initialHandicapForDisplay = evolution[k].handicap;
            					break;
        					}
    					}
					}
					// Si le joueur n'a pas 6 parties, garder son handicap initial
					if (partiesJouees < 6) {
    					initialHandicapForDisplay = evolution[0].handicap;
					}
					var totalChange = finalH - initialHForDisplay;
            	    var totalGames = evolution[evolution.length - 1].gameNumber;
            
            	    console.log(`${playerName} RÃ‰SUMÃ‰: ${initialH.toFixed(1)} â†’ ${finalH.toFixed(1)} (${totalChange > 0 ? '+' : ''}${totalChange.toFixed(1)}) sur ${totalGames} parties`);
        	}
    	    }
    
    	    console.log("\nâœ… Ã‰volution PROGRESSIVE calculÃ©e!");
	}

	// 3. FONCTION POUR CALCULER AVEC VARIATION RÃ‰ALISTE (alternative)
	function prepareHandicapEvolutionWithRealisticVariation() {
    	    console.log("ğŸ­ PrÃ©paration avec variation rÃ©aliste...");
    
    	    handicapEvolutionData = {};
    
    	    for (var i = 0; i < players.length; i++) {
        	var player = players[i];
        	var evolution = [];
        	var playerName = player.name || (player.firstName + ' ' + player.lastName);
        
        	// Handicap de dÃ©part
        	var currentHandicap = player.handicap;
        
        	evolution.push({
            	    date: dates[0] || '2023-01-01',
            	    handicap: currentHandicap,
            	    gameNumber: 0,
            	    change: 0
        	});
        
        	// Variables pour la progression rÃ©aliste
        	var recentScores = [];
        	var gameNumber = 0;
        	var lastHandicapUpdate = 0;
        
        	for (var j = 0; j < dates.length; j++) {
            	    if (allScores[i][j] > 0) {
                	gameNumber++;
                	var grossScore = allScores[i][j];
                
                	// Ajouter Ã  la liste des scores rÃ©cents
                	recentScores.push(grossScore);
                
                	// Garder seulement les 8 derniers scores pour l'Ã©valuation
                	if (recentScores.length > 8) {
                    	    recentScores.shift();
                	}
                
                	// Calculer un changement basÃ© sur la performance rÃ©cente
                	var change = 0;
                
                	if (gameNumber >= 5 && (gameNumber - lastHandicapUpdate) >= 3) {
                    	    // Recalculer le handicap tous les 3 parties aprÃ¨s les 5 premiÃ¨res
                    	    var avgRecentScore = recentScores.reduce((sum, s) => sum + s, 0) / recentScores.length;
                    	    var expectedScore = 72 + currentHandicap; // Score attendu basÃ© sur par + handicap
                    
                    	    var performance = avgRecentScore - expectedScore;
                    
                    	    if (performance < -3) {
                        	// TrÃ¨s bonne performance = handicap baisse
                        	change = -0.5 - (Math.random() * 0.5);
                    	    } else if (performance < -1) {
                        	// Bonne performance = lÃ©gÃ¨re baisse
                        	change = -0.2 - (Math.random() * 0.3);
                    	    } else if (performance > 3) {
                        	// Mauvaise performance = handicap monte
                        	change = 0.3 + (Math.random() * 0.7);
                    	    } else if (performance > 1) {
                        	// Performance dÃ©cevante = lÃ©gÃ¨re hausse
                        	change = 0.1 + (Math.random() * 0.3);
                    	    } else {
                        	// Performance stable = changement minimal
                        	change = (Math.random() - 0.5) * 0.2;
                    	    }
                    
                    	    lastHandicapUpdate = gameNumber;
                	}
                
                	// Appliquer le changement
                	currentHandicap = Math.max(0, Math.min(36.4, currentHandicap + change));
                	currentHandicap = Math.round(currentHandicap * 10) / 10;
                
                	evolution.push({
                    	    date: dates[j],
                    	    handicap: currentHandicap,
                    	    gameNumber: gameNumber,
                    	    change: change,
                    	    score: grossScore,
                    	    course: courses[j],
                    	    avgRecent: recentScores.length > 0 ? (recentScores.reduce((sum, s) => sum + s, 0) / recentScores.length).toFixed(1) : 'N/A'
                	});
            	    }
        	}
        
        	handicapEvolutionData[player.id] = {
            	    player: player,
            	    playerName: playerName,
            	    evolution: evolution
        	};
    	    }
    
    	    console.log("âœ… Ã‰volution avec variation rÃ©aliste calculÃ©e!");
	}

	// 4. FONCTION POUR CHOISIR LA MÃ‰THODE DE CALCUL
	function updateHandicapEvolutionMethod(method) {
    	    console.log(`ğŸ”„ Mise Ã  jour avec mÃ©thode: ${method}`);
    
    	    switch(method) {
        	case 'progressive':
            	    prepareHandicapEvolutionDataProgressive();
            	    break;
        	case 'realistic':
            	    prepareHandicapEvolutionWithRealisticVariation();
            	    break;
        	default:
            	    console.log("âŒ MÃ©thode inconnue. Utilisez 'progressive' ou 'realistic'");
            	    return;
    	    }
    
    	    // Mettre Ã  jour l'affichage
    	    if (typeof displayHandicapStats === 'function') {
        	displayHandicapStats();
    	    }
    
    	    if (typeof selectedPlayers !== 'undefined' && selectedPlayers.length > 0) {
        	if (typeof drawHandicapChart === 'function') {
            	    drawHandicapChart();
        	}
    	    }
    
    	    console.log("âœ… Affichage mis Ã  jour!");
	}

	// 5. INSTRUCTIONS DE TEST
	console.log("=== INSTRUCTIONS POUR CORRIGER L'Ã‰VOLUTION ===");
	console.log("1. Diagnostic: diagnoseHandicapProgression()");
	console.log("2. MÃ©thode progressive: updateHandicapEvolutionMethod('progressive')");
	console.log("3. MÃ©thode rÃ©aliste: updateHandicapEvolutionMethod('realistic')");
	console.log("4. La mÃ©thode rÃ©aliste donnera des variations plus visibles");

	// CrÃ©er les checkboxes pour sÃ©lectionner les joueurs
	function createPlayerCheckboxes() {
    	    var container = document.getElementById('playerCheckboxes');
    	    var html = '';
    
    	    for (var i = 0; i < players.length; i++) {
        	var player = players[i];
        	var totalScores = allScores[i].filter(score => score > 0).length;
        
        	if (totalScores >= 5) { // Seulement les joueurs avec assez de scores
            	    // CORRECTION : Utiliser le nom calculÃ©
            	    var playerName = player.name || (player.firstName + ' ' + player.lastName);
            
            	    html += '<label style="display: flex; align-items: center; gap: 8px; padding: 8px; border: 1px solid #ddd; border-radius: 5px;">' +
                    	    '<input type="checkbox" value="' + player.id + '" onchange="togglePlayer(' + player.id + ')">' +
                    	    '<span><strong>' + playerName + '</strong> (' + totalScores + ' parties)</span>' +
                    	    '</label>';
        	}
    	    }
    
    	    container.innerHTML = html;
	}

	// SÃ©lectionner les joueurs par dÃ©faut
	function selectDefaultPlayers() {
    	    var checkboxes = document.querySelectorAll('#playerCheckboxes input[type="checkbox"]');
    	    selectedPlayers = [];
    
    	    // SÃ©lectionner les 3 premiers joueurs avec assez de scores
    	    for (var i = 0; i < Math.min(3, checkboxes.length); i++) {
        	checkboxes[i].checked = true;
        	selectedPlayers.push(parseInt(checkboxes[i].value));
    	    }
	}

	// Basculer la sÃ©lection d'un joueur
	function togglePlayer(playerId) {
    	var index = selectedPlayers.indexOf(playerId);
    	if (index > -1) {
        	selectedPlayers.splice(index, 1);
    	} else {
        	selectedPlayers.push(playerId);
    	}
    
    	// Mettre Ã  jour le graphique aprÃ¨s chaque changement
    	updateHandicapChart();
	}

	// SÃ©lectionner tous les joueurs
	function selectAllPlayers() {
    	    var checkboxes = document.querySelectorAll('#playerCheckboxes input[type="checkbox"]');
    	    selectedPlayers = [];
    
    	    for (var i = 0; i < checkboxes.length; i++) {
        	checkboxes[i].checked = true;
        	selectedPlayers.push(parseInt(checkboxes[i].value));
    	    }
    
    	    updateHandicapChart();
	}

	// DÃ©sÃ©lectionner tous les joueurs
	function clearAllPlayers() {
    	    var checkboxes = document.querySelectorAll('#playerCheckboxes input[type="checkbox"]');
    	    selectedPlayers = [];
    
    	    for (var i = 0; i < checkboxes.length; i++) {
        	checkboxes[i].checked = false;
    	    }
    
    	    updateHandicapChart();
    
    	    // CORRECTION : Maintenir l'affichage des statistiques mÃªme quand aucun joueur n'est sÃ©lectionnÃ©
    	    displayHandicapStats();
	}

	// Mettre Ã  jour le graphique
	function updateHandicapChart() {
    	    if (selectedPlayers.length === 0) {
        	document.getElementById('handicapChart').innerHTML = 
            	    '<div style="text-align: center; padding: 50px; color: #666; border: 2px dashed #ddd; border-radius: 8px; background: #f9f9fa;">' +
            	    '<h3 style="color: #999; margin-bottom: 10px;">ğŸ“ˆ Graphique d\'Ã‰volution</h3>' +
            	    '<p>Veuillez sÃ©lectionner au moins un joueur pour voir le graphique d\'Ã©volution des handicaps.</p>' +
            	    '<p style="font-size: 14px; color: #999;">Les statistiques de tous les joueurs sont affichÃ©es ci-dessous.</p>' +
            	    '</div>';
        
        	// CORRECTION : Toujours afficher les statistiques
        	displayHandicapStats();
        	return;
    	    }
    
    	    // Remettre le canvas si des joueurs sont sÃ©lectionnÃ©s
    	    document.getElementById('handicapChart').innerHTML = 
        	'<canvas id="handicapCanvas" width="1000" height="500" style="max-width: 100%; border: 1px solid #ddd; border-radius: 8px;"></canvas>';
    
    	    drawHandicapChart();
    	    displayHandicapStats();
	}

	// Dessiner le graphique des handicaps
	function drawHandicapChart() {
    	var canvas = document.getElementById('handicapCanvas');
    	var ctx = canvas.getContext('2d');

    	// Dimensions
    	var width = canvas.width;
    	var height = canvas.height;
    	var padding = 60;
    	var chartWidth = width - 2 * padding;
    	var chartHeight = height - 2 * padding;

    	// Nettoyer le canvas
    	ctx.clearRect(0, 0, width, height);

    	// Couleurs pour les joueurs
    	var colors = ['#e74c3c', '#3498db', '#2ecc71', '#f39c12', '#9b59b6', '#1abc9c', '#e67e22', '#34495e', '#f1c40f', '#95a5a6', '#d35400', '#8e44ad', '#16a085'];

    	// Trouver les limites des donnÃ©es (seulement Ã  partir de la 6e partie)
    	var minHandicap = Infinity;
    	var maxHandicap = -Infinity;
    	var maxGames = 0;

    	for (var i = 0; i < selectedPlayers.length; i++) {
        	var playerId = selectedPlayers[i];
        	var evolution = handicapEvolutionData[playerId].evolution;
        
        	for (var j = 0; j < evolution.length; j++) {
            	if (evolution[j].gameNumber >= 5) { // Seulement Ã  partir de la 6e partie
                	minHandicap = Math.min(minHandicap, evolution[j].handicap);
                	maxHandicap = Math.max(maxHandicap, evolution[j].handicap);
                	// Ajuster pour que maxGames reprÃ©sente la plage visible (0 = 6e partie)
                	maxGames = Math.max(maxGames, evolution[j].gameNumber - 5);
            	}
        	}
    	}

    	// Ajouter une marge
    	var handicapRange = maxHandicap - minHandicap;
    	minHandicap -= handicapRange * 0.1;
    	maxHandicap += handicapRange * 0.1;

    	// Dessiner les axes
    	ctx.strokeStyle = '#333';
    	ctx.lineWidth = 2;
    	ctx.beginPath();
    	ctx.moveTo(padding, padding);
    	ctx.lineTo(padding, height - padding);
    	ctx.lineTo(width - padding, height - padding);
    	ctx.stroke();

    	// Dessiner la grille horizontale
    	ctx.strokeStyle = '#e0e0e0';
    	ctx.lineWidth = 1;
    	for (var i = 0; i <= 10; i++) {
        	var y = padding + (chartHeight * i / 10);
        	ctx.beginPath();
        	ctx.moveTo(padding, y);
        	ctx.lineTo(width - padding, y);
        	ctx.stroke();
        
        	// Ã‰tiquettes handicap
        	var handicapValue = maxHandicap - (handicapRange * i / 10);
        	ctx.fillStyle = '#666';
        	ctx.font = '12px Arial';
        	ctx.textAlign = 'right';
        	ctx.fillText(handicapValue.toFixed(1), padding - 10, y + 4);
    	}

    	// Dessiner la grille verticale
    	for (var i = 0; i <= maxGames; i += Math.max(1, Math.floor(maxGames / 10))) {
        	var x = padding + (chartWidth * i / maxGames);
        	ctx.beginPath();
        	ctx.moveTo(x, padding);
        	ctx.lineTo(x, height - padding);
        	ctx.stroke();
        
        	// Ã‰tiquettes parties (ajuster pour montrer le vrai numÃ©ro de partie)
        	ctx.fillStyle = '#666';
        	ctx.font = '12px Arial';
        	ctx.textAlign = 'center';
        	ctx.fillText('P' + (i + 6), x, height - padding + 20); // +6 car on commence Ã  la 6e partie
    	}

    	// Dessiner les lignes des joueurs
    	for (var i = 0; i < selectedPlayers.length; i++) {
        	var playerId = selectedPlayers[i];
        	var playerData = handicapEvolutionData[playerId];
        	var evolution = playerData.evolution;
        	var color = colors[i % colors.length];

        	ctx.strokeStyle = color;
        	ctx.fillStyle = color;
        	ctx.lineWidth = 3;

        	// Filtrer pour ne montrer qu'Ã  partir de la 6e partie (gameNumber >= 5)
        	var visibleEvolution = evolution.filter(point => point.gameNumber >= 5);
        
        	if (visibleEvolution.length === 0) continue;

        	// Dessiner la ligne (seulement pour les parties 6+)
        	ctx.beginPath();
        	for (var j = 0; j < visibleEvolution.length; j++) {
            	var point = visibleEvolution[j];
            	// Ajuster gameNumber pour que la 6e partie devienne la position 0
            	var adjustedGameNumber = point.gameNumber - 5;
            	var x = padding + (chartWidth * adjustedGameNumber / maxGames);
            	var y = padding + (chartHeight * (maxHandicap - point.handicap) / handicapRange);

            	if (j === 0) {
                	ctx.moveTo(x, y);
            	} else {
                	ctx.lineTo(x, y);
            	}
        	}
        	ctx.stroke();

        	// Dessiner les points (seulement pour les parties 6+)
        	for (var j = 0; j < visibleEvolution.length; j++) {
            	var point = visibleEvolution[j];
            	var adjustedGameNumber = point.gameNumber - 5;
            	var x = padding + (chartWidth * adjustedGameNumber / maxGames);
            	var y = padding + (chartHeight * (maxHandicap - point.handicap) / handicapRange);

            	ctx.beginPath();
            	ctx.arc(x, y, 4, 0, 2 * Math.PI);
            	ctx.fill();
        	}
    	}

    	// LÃ©gende
    	var legendY = 20;
    	for (var i = 0; i < selectedPlayers.length; i++) {
        	var playerId = selectedPlayers[i];
        	var playerData = handicapEvolutionData[playerId];
        	var color = colors[i % colors.length];
        
        	var playerName = playerData.playerName || playerData.player.name || (playerData.player.firstName + ' ' + playerData.player.lastName);
        
        	ctx.fillStyle = color;
        	ctx.fillRect(width - 200, legendY + (i * 25), 15, 15);
        
        	ctx.fillStyle = '#333';
        	ctx.font = '14px Arial';
        	ctx.textAlign = 'left';
        	ctx.fillText(playerName, width - 180, legendY + (i * 25) + 12);
    	}

    	// Titre
    	ctx.fillStyle = '#333';
    	ctx.font = 'bold 16px Arial';
    	ctx.textAlign = 'center';
    	ctx.fillText('Ã‰volution des Handicaps par Partie (Ã  partir de la 6e partie)', width / 2, 30);

    	// Ã‰tiquettes des axes
    	ctx.fillStyle = '#666';
    	ctx.font = '14px Arial';
    	ctx.textAlign = 'center';
    	ctx.fillText('NumÃ©ro de Partie', width / 2, height - 10);

    	ctx.save();
    	ctx.translate(20, height / 2);
    	ctx.rotate(-Math.PI / 2);
    	ctx.fillText('Handicap Index', 0, 0);
    	ctx.restore();
	}

	// Afficher les statistiques d'Ã©volution
	function displayHandicapStats() {
    	    // CORRECTION : Afficher les stats pour TOUS les joueurs avec des scores, pas seulement les sÃ©lectionnÃ©s
    	    var allPlayersWithScores = [];
    
    	    for (var playerId in handicapEvolutionData) {
        	var playerData = handicapEvolutionData[playerId];
        	var evolution = playerData.evolution;
        
        	if (evolution.length >= 2) { // Au moins 2 points pour calculer l'Ã©volution
            	    allPlayersWithScores.push({
                	playerId: playerId,
                	playerData: playerData
            	    });
        	}
    	    }
    
    	    if (allPlayersWithScores.length === 0) {
        	document.getElementById('handicapStats').innerHTML = '<p style="text-align: center; color: #666; padding: 20px;">Aucune donnÃ©e d\'Ã©volution disponible</p>';
        	return;
    	    }
    
    	    var html = '<h3>ğŸ“Š Statistiques d\'Ã‰volution - Tous les Joueurs</h3>';
    	    html += '<p style="color: #666; margin-bottom: 15px;">Ã‰volution des handicaps pour tous les joueurs ayant au moins 5 parties</p>';
    	    html += '<table class="table"><thead><tr><th>Joueur</th><th>Handicap Initial</th><th>Handicap Final</th><th>Changement Total</th><th>Plus Grande AmÃ©lioration</th><th>Plus Grande DÃ©gradation</th><th>Parties</th></tr></thead><tbody>';
    
    	    // Trier par changement total (les amÃ©liorations en premier)
    	    allPlayersWithScores.sort((a, b) => {
        	var evolutionA = a.playerData.evolution;
        	var evolutionB = b.playerData.evolution;
        	var changeA = evolutionA[evolutionA.length - 1].handicap - evolutionA[0].handicap;
        	var changeB = evolutionB[evolutionB.length - 1].handicap - evolutionB[0].handicap;
        	return changeA - changeB; // Ordre croissant (amÃ©liorations nÃ©gatives en premier)
    	    });
    
    	    for (var i = 0; i < allPlayersWithScores.length; i++) {
        		var playerData = allPlayersWithScores[i].playerData;
        		var evolution = playerData.evolution;
        
        		// Trouver l'handicap Ã  la 6e partie JOUÃ‰E par ce joueur
				var initialHandicapForDisplay = evolution[0].handicap;
				var partiesJouees = 0;
				for (var k = 0; k < evolution.length; k++) {
    				// VÃ©rifier s'il a jouÃ© cette partie (a un score)
    				if (evolution[k].score && evolution[k].score > 0) {
        				partiesJouees++;
        				if (partiesJouees === 6) {
            				initialHandicapForDisplay = evolution[k].handicap;
            				break;
        				}
    				}
				}
				// Si le joueur n'a pas 6 parties, garder son handicap initial
				if (partiesJouees < 6) {
    				initialHandicapForDisplay = evolution[0].handicap;
				}

				var initialHandicap = evolution[0].handicap; // Garder le vrai initial pour les calculs
				var finalHandicap = evolution[evolution.length - 1].handicap;
				var totalChange = finalHandicap - initialHandicapForDisplay; // Changement depuis la 6e partie
        
        	var bestChange = 0;
        	var worstChange = 0;
        
        	for (var j = 1; j < evolution.length; j++) {
            	    var change = evolution[j].change;
            	    if (change < bestChange) bestChange = change;
            	    if (change > worstChange) worstChange = change;
        	}
        
        	// Style de ligne selon l'amÃ©lioration/dÃ©gradation
        	var changeClass = '';
        	var rowStyle = '';
        	if (totalChange < -2) {
            	    changeClass = 'style="color: #28a745; font-weight: bold;"'; // Vert pour grosse amÃ©lioration
            	    rowStyle = ' style="background: #f8fff8;"';
        	} else if (totalChange < 0) {
            	    changeClass = 'style="color: #28a745;"'; // Vert pour amÃ©lioration
        	} else if (totalChange > 2) {
            	    changeClass = 'style="color: #dc3545; font-weight: bold;"'; // Rouge pour grosse dÃ©gradation
            	    rowStyle = ' style="background: #fff8f8;"';
        	} else if (totalChange > 0) {
            	    changeClass = 'style="color: #dc3545;"'; // Rouge pour dÃ©gradation
        	}
        
        	var playerName = playerData.playerName || playerData.player.name || (playerData.player.firstName + ' ' + playerData.player.lastName);
        	var totalGames = evolution.length - 1; // -1 car le premier point est l'Ã©tat initial
        
        	html += '<tr' + rowStyle + '>' +
                	'<td><strong>' + playerName + '</strong></td>' +
                	'<td>' + initialHandicapForDisplay.toFixed(1) + '</td>' +
                	'<td>' + finalHandicap.toFixed(1) + '</td>' +
                	'<td ' + changeClass + '><strong>' + (totalChange > 0 ? '+' : '') + totalChange.toFixed(1) + '</strong></td>' +
                	'<td style="color: #28a745;">' + bestChange.toFixed(1) + '</td>' +
                	'<td style="color: #dc3545;">+' + worstChange.toFixed(1) + '</td>' +
                	'<td>' + totalGames + '</td>' +
                	'</tr>';
    	    }
    
    	    html += '</tbody></table>';
    
    	    // Ajouter une lÃ©gende
    	    html += '<div style="margin-top: 15px; padding: 10px; background: #f8f9fa; border-radius: 5px; font-size: 14px;">' +
            	    '<strong>LÃ©gende:</strong> ' +
            	    '<span style="color: #28a745;">ğŸŸ¢ AmÃ©lioration du handicap</span> | ' +
            	    '<span style="color: #dc3545;">ğŸ”´ DÃ©gradation du handicap</span> | ' +
            	    '<span style="color: #666;">âšª Changement minimal (Â±2 points)</span>' +
            	    '</div>';
    
    	    document.getElementById('handicapStats').innerHTML = html;
	}

	// 5. AJOUTER UNE FONCTION POUR FILTRER LES STATISTIQUES PAR SÃ‰LECTION (optionnel) :

	function toggleStatsDisplay() {
    	    var showOnlySelected = document.getElementById('showOnlySelected').checked;
    
    	    if (showOnlySelected && selectedPlayers.length > 0) {
        	displayHandicapStatsFiltered();
    	    } else {
        	displayHandicapStats();
    	    }
	}

	function displayHandicapStatsFiltered() {
    	    if (selectedPlayers.length === 0) return;
    
    	    var html = '<h3>ğŸ“Š Statistiques d\'Ã‰volution - Joueurs SÃ©lectionnÃ©s</h3>';
    	    html += '<table class="table"><thead><tr><th>Joueur</th><th>Handicap Initial</th><th>Handicap Final</th><th>Changement Total</th><th>Plus Grande AmÃ©lioration</th><th>Plus Grande DÃ©gradation</th><th>Parties</th></tr></thead><tbody>';
    
    	    for (var i = 0; i < selectedPlayers.length; i++) {
        	var playerId = selectedPlayers[i];
        	var playerData = handicapEvolutionData[playerId];
        	var evolution = playerData.evolution;
        
        	if (evolution.length < 2) continue;
        
        	var initialHandicap = evolution[0].handicap;
        	var finalHandicap = evolution[evolution.length - 1].handicap;
        	// Trouver l'handicap Ã  la 6e partie JOUÃ‰E par ce joueur
			var initialHandicapForDisplay = evolution[0].handicap;
			var partiesJouees = 0;
			for (var k = 0; k < evolution.length; k++) {
    			// VÃ©rifier s'il a jouÃ© cette partie (a un score)
    			if (evolution[k].score && evolution[k].score > 0) {
        			partiesJouees++;
        			if (partiesJouees === 6) {
            			initialHandicapForDisplay = evolution[k].handicap;
            			break;
        			}
    			}
			}
			// Si le joueur n'a pas 6 parties, garder son handicap initial
			if (partiesJouees < 6) {
    			initialHandicapForDisplay = evolution[0].handicap;
			}
			var totalChange = finalHandicap - initialHandicapForDisplay;
        
        	var bestChange = 0;
        	var worstChange = 0;
        
        	for (var j = 1; j < evolution.length; j++) {
            	    var change = evolution[j].change;
            	    if (change < bestChange) bestChange = change;
            	    if (change > worstChange) worstChange = change;
        	}
        
        	var changeClass = totalChange < 0 ? 'style="color: #28a745;"' : totalChange > 0 ? 'style="color: #dc3545;"' : '';
        	var playerName = playerData.playerName || playerData.player.name || (playerData.player.firstName + ' ' + playerData.player.lastName);
        	var totalGames = evolution.length - 1;
        
        	html += '<tr>' +
                	'<td><strong>' + playerName + '</strong></td>' +
                	'<td>' + initialHandicap.toFixed(1) + '</td>' +
                	'<td>' + finalHandicap.toFixed(1) + '</td>' +
                	'<td ' + changeClass + '><strong>' + (totalChange > 0 ? '+' : '') + totalChange.toFixed(1) + '</strong></td>' +
                	'<td style="color: #28a745;">' + bestChange.toFixed(1) + '</td>' +
                	'<td style="color: #dc3545;">+' + worstChange.toFixed(1) + '</td>' +
                	'<td>' + totalGames + '</td>' +
                	'</tr>';
    	    }
    
    	    html += '</tbody></table>';
    
    	    document.getElementById('handicapStats').innerHTML = html;
	}

	// Exporter les donnÃ©es d'Ã©volution
	function exportHandicapData() {
    	    if (selectedPlayers.length === 0) {
        	alert('Veuillez sÃ©lectionner au moins un joueur');
        	return;
    	    }
    
    	    var csvContent = 'Joueur,Date,NumÃ©ro Partie,Handicap,Changement,Score,Terrain\n';
    
    	    for (var i = 0; i < selectedPlayers.length; i++) {
        	var playerId = selectedPlayers[i];
        	var playerData = handicapEvolutionData[playerId];
        	var evolution = playerData.evolution;
        
        	// CORRECTION : Utiliser le nom calculÃ©
        	var playerName = playerData.playerName || playerData.player.name || (playerData.player.firstName + ' ' + playerData.player.lastName);
        
        	for (var j = 0; j < evolution.length; j++) {
            	    var point = evolution[j];
            	    csvContent += playerName + ',' +  // UTILISER playerName
                         	point.date + ',' +
                                point.gameNumber + ',' +
                         	point.handicap.toFixed(1) + ',' +
                         	point.change.toFixed(1) + ',' +
                         	(point.score || '') + ',' +
                         	(point.course || '') + '\n';
        	}
    	    }
    
    	    var blob = new Blob([csvContent], { type: 'text/csv' });
    	    var link = document.createElement('a');
    	    link.href = URL.createObjectURL(blob);
    	    link.download = 'evolution-handicaps-' + new Date().toISOString().split('T')[0] + '.csv';
    	    link.click();
	}

	// Variables pour la gestion des joueurs
	var nextPlayerId = 14; // Commencer aprÃ¨s les joueurs existants

	// Afficher la section de gestion des joueurs
	function showPlayerManagement() {
    	    hideAllSections();
    	    document.getElementById('playerManagement').style.display = 'block';
    	    setActiveButton(8); // Ajustez selon votre ordre de boutons
    	    loadPlayersGrid();
	}

	// Charger la grille des joueurs
	function loadPlayersGrid() {
    	    var html = '';
    
    	    // CORRECTION : S'assurer que tous les joueurs ont la propriÃ©tÃ© 'active'
    	    for (var i = 0; i < players.length; i++) {
        	if (players[i].active === undefined) {
            	    players[i].active = true; // Par dÃ©faut, tous les joueurs sont actifs
        	}
    	    }
    
    	    var activePlayers = players.filter(p => p.active);
    
    	    console.log("DEBUG: Nombre total de joueurs:", players.length);
    	    console.log("DEBUG: Joueurs actifs:", activePlayers.length);
    
    	    // Statistiques gÃ©nÃ©rales
    	    html += '<div class="card" style="background: #f8f9fa;">' +
            	    '<h3>ğŸ“Š Statistiques du Club</h3>' +
            	    '<div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(150px, 1fr)); gap: 15px;">' +
            	    '<div class="stat-box"><div class="stat-value">' + activePlayers.length + '</div><div class="stat-label">Joueurs Actifs</div></div>' +
            	    '<div class="stat-box"><div class="stat-value">' + (players.length - activePlayers.length) + '</div><div class="stat-label">Joueurs Inactifs</div></div>' +
            	    '<div class="stat-box"><div class="stat-value">' + getAverageHandicap().toFixed(1) + '</div><div class="stat-label">Handicap Moyen</div></div>' +
            	    '<div class="stat-box"><div class="stat-value">' + getTotalGamesPlayed() + '</div><div class="stat-label">Parties Totales</div></div>' +
            	    '</div>' +
            	    '</div>';
    
    	    // CORRECTION : Afficher TOUS les joueurs (actifs ET inactifs) pour la gestion
    	    for (var i = 0; i < players.length; i++) {
        	var player = players[i];
        
        	// CORRECTION : Calculer le nom du joueur
        	var playerName = player.name || (player.firstName + ' ' + player.lastName) || ('Joueur #' + player.id);
        
        	var playerStats = calculatePlayerStats(player);
        	var statusBadge = player.active ? 
            	    '<span style="background: #28a745; color: white; padding: 2px 8px; border-radius: 10px; font-size: 11px;">ACTIF</span>' : 
            	    '<span style="background: #6c757d; color: white; padding: 2px 8px; border-radius: 10px; font-size: 11px;">INACTIF</span>';
        
        	html += '<div class="course-card">' +
                	'<div class="course-header">' +
                	'<div class="course-name">ğŸŒï¸ ' + playerName + '</div>' +
                	'<div>' +
                	statusBadge +
                	'<button class="btn-secondary" onclick="editPlayer(' + player.id + ')" style="margin-left: 10px;">âœï¸ Modifier</button>' +
                	'<button class="btn-danger" onclick="togglePlayerStatus(' + player.id + ')">ğŸ”„ Statut</button>' +
                	'</div>' +
                	'</div>' +
                
                	'<div style="margin: 10px 0; padding: 10px; background: #f8f9fa; border-radius: 5px;">' +
                	'<div style="display: grid; grid-template-columns: 1fr 1fr; gap: 10px; font-size: 14px;">' +
                	'<div><strong>ğŸ“ TÃ©lÃ©phone:</strong><br>' + (player.phone || 'Non renseignÃ©') + '</div>' +
                	'<div><strong>ğŸ“§ Courriel:</strong><br>' + (player.email || 'Non renseignÃ©') + '</div>' +
                	'<div><strong>ğŸŒï¸ Handicap:</strong><br>' + player.handicap.toFixed(1) + '</div>' +
                	'<div><strong>ğŸ“… Membre depuis:</strong><br>' + formatDate(player.dateJoined) + '</div>' +
                	'</div>' +
                	'</div>' +
                
                	'<div style="border: 2px solid #4a7c59; border-radius: 8px; padding: 15px; background: #fff;">' +
                	'<h4 style="margin: 0 0 10px 0; color: #2c5530;">ğŸ“ˆ Statistiques GÃ©nÃ©rales</h4>' +
                	'<div style="display: grid; grid-template-columns: repeat(2, 1fr); gap: 10px; text-align: center;">' +
                	'<div style="background: #e8f5e8; padding: 10px; border-radius: 5px;"><strong>' + playerStats.totalGames + '</strong><br><small>Parties</small></div>' +
                	'<div style="background: #e3f2fd; padding: 10px; border-radius: 5px;"><strong>' + playerStats.avgScore.toFixed(1) + '</strong><br><small>Score Moyen</small></div>' +
                	'<div style="background: #fff3e0; padding: 10px; border-radius: 5px;"><strong>' + playerStats.bestScore + '</strong><br><small>Meilleur Score</small></div>' +
                	'<div style="background: #fce4ec; padding: 10px; border-radius: 5px;"><strong>' + playerStats.worstScore + '</strong><br><small>Pire Score</small></div>' +
                	'</div>' +
                	'<div style="margin-top: 10px; text-align: center; font-size: 12px; color: #666;">' +
                	'DerniÃ¨re partie: ' + (playerStats.lastGame || 'Aucune') + 
                	'</div>' +
                	'</div>' +
                
                	'</div>';
    	    }
    
    	    console.log("DEBUG: HTML gÃ©nÃ©rÃ©, longueur:", html.length);
    	    document.getElementById('playersGrid').innerHTML = html;
	}

	// Calculer les statistiques d'un joueur
	function calculatePlayerStats(player) {
    	    var playerIndex = players.findIndex(p => p.id === player.id);
    
    	    console.log("DEBUG: Calcul stats pour joueur", player.id, "index:", playerIndex);
    
    	    if (playerIndex === -1 || !allScores[playerIndex]) {
        	console.log("DEBUG: Pas de scores pour le joueur", player.id);
        	return {
            	    totalGames: 0,
            	    avgScore: 0,
            	    bestScore: 'N/A',
            	    worstScore: 'N/A',
            	    lastGame: 'Aucune'
        	};
    	    }
    
    	    var scores = allScores[playerIndex].filter(score => score > 0);
    
    	    console.log("DEBUG: Joueur", player.id, "a", scores.length, "scores");
    
    	    if (scores.length === 0) {
        	return {
            	    totalGames: 0,
            	    avgScore: 0,
            	    bestScore: 'N/A',
            	    worstScore: 'N/A',
            	    lastGame: 'Aucune'
        	};
    	    }
    
    	    var totalScore = scores.reduce((sum, score) => sum + score, 0);
    	    var avgScore = totalScore / scores.length;
    	    var bestScore = Math.min(...scores);
    	    var worstScore = Math.max(...scores);
    
    	    // Trouver la derniÃ¨re partie
    	    var lastGameIndex = -1;
    	    for (var i = allScores[playerIndex].length - 1; i >= 0; i--) {
        	if (allScores[playerIndex][i] > 0) {
            	    lastGameIndex = i;
            	    break;
        	}
    	    }
    
    	    var lastGame = lastGameIndex >= 0 ? formatDate(dates[lastGameIndex]) : 'Aucune';
    
    	    return {
        	totalGames: scores.length,
        	avgScore: avgScore,
        	bestScore: bestScore,
        	worstScore: worstScore,
        	lastGame: lastGame
    	    };
	}

	// Afficher le formulaire d'ajout de joueur
	function showAddPlayerForm() {
    	    var form = document.getElementById('addPlayerForm');
    	    if (form.style.display === 'none') {
        	form.style.display = 'block';
        	// DÃ©finir la date d'aujourd'hui par dÃ©faut
        	document.getElementById('newPlayerDateJoined').value = new Date().toISOString().split('T')[0];
        	// Vider les champs
        	document.getElementById('newPlayerFirstName').value = '';
        	document.getElementById('newPlayerLastName').value = '';
        	document.getElementById('newPlayerPhone').value = '';
        	document.getElementById('newPlayerEmail').value = '';
        	document.getElementById('newPlayerHandicap').value = '';
    	    } else {
        	form.style.display = 'none';
    	    }
	}

	// Sauvegarder un nouveau joueur
	function saveNewPlayer() {
    	    var firstName = document.getElementById('newPlayerFirstName').value.trim();
    	    var lastName = document.getElementById('newPlayerLastName').value.trim();
    	    var phone = document.getElementById('newPlayerPhone').value.trim();
    	    var email = document.getElementById('newPlayerEmail').value.trim();
    	    var handicap = parseFloat(document.getElementById('newPlayerHandicap').value);
    	    var dateJoined = document.getElementById('newPlayerDateJoined').value;
    
    	    // Validation
    	    if (!firstName || !lastName) {
        	alert('Le prÃ©nom et le nom sont obligatoires.');
        	return;
    	    }
    
    	    if (isNaN(handicap) || handicap < 0 || handicap > 36.4) {
        	alert('Le handicap doit Ãªtre un nombre entre 0 et 36.4.');
        	return;
    	    }
    
    	    if (email && !isValidEmail(email)) {
        	alert('L\'adresse courriel n\'est pas valide.');
        	return;
    	    }
    
    	    // VÃ©rifier si le joueur existe dÃ©jÃ 
    	    var existingPlayer = players.find(p => 
        	p.firstName.toLowerCase() === firstName.toLowerCase() && 
        	p.lastName.toLowerCase() === lastName.toLowerCase()
    	    );
    
    	    if (existingPlayer) {
        	alert('Un joueur avec ce nom existe dÃ©jÃ .');
        	return;
    	    }
    
    	    // Trouver le prochain ID disponible
    	    var nextId = Math.max(...players.map(p => p.id)) + 1;
    
    	    // CrÃ©er le nouveau joueur
    	    var newPlayer = {
        	id: nextId,
        	firstName: firstName,
        	lastName: lastName,
        	name: firstName + ' ' + lastName,
        	phone: phone,
        	email: email,
        	handicap: handicap,
        	dateJoined: dateJoined,
        	active: true
    	    };
    
    	    players.push(newPlayer);
    
    	    // Ajouter un tableau vide de scores pour ce joueur
    	    var emptyScores = new Array(dates.length).fill(null);
    	    allScores.push(emptyScores);
    
            // Sauvegarder dans Firebase
            Promise.all([
                savePlayersToFirebase(),
                saveScoresToFirebase()
            ]).then(function() {
                console.log('Nouveau joueur sauvegardÃ© dans Firebase');
            }).catch(function(error) {
                console.error('Erreur de sauvegarde:', error);
                alert('Erreur de sauvegarde: ' + error.message);
            });

    	    // Sauvegarder et recharger
    	    loadPlayersGrid();
    	    showAddPlayerForm(); // Fermer le formulaire
    
    	    alert('âœ… Joueur "' + newPlayer.name + '" ajoutÃ© avec succÃ¨s!');
	}

	// Annuler l'ajout de joueur
	function cancelAddPlayer() {
    	    showAddPlayerForm();
	}

	// Ã‰diter un joueur
	function editPlayer(playerId) {
    	    var player = players.find(p => p.id === playerId);
    	    if (!player) {
        	alert('Joueur non trouvÃ©!');
        	return;
    	    }
    
    	    var playerName = player.name || (player.firstName + ' ' + player.lastName);
    
    	    // CrÃ©er un formulaire d'Ã©dition plus complet
    	    var formHtml = 
        	'<div style="position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.5); z-index: 1000; display: flex; justify-content: center; align-items: center;">' +
        	'<div style="background: white; padding: 30px; border-radius: 10px; box-shadow: 0 4px 20px rgba(0,0,0,0.3); max-width: 500px; width: 90%;">' +
        	'<h3 style="margin-top: 0; color: #2c5530;">âœï¸ Modifier ' + playerName + '</h3>' +
        
        	'<div style="margin: 15px 0;">' +
        	'<label style="display: block; font-weight: bold; margin-bottom: 5px;">PrÃ©nom:</label>' +
        	'<input type="text" id="editFirstName" value="' + (player.firstName || '') + '" style="width: 100%; padding: 8px; border: 1px solid #ddd; border-radius: 4px;">' +
        	'</div>' +
        
        	'<div style="margin: 15px 0;">' +
        	'<label style="display: block; font-weight: bold; margin-bottom: 5px;">Nom:</label>' +
        	'<input type="text" id="editLastName" value="' + (player.lastName || '') + '" style="width: 100%; padding: 8px; border: 1px solid #ddd; border-radius: 4px;">' +
        	'</div>' +
        
        	'<div style="margin: 15px 0;">' +
        	'<label style="display: block; font-weight: bold; margin-bottom: 5px;">TÃ©lÃ©phone:</label>' +
        	'<input type="tel" id="editPhone" value="' + (player.phone || '') + '" style="width: 100%; padding: 8px; border: 1px solid #ddd; border-radius: 4px;">' +
        	'</div>' +
        
        	'<div style="margin: 15px 0;">' +
        	'<label style="display: block; font-weight: bold; margin-bottom: 5px;">Courriel:</label>' +
        	'<input type="email" id="editEmail" value="' + (player.email || '') + '" style="width: 100%; padding: 8px; border: 1px solid #ddd; border-radius: 4px;">' +
        	'</div>' +
        
        	'<div style="margin: 15px 0;">' +
        	'<label style="display: block; font-weight: bold; margin-bottom: 5px;">Handicap:</label>' +
        	'<input type="number" id="editHandicap" value="' + player.handicap + '" step="0.1" min="0" max="36.4" style="width: 100%; padding: 8px; border: 1px solid #ddd; border-radius: 4px;">' +
        	'</div>' +
        
        	'<div style="margin: 15px 0;">' +
        	'<label style="display: block; font-weight: bold; margin-bottom: 5px;">Date d\'adhÃ©sion:</label>' +
        	'<input type="date" id="editDateJoined" value="' + (player.dateJoined || '') + '" style="width: 100%; padding: 8px; border: 1px solid #ddd; border-radius: 4px;">' +
        	'</div>' +
        
        	'<div style="margin-top: 25px; text-align: center;">' +
        	'<button onclick="savePlayerEdit(' + playerId + ')" style="background: #4a7c59; color: white; border: none; padding: 10px 20px; border-radius: 5px; margin: 5px; cursor: pointer;">ğŸ’¾ Sauvegarder</button>' +
        	'<button onclick="cancelPlayerEdit()" style="background: #6c757d; color: white; border: none; padding: 10px 20px; border-radius: 5px; margin: 5px; cursor: pointer;">âŒ Annuler</button>' +
        	'</div>' +
        
        	'</div>' +
        	'</div>';
    
    	    // Ajouter le formulaire au body
    	    var formDiv = document.createElement('div');
    	    formDiv.id = 'editPlayerForm';
    	    formDiv.innerHTML = formHtml;
    	    document.body.appendChild(formDiv);
	}

	function savePlayerEdit(playerId) {
    	    var player = players.find(p => p.id === playerId);
    	    if (!player) return;
    
    	    var newFirstName = document.getElementById('editFirstName').value.trim();
    	    var newLastName = document.getElementById('editLastName').value.trim();
    	    var newPhone = document.getElementById('editPhone').value.trim();
    	    var newEmail = document.getElementById('editEmail').value.trim();
    	    var newHandicap = parseFloat(document.getElementById('editHandicap').value);
    	    var newDateJoined = document.getElementById('editDateJoined').value;
    
    	    // Validation
    	    if (!newFirstName || !newLastName) {
        	alert('Le prÃ©nom et le nom sont obligatoires.');
        	return;
    	    }
    
    	    if (isNaN(newHandicap) || newHandicap < 0 || newHandicap > 36.4) {
        	alert('Le handicap doit Ãªtre un nombre entre 0 et 36.4.');
        	return;
    	    }
    
    	    if (newEmail && !isValidEmail(newEmail)) {
        	alert('L\'adresse courriel n\'est pas valide.');
        	return;
    	    }
    
    	    // Mettre Ã  jour
    	    player.firstName = newFirstName;
    	    player.lastName = newLastName;
    	    player.name = newFirstName + ' ' + newLastName;
    	    player.phone = newPhone;
    	    player.email = newEmail;
    	    player.handicap = newHandicap;
    	    player.dateJoined = newDateJoined;
    
    	    // Fermer le formulaire
    	    cancelPlayerEdit();
    
    	    // Recharger l'affichage
    	    loadPlayersGrid();
    
    	    alert('âœ… Joueur "' + player.name + '" modifiÃ© avec succÃ¨s!');
	}

	function cancelPlayerEdit() {
    	    var formDiv = document.getElementById('editPlayerForm');
    	    if (formDiv) {
        	formDiv.remove();
    	    }
	}
		// Basculer le statut actif/inactif d'un joueur
		function togglePlayerStatus(playerId) {
    	    	    var player = players.find(p => p.id === playerId);
    	    	    if (!player) return;
    
    	    	    var action = player.active ? 'dÃ©sactiver' : 'rÃ©activer';
    	    	    if (confirm('Voulez-vous ' + action + ' le joueur "' + getPlayerName(player) + '"?')) {
        		player.active = !player.active;
        		savePlayersData();
        		loadPlayersGrid();
        
        		var status = player.active ? 'rÃ©activÃ©' : 'dÃ©sactivÃ©';
        		alert('âœ… Joueur ' + status + ' avec succÃ¨s!');
    	    	    }
		}

	// Fonctions utilitaires
	function getAverageHandicap() {
    	    var activePlayers = players.filter(p => p.active);
    	    if (activePlayers.length === 0) return 0;
    
    	    var total = activePlayers.reduce((sum, p) => sum + p.handicap, 0);
    	    return total / activePlayers.length;
	}

	function getTotalGamesPlayed() {
    	    var total = 0;
    	    for (var i = 0; i < allScores.length; i++) {
        	total += allScores[i].filter(score => score > 0).length;
    	    }
    	    return total;
	}

	function formatDate(dateString) {
    	    if (!dateString) return 'Non dÃ©finie';
    	    var date = new Date(dateString);
    	    return date.toLocaleDateString('fr-FR');
	}

	function isValidEmail(email) {
    	    var emailRegex = /^[^\s@]+@[^\s@]+\.[^\s@]+$/;
    	    return emailRegex.test(email);
	}

	// Exporter les donnÃ©es des joueurs
	function exportPlayersData() {
    	    var dataToExport = {
        	players: players,
        	exportDate: new Date().toISOString(),
        	totalPlayers: players.length
    	    };
    
    	    var dataStr = JSON.stringify(dataToExport, null, 2);
    	    var dataBlob = new Blob([dataStr], {type: 'application/json'});
    
    	    var link = document.createElement('a');
    	    link.href = URL.createObjectURL(dataBlob);
    	    link.download = 'joueurs-golf-' + new Date().toISOString().split('T')[0] + '.json';
    	    link.click();
	}	

	// Importer les donnÃ©es des joueurs
	function importPlayersData() {
    	    document.getElementById('importFile').click();
	}

	function handleFileImport(event) {
    	    var file = event.target.files[0];
    	    if (!file) return;
    
    	    var reader = new FileReader();
    	    reader.onload = function(e) {
        	try {
            	    var importedData = JSON.parse(e.target.result);
            	    if (importedData.players && Array.isArray(importedData.players)) {
                	if (confirm('Cela va remplacer tous les joueurs existants. Continuer?')) {
                    	    players = importedData.players;
                    	    nextPlayerId = Math.max(...players.map(p => p.id)) + 1;
                    	    savePlayersData();
                    	    loadPlayersGrid();
                    	    alert('âœ… Joueurs importÃ©s avec succÃ¨s!');
                	}	
            	    } else {
                	alert('âŒ Format de fichier invalide.');
            	    }
        	} catch (error) {
            	    alert('âŒ Erreur lors de l\'importation: ' + error.message);
        	}
    	    };
    	    reader.readAsText(file);
	}

	function savePlayersData() {
    	    // Simuler la sauvegarde
    	    console.log('Joueurs sauvegardÃ©s:', players.length + ' joueurs');
	}

	// 4. FONCTION UTILITAIRE POUR OBTENIR LE NOM DU JOUEUR (AJOUTEZ CETTE FONCTION)

	function getPlayerDisplayName(player) {
    	    if (player.name) {
        	return player.name;
    	    } else if (player.firstName && player.lastName) {
        	return player.firstName + ' ' + player.lastName;
    	    } else if (player.firstName) {
        	return player.firstName;
    	    } else {
        	return 'Joueur #' + player.id;
    	    }
	}

	// 5. FONCTION POUR RÃ‰PARER TOUS LES NOMS AUTOMATIQUEMENT

	function fixAllPlayerNames() {
    	    console.log("RÃ©paration des noms de joueurs...");
    
    	    for (var i = 0; i < players.length; i++) {
        	var player = players[i];
        
        	// Si pas de nom mais firstName/lastName existent
        	if (!player.name && player.firstName && player.lastName) {
            	player.name = player.firstName + ' ' + player.lastName;
            	console.log("RÃ©parÃ©:", player.name);
        	}
        	// Si pas de firstName/lastName mais name existe
        	else if (player.name && (!player.firstName || !player.lastName)) {
            	    var parts = player.name.split(' ');
            	    player.firstName = parts[0] || '';
            	    player.lastName = parts.slice(1).join(' ') || '';
            	    console.log("AjoutÃ© firstName/lastName pour:", player.name);
        	}
    	    }
    
    	    // Mettre Ã  jour tous les scores existants avec les bons noms
    	    for (var i = 0; i < scores.length; i++) {
        	var score = scores[i];
        	var player = players.find(p => p.id === score.playerId);
        	if (player && (!score.playerName || score.playerName === 'undefined')) {
            	    score.playerName = getPlayerDisplayName(player);
        	}
    	    }
    
    	    console.log("RÃ©paration terminÃ©e!");
	}

	// Variables globales pour la nouvelle partie
	var newRoundPlayers = {};

	// Afficher la section d'ajout de partie
	function showAddRound() {
    	    hideAllSections();
    	    document.getElementById('addRound').style.display = 'block';
    	    setActiveButton(8); // Ajustez selon votre ordre de boutons
    	    loadAddRoundInterface();
	}

	// Charger l'interface d'ajout de partie
	function loadAddRoundInterface() {
    	    // DÃ©finir la date d'aujourd'hui par dÃ©faut
    	    document.getElementById('newRoundDate').value = new Date().toISOString().split('T')[0];
    
    	    // Charger la liste des terrains
    	    loadCourseOptions();
    
    	    // Charger la grille des joueurs
    	    loadPlayersScoreGrid();
    
    	    // Initialiser les variables
    	    newRoundPlayers = {};

			// AJOUTER CETTE LIGNE :
    		updateGPROptions(); // Forcer l'affichage des options GPR si GPR est sÃ©lectionnÃ© par dÃ©faut
	}

	// Charger les options de terrains
	function loadCourseOptions() {
    	    var select = document.getElementById('newRoundCourse');
    	    select.innerHTML = '<option value="">-- SÃ©lectionner un terrain --</option>';
    
    	    var courseNames = Object.keys(coursesDatabase).sort();
    
    	    for (var i = 0; i < courseNames.length; i++) {
        	var courseName = courseNames[i];
        	var option = document.createElement('option');
        	option.value = courseName;
        	option.textContent = courseName;
        	select.appendChild(option);
    	    }
	}

	// Mettre Ã  jour les dÃ©parts disponibles selon le terrain sÃ©lectionnÃ©
	function updateAvailableTees() {
    	    var courseName = document.getElementById('newRoundCourse').value;
    	    var teeSelect = document.getElementById('newRoundDefaultTee');
    
    	    teeSelect.innerHTML = '<option value="">-- Choisir --</option>';
    
    	    if (courseName && coursesDatabase[courseName]) {
        	var tees = coursesDatabase[courseName];
        
        	for (var i = 0; i < tees.length; i++) {
            	    var tee = tees[i];
            	    var option = document.createElement('option');
            	    option.value = tee.tee;
            	    option.textContent = tee.tee.charAt(0).toUpperCase() + tee.tee.slice(1) + 
                               	       ` (Rating: ${tee.rating}, Slope: ${tee.slope}, Par: ${tee.par})`;
            	    teeSelect.appendChild(option);
        	}
    	    }
	}

	// Charger la grille des joueurs pour saisie des scores
	function loadPlayersScoreGrid() {
    	    var html = '';
    
    	    for (var i = 0; i < players.length; i++) {
        	var player = players[i];
        	if (!player.active) continue; // Seulement les joueurs actifs
        
        	var playerName = player.name || (player.firstName + ' ' + player.lastName);
        
        	html += '<div class="course-card" id="playerCard_' + player.id + '">' +
                	'<div class="course-header">' +
                	'<label style="display: flex; align-items: center; gap: 10px;">' +
                	'<input type="checkbox" id="playerCheck_' + player.id + '" onchange="togglePlayerForRound(' + player.id + ')">' +
                	'<span><strong>' + playerName + '</strong></span>' +
                	'<span style="background: #e9ecef; padding: 2px 6px; border-radius: 10px; font-size: 11px;">H: ' + player.handicap.toFixed(1) + '</span>' +
                	'</label>' +
                	'</div>' +
                
                	'<div id="playerInputs_' + player.id + '" style="display: none; margin-top: 15px;">' +
                
                	'<div style="display: grid; grid-template-columns: 1fr 1fr; gap: 10px; margin-bottom: 15px;">' +
                	'<div>' +
                	'<label style="display: block; font-weight: bold; margin-bottom: 5px;">DÃ©part:</label>' +
                	'<select id="playerTee_' + player.id + '" style="width: 100%; padding: 6px;">' +
                	'<option value="">Utiliser dÃ©faut</option>' +
                	'</select>' +
                	'</div>' +
                	'<div>' +
                	'<label style="display: block; font-weight: bold; margin-bottom: 5px;">Score Brut:</label>' +
                	'<input type="number" id="playerScore_' + player.id + '" min="50" max="150" style="width: 100%; padding: 6px;" placeholder="Ex: 85">' +
                	'</div>' +
                	'</div>' +
                
                	'<div style="background: #f8f9fa; padding: 10px; border-radius: 5px; font-size: 12px;">' +
                	'<div id="playerPreview_' + player.id + '">SÃ©lectionnez d\'abord un terrain</div>' +
                	'</div>' +
                
                	'</div>' +
                	'</div>';
    	    }
    
    	    document.getElementById('playersScoreGrid').innerHTML = html;
	}

	// Activer/dÃ©sactiver un joueur pour la partie
	function togglePlayerForRound(playerId) {
    	    var checkbox = document.getElementById('playerCheck_' + playerId);
    	    var inputs = document.getElementById('playerInputs_' + playerId);
    	    var player = players.find(p => p.id === playerId);
    
    	    if (checkbox.checked) {
        	inputs.style.display = 'block';
        
        	// Initialiser les dÃ©parts disponibles pour ce joueur
        	updatePlayerTeeOptions(playerId);
        
        	// Ajouter Ã  la liste
        	newRoundPlayers[playerId] = {
            	    player: player,
            	    tee: '',
            	    score: null
        	};
        
        	// Calculer l'aperÃ§u si un terrain est sÃ©lectionnÃ©
        	updatePlayerPreview(playerId);
        
    	    } else {
        	inputs.style.display = 'none';
        	delete newRoundPlayers[playerId];
    	    }
	}

	// Mettre Ã  jour les options de dÃ©part pour un joueur
	function updatePlayerTeeOptions(playerId) {
    	    var courseName = document.getElementById('newRoundCourse').value;
    	    var defaultTee = document.getElementById('newRoundDefaultTee').value;
    	    var playerTeeSelect = document.getElementById('playerTee_' + playerId);
    
    	    playerTeeSelect.innerHTML = '<option value="">Utiliser dÃ©faut (' + (defaultTee || 'non dÃ©fini') + ')</option>';
    
    	    if (courseName && coursesDatabase[courseName]) {
        	var tees = coursesDatabase[courseName];
        
        	for (var i = 0; i < tees.length; i++) {
            	    var tee = tees[i];
            	    var option = document.createElement('option');
            	    option.value = tee.tee;
            	    option.textContent = tee.tee.charAt(0).toUpperCase() + tee.tee.slice(1);
            	    playerTeeSelect.appendChild(option);
        	}
    	    }
	}

	// Mettre Ã  jour l'aperÃ§u pour un joueur
	function updatePlayerPreview(playerId) {
    	    var courseName = document.getElementById('newRoundCourse').value;
    	    var defaultTee = document.getElementById('newRoundDefaultTee').value;
    	    var playerTee = document.getElementById('playerTee_' + playerId).value || defaultTee;
    	    var playerScore = parseInt(document.getElementById('playerScore_' + playerId).value);
    	    var player = players.find(p => p.id === playerId);
    
    	    var previewDiv = document.getElementById('playerPreview_' + playerId);
    
    	    if (!courseName || !playerTee) {
        	previewDiv.innerHTML = 'SÃ©lectionnez un terrain et un dÃ©part';
        	return;
    	    }
    
    	    // Calculer le handicap de parcours
    	    var courseHandicap = calculateCourseHandicap(player.handicap, courseName, playerTee);
    	    var netScore = playerScore ? (playerScore - courseHandicap).toFixed(1) : '?';
    
    	    var html = '<strong>AperÃ§u:</strong><br>' +
               	       'DÃ©part: ' + playerTee + ' | ' +
               	       'Handicap parcours: ' + courseHandicap.toFixed(1) + '<br>' +
               	       'Score net: ' + (playerScore ? playerScore + ' - ' + courseHandicap.toFixed(1) + ' = ' + netScore : 'En attente du score');
    
    	    previewDiv.innerHTML = html;
	}

	// Fonctions de sÃ©lection rapide
	function selectAllPlayersForRound() {
    	    for (var i = 0; i < players.length; i++) {
        	var player = players[i];
        	if (player.active) {
            	    var checkbox = document.getElementById('playerCheck_' + player.id);
            	    if (!checkbox.checked) {
                	checkbox.checked = true;
                	togglePlayerForRound(player.id);
            	    }
        	}
    	    }
	}

	function clearAllPlayersForRound() {
    	    for (var playerId in newRoundPlayers) {
        	var checkbox = document.getElementById('playerCheck_' + playerId);
        	checkbox.checked = false;
        	togglePlayerForRound(parseInt(playerId));
    	    }
	}

	function selectFrequentPlayers() {
    	    // SÃ©lectionner les joueurs qui ont jouÃ© le plus de parties
    	    var playerGameCounts = [];
    
    	    for (var i = 0; i < players.length; i++) {
        	var player = players[i];
        	if (player.active) {
            	    var gameCount = allScores[i] ? allScores[i].filter(score => score > 0).length : 0;
            	    playerGameCounts.push({
                	playerId: player.id,
                	gameCount: gameCount
            	    });
        	}
    	    }
    
    	    // Trier par nombre de parties et prendre les 8 premiers
    	    playerGameCounts.sort((a, b) => b.gameCount - a.gameCount);
    	    var topPlayers = playerGameCounts.slice(0, 8);
    
    	    // DÃ©sÃ©lectionner tous d'abord
    	    clearAllPlayersForRound();
    
    	    // SÃ©lectionner les joueurs frÃ©quents
    	    for (var i = 0; i < topPlayers.length; i++) {
        	var playerId = topPlayers[i].playerId;
        	var checkbox = document.getElementById('playerCheck_' + playerId);
        	checkbox.checked = true;
        	togglePlayerForRound(playerId);
    	    }
	}

	// AperÃ§u de la partie
	function previewNewRound() {
    	    var date = document.getElementById('newRoundDate').value;
    	    var courseName = document.getElementById('newRoundCourse').value;
    	    var roundType = document.getElementById('newRoundType').value;
    
    	    if (!date || !courseName) {
        	alert('Veuillez sÃ©lectionner une date et un terrain.');
        	return;
    	    }
    
    	    var selectedPlayers = Object.keys(newRoundPlayers);
    	    if (selectedPlayers.length === 0) {
        	alert('Veuillez sÃ©lectionner au moins un joueur.');
        	return;
    	    }
    
    	    // Collecter les donnÃ©es
    	    var roundData = [];
    	    var hasAllScores = true;
    
    	    for (var i = 0; i < selectedPlayers.length; i++) {
        	var playerId = parseInt(selectedPlayers[i]);
        	var player = players.find(p => p.id === playerId);
        	var defaultTee = document.getElementById('newRoundDefaultTee').value;
        	var playerTee = document.getElementById('playerTee_' + playerId).value || defaultTee;
        	var playerScore = parseInt(document.getElementById('playerScore_' + playerId).value);
        
        	if (!playerScore || !playerTee) {
            	    hasAllScores = false;
        	}
        
        	var courseHandicap = playerTee ? calculateCourseHandicap(player.handicap, courseName, playerTee) : 0;
        	var netScore = playerScore ? playerScore - courseHandicap : null;
        
        	roundData.push({
            	    player: player,
            	    tee: playerTee,
            	    score: playerScore,
            	    courseHandicap: courseHandicap,
            	    netScore: netScore
        	});
    	    }
    
    	    // Trier par score net
    	    roundData.sort((a, b) => {
        	if (!a.netScore) return 1;
        	if (!b.netScore) return -1;
        	return a.netScore - b.netScore;
    	    });
    
    	    // GÃ©nÃ©rer l'aperÃ§u
    	    var html = '<h4>ğŸ“Š AperÃ§u de la Partie</h4>' +
               	       '<p><strong>Date:</strong> ' + new Date(date).toLocaleDateString('fr-FR') + '</p>' +
               	       '<p><strong>Terrain:</strong> ' + courseName + '</p>' +
               	       '<p><strong>Type:</strong> ' + (roundType === 'diablo' ? 'ğŸ† Diablo' : roundType === 'gpr' ? 'ğŸ¯ GPR' : 'â›³ Amicale') + '</p>' +
               	       '<p><strong>Joueurs:</strong> ' + selectedPlayers.length + '</p>';
    
    	    if (!hasAllScores) {
        	    html += '<div style="background: #fff3cd; padding: 10px; border-radius: 5px; margin: 10px 0;">' +
                	'âš ï¸ Certains scores ou dÃ©parts sont manquants</div>';
    	    }
    
    	    html += '<table class="table">' +
            	    '<thead><tr><th>Pos.</th><th>Joueur</th><th>DÃ©part</th><th>Score Brut</th><th>Handicap</th><th>Score Net</th></tr></thead>' +
            	    '<tbody>';
    
    	    for (var i = 0; i < roundData.length; i++) {
        	var data = roundData[i];
        	var playerName = data.player.name || (data.player.firstName + ' ' + data.player.lastName);
        
        	html += '<tr>' +
                	'<td>' + (data.netScore ? (i + 1) : '-') + '</td>' +
                	'<td><strong>' + playerName + '</strong></td>' +
                	'<td>' + (data.tee || 'âŒ') + '</td>' +
                	'<td>' + (data.score || 'âŒ') + '</td>' +
                	'<td>' + (data.tee ? data.courseHandicap.toFixed(1) : '-') + '</td>' +
                	'<td><strong>' + (data.netScore ? data.netScore.toFixed(1) : 'âŒ') + '</strong></td>' +
                	'</tr>';
    	    }
    
    	    html += '</tbody></table>';
    
    	    document.getElementById('previewContent').innerHTML = html;
    	    document.getElementById('newRoundPreview').style.display = 'block';
	}

    function saveAllToFirebase() {
        showLoading('Sauvegarde en cours...');
    
        Promise.all([
            savePlayersToFirebase(),
            saveScoresToFirebase(),
            saveCoursesToFirebase(),
            saveDatesToFirebase(),
			saveRoundsToFirebase()
        ]).then(function() {
            hideLoading();
            alert('âœ… Toutes les donnÃ©es sauvegardÃ©es avec succÃ¨s!');
        }).catch(function(error) {
            hideLoading();
            console.error('Erreur de sauvegarde complÃ¨te:', error);
            alert('âŒ Erreur de sauvegarde: ' + error.message);
        });
    }
    
	// Sauvegarder la nouvelle partie
	function saveNewRound() {
    	    console.log('=== FONCTION saveNewRound() APPELÃ‰E ==='); // AJOUTE CETTE LIGNE

			var date = document.getElementById('newRoundDate').value;
    	    var courseName = document.getElementById('newRoundCourse').value;
    	    var defaultTee = document.getElementById('newRoundDefaultTee').value;
    	    var roundType = document.getElementById('newRoundType').value;
    
			// === LIGNES DE DEBUG Ã€ AJOUTER ===
			console.log('=== DEBUG DATE ===');
			console.log('Date rÃ©cupÃ©rÃ©e du formulaire:', date);
			console.log('Type de la variable date:', typeof date);

    	    // Validation de base
    	    if (!date || !courseName || !defaultTee) {
        	alert('Veuillez remplir tous les champs obligatoires (date, terrain, dÃ©part par dÃ©faut).');
        	return;
    	    }
    
    	    var selectedPlayers = Object.keys(newRoundPlayers);
    	    if (selectedPlayers.length === 0) {
        	alert('Veuillez sÃ©lectionner au moins un joueur.');
        	return;
    	    }
    
    	    // VÃ©rifier que tous les joueurs ont un score
    	    var missingScores = [];
    	    for (var i = 0; i < selectedPlayers.length; i++) {
        	var playerId = parseInt(selectedPlayers[i]);
        	var playerScore = parseInt(document.getElementById('playerScore_' + playerId).value);
        	var player = players.find(p => p.id === playerId);
        	var playerName = player.name || (player.firstName + ' ' + player.lastName);
        
        	if (!playerScore) {
            	    missingScores.push(playerName);
        	}
    	    }
    
    	    if (missingScores.length > 0) {
        	if (!confirm('Les joueurs suivants n\'ont pas de score :\n' + missingScores.join(', ') + '\n\nContinuer quand mÃªme ?')) {
            	return;
        	}
    	    }
    
    	    // Confirmation finale
    	    if (!confirm('Enregistrer cette partie avec ' + selectedPlayers.length + ' joueur(s) ?')) {
        	return;
    	    }
    
    	    // Ajouter la nouvelle partie aux donnÃ©es
    	    var newRoundId = rounds.length + 1;
    	    // Solution simple : utiliser directement la date string
			var dateParts = date.split('-');
			var year = parseInt(dateParts[0]);
			var month = parseInt(dateParts[1]);
			var day = parseInt(dateParts[2]);

			// === AJOUTER CES LIGNES DE DEBUG ===
			console.log('Parties de date:', dateParts);
			console.log('AnnÃ©e:', year, 'Mois:', month, 'Jour:', day);

			// Pour l'affichage et le stockage, garder la date string originale
			var gameDate = new Date(year, month - 1, day);
    
			// === AJOUTER CETTE LIGNE DE DEBUG ===
			console.log('Date finale crÃ©Ã©e:', gameDate);
			console.log('Date qui sera stockÃ©e dans dates[]:', date);

    	    // RÃ©cupÃ©rer les mÃ©tadonnÃ©es GPR
			var gprPhase = '';
			var finaleFormat = '';
			var isGPRRound = false;

			if (roundType === 'gpr') {
    			isGPRRound = true;
    			gprPhase = document.getElementById('gprPhase').value;
    			finaleFormat = document.getElementById('finaleFormat').value;
			}

			// DÃ©terminer le type automatiquement si "amicale"
			var finalType = roundType;
			if (roundType === 'amicale') {
    			var isDiablo = (courseName === 'Le Diable' || courseName === 'Le GÃ©ant' || courseName === 'Manoir des Sables') || month === 9;
    			finalType = isDiablo ? 'diablo' : 'gpr';
			}
    
    	    // Ajouter aux rounds avec mÃ©tadonnÃ©es GPR
			var newRound = {
    			id: newRoundId,
    			date: date,
    			course: courseName,
    			tee: defaultTee,
    			type: finalType,
    			year: year,
    			month: month
			};

			// Ajouter les mÃ©tadonnÃ©es GPR si applicable
			if (isGPRRound) {
    			newRound.gprPhase = gprPhase;
    			newRound.gprFinaleFormat = finaleFormat;
			}

			rounds.push(newRound);

			// Sauvegarder les mÃ©tadonnÃ©es GPR sÃ©parÃ©ment
			if (isGPRRound) {
    			gprRoundsData.push({
        			roundId: newRoundId,
        			phase: gprPhase,
        			finaleFormat: finaleFormat,
        			date: date
    			});
			}
    
    	    // Ajouter aux dates et courses
    	    dates.push(date);
    	    courses.push(courseName);
    	    teeUsed.push(defaultTee);
    
    	    // Ã‰tendre allScores pour tous les joueurs
    	    for (var i = 0; i < allScores.length; i++) {
        	allScores[i].push(null);
    	    }
    
    	    // Ajouter les scores des joueurs participants
    	    var savedCount = 0;
    
    	    for (var i = 0; i < selectedPlayers.length; i++) {
        	var playerId = parseInt(selectedPlayers[i]);
        	var playerIndex = players.findIndex(p => p.id === playerId);
        	var playerScore = parseInt(document.getElementById('playerScore_' + playerId).value);
        	var playerTee = document.getElementById('playerTee_' + playerId).value || defaultTee;
        	var player = players.find(p => p.id === playerId);
        
        	if (playerIndex !== -1 && playerScore) {
            	    // Mettre le score dans allScores
            	    allScores[playerIndex][allScores[playerIndex].length - 1] = playerScore;
            
            	    // Ajouter aux scores calculÃ©s
            	    var courseHandicap = calculateCourseHandicap(player.handicap, courseName, playerTee);
            	    var netScore = playerScore - courseHandicap;
            	    var playerName = player.name || (player.firstName + ' ' + player.lastName);
            
            	    scores.push({
                	roundId: newRoundId,
                	playerId: playerId,
                	playerName: playerName,
                	score: playerScore,
                	courseHandicap: courseHandicap,
                	net: netScore,
                	tee: playerTee,
                	type: finalType,
                	year: year,
                	month: month
            	    });
            
            	    savedCount++;
        	}
    	    }
            
            // Sauvegarder dans Firebase
            Promise.all([
                saveScoresToFirebase(),
                saveDatesToFirebase()
            ]).then(function() {
                console.log('ğŸ”¥ TEST DEBUG - LIGNE JUSTE AVANT FIREBASE');
				console.log('Nouvelle partie sauvegardÃ©e dans Firebase');
            }).catch(function(error) {
                console.error('Erreur de sauvegarde partie:', error);
                alert('Erreur de sauvegarde: ' + error.message);
            });

    	    // Confirmation et nettoyage
    	    alert('âœ… Partie enregistrÃ©e avec succÃ¨s !\n' + savedCount + ' score(s) sauvegardÃ©(s).');
    
    	    resetNewRoundForm();
    
    	    // Optionnel : aller voir la partie dans les dÃ©tails
    	    if (confirm('Voulez-vous voir cette partie dans les dÃ©tails ?')) {
        	showDetails();
        	document.getElementById('roundSelect').value = newRoundId;
        	showRoundDetail();
    	    }
	}

	// RÃ©initialiser le formulaire
	function resetNewRoundForm() {
    	    document.getElementById('newRoundDate').value = new Date().toISOString().split('T')[0];
    	    document.getElementById('newRoundCourse').value = '';
    	    document.getElementById('newRoundDefaultTee').innerHTML = '<option value="">-- Choisir --</option>';
    	    document.getElementById('newRoundType').value = 'gpr';
    	    document.getElementById('newRoundPreview').style.display = 'none';
    
    	    clearAllPlayersForRound();
    	    loadPlayersScoreGrid();
	}

	// === FONCTIONS DE GESTION DES PARTIES ===

	// Supprimer une partie complÃ¨tement
	function deleteRound(roundId) {
    	if (!confirm('âš ï¸ ATTENTION ! Supprimer dÃ©finitivement cette partie ?\n\nCette action ne peut pas Ãªtre annulÃ©e.')) {
        	return;
    	}
    
    	console.log('Suppression de la partie ID:', roundId);
    
    	// Trouver l'index de la partie dans les arrays
    	var roundIndex = rounds.findIndex(r => r.id === roundId);
    	var dateIndex = roundIndex;
    
    	if (roundIndex === -1) {
        	alert('âŒ Partie non trouvÃ©e !');
        	return;
    	}
    
    	// Supprimer de rounds
    	rounds.splice(roundIndex, 1);
    
    	// Supprimer de dates, courses, teeUsed
    	if (dateIndex !== -1) {
        	dates.splice(dateIndex, 1);
        	courses.splice(dateIndex, 1);
        	teeUsed.splice(dateIndex, 1);
    	}
    
    	// Supprimer les scores de tous les joueurs pour cette partie
    	for (var i = 0; i < allScores.length; i++) {
        	if (allScores[i] && dateIndex !== -1) {
            	allScores[i].splice(dateIndex, 1);
        	}
    	}
    
    	// Supprimer de l'array scores
    	scores = scores.filter(s => s.roundId !== roundId);
    
    	// Supprimer des mÃ©tadonnÃ©es GPR
    	gprRoundsData = gprRoundsData.filter(g => g.roundId !== roundId);
    
    	// Sauvegarder dans Firebase
    	Promise.all([
        	saveScoresToFirebase(),
        	saveDatesToFirebase()
    	]).then(function() {
        	console.log('Partie supprimÃ©e de Firebase');
        	alert('âœ… Partie supprimÃ©e avec succÃ¨s !');
        
        	// RafraÃ®chir l'affichage
        	if (document.getElementById('details').style.display === 'block') {
            	loadDetails();
        	}
        	if (document.getElementById('gpr').style.display === 'block') {
            	loadGPR();
        	}
        	if (document.getElementById('diablo').style.display === 'block') {
            	loadDiablo();
        	}
        
    	}).catch(function(error) {
        	console.error('Erreur de suppression:', error);
        	alert('âŒ Erreur lors de la suppression: ' + error.message);
    	});
	}

	// Afficher le formulaire de modification d'une partie
	function editRound(roundId) {
    	var round = rounds.find(r => r.id === roundId);
    	if (!round) {
        	alert('âŒ Partie non trouvÃ©e !');
        	return;
    	}
    
    	// CrÃ©er la popup de modification
    	var formHtml = 
        	'<div style="position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.5); z-index: 1000; overflow-y: auto;">' +
        	'<div style="background: white; padding: 30px; margin: 50px auto; border-radius: 10px; box-shadow: 0 4px 20px rgba(0,0,0,0.3); max-width: 800px; width: 90%;">' +
        	'<h3 style="margin-top: 0; color: #2c5530;">âœï¸ Modifier la Partie</h3>' +
        
        	'<div style="margin: 15px 0;">' +
        	'<label style="display: block; font-weight: bold; margin-bottom: 5px;">Date:</label>' +
        	'<input type="date" id="editRoundDate" value="' + round.date + '" style="width: 200px; padding: 8px; border: 1px solid #ddd; border-radius: 4px;">' +
        	'</div>' +
        
        	'<div style="margin: 15px 0;">' +
        	'<label style="display: block; font-weight: bold; margin-bottom: 5px;">Terrain:</label>' +
        	'<select id="editRoundCourse" style="width: 300px; padding: 8px;">';
    
    	// Ajouter les options de terrains
    	var courseNames = Object.keys(coursesDatabase).sort();
    	for (var i = 0; i < courseNames.length; i++) {
        	var selected = courseNames[i] === round.course ? ' selected' : '';
			var courseName = courseNames[i].replace(/"/g, '&quot;');
			formHtml += '<option value="' + courseName + '"' + selected + '>' + courseNames[i] + '</option>';
    	}
    
    	formHtml += '</select></div>' +
        
        	'<div style="margin: 15px 0;">' +
        	'<label style="display: block; font-weight: bold; margin-bottom: 5px;">Type:</label>' +
        	'<select id="editRoundType" style="width: 200px; padding: 8px;" onchange="updateEditGPROptions()">' +
        	'<option value="gpr"' + (round.type === 'gpr' ? ' selected' : '') + '>ğŸ¯ GPR</option>' +
        	'<option value="diablo"' + (round.type === 'diablo' ? ' selected' : '') + '>ğŸ† Diablo</option>' +
        	'<option value="amicale"' + (round.type === 'amicale' ? ' selected' : '') + '>â›³ Amicale</option>' +
        	'</select>' +
        	'</div>' +
        
        	// Options GPR
        	'<div id="editGprOptions" style="display: ' + (round.type === 'gpr' ? 'block' : 'none') + '; margin: 15px 0; padding: 15px; background: #e7f3ff; border-radius: 8px;">' +
        	'<h4 style="margin-top: 0;">âš™ï¸ Configuration GPR</h4>' +
        	'<div style="margin: 10px 0;">' +
       		'<label style="display: block; font-weight: bold; margin-bottom: 5px;">Phase GPR:</label>' +
        	'<select id="editGprPhase" style="width: 200px; padding: 8px;" onchange="updateEditFinaleOptions()">' +
        	'<option value="exhibition"' + (round.gprPhase === 'exhibition' ? ' selected' : '') + '>ğŸ“Š Exhibition</option>' +
        	'<option value="finale"' + (round.gprPhase === 'finale' ? ' selected' : '') + '>ğŸ† Finale</option>' +
        	'</select>' +
        	'</div>' +
        	'<div id="editFinaleOptions" style="display: ' + (round.gprPhase === 'finale' ? 'block' : 'none') + '; margin: 10px 0;">' +
        	'<label style="display: block; font-weight: bold; margin-bottom: 5px;">Format finale:</label>' +
        	'<select id="editFinaleFormat" style="width: 200px; padding: 8px;">' +
        	'<option value="2days"' + (round.gprFinaleFormat === '2days' ? ' selected' : '') + '>ğŸ“… Finale 2 jours</option>' +
        	'<option value="1day"' + (round.gprFinaleFormat === '1day' ? ' selected' : '') + '>âš¡ Finale 1 jour</option>' +
        	'</select>' +
        	'</div>' +
        	'</div>' +
        
        	'<h4>ğŸ‘¥ Scores des Joueurs</h4>' +
        	'<div id="editPlayersScores" style="max-height: 300px; overflow-y: auto; border: 1px solid #ddd; padding: 15px; border-radius: 5px;">';
    
    	// Ajouter les scores des joueurs
    	var roundScores = scores.filter(s => s.roundId === roundId);
    	for (var i = 0; i < roundScores.length; i++) {
        	var score = roundScores[i];
        	formHtml += '<div style="display: flex; align-items: center; gap: 15px; margin: 10px 0; padding: 10px; background: #f8f9fa; border-radius: 5px;">' +
            	'<span style="width: 150px; font-weight: bold;">' + score.playerName + '</span>' +
            	'<label>Score: <input type="number" id="editScore_' + score.playerId + '" value="' + score.score + '" min="50" max="150" style="width: 80px; padding: 5px;"></label>' +
            	'<span style="font-size: 12px; color: #666;">Handicap: ' + score.courseHandicap.toFixed(1) + ' | Net: ' + score.net.toFixed(1) + '</span>' +
            	'</div>';
    	}
    
    	formHtml += '</div>' +
        
        	'<div style="margin-top: 25px; text-align: center;">' +
        	'<button onclick="saveRoundEdit(' + roundId + ')" style="background: #4a7c59; color: white; border: none; padding: 12px 24px; border-radius: 5px; margin: 5px; cursor: pointer; font-size: 16px;">ğŸ’¾ Sauvegarder</button>' +
        	'<button onclick="cancelRoundEdit()" style="background: #6c757d; color: white; border: none; padding: 12px 24px; border-radius: 5px; margin: 5px; cursor: pointer; font-size: 16px;">âŒ Annuler</button>' +
        	'<button onclick="deleteRound(' + roundId + ')" style="background: #dc3545; color: white; border: none; padding: 12px 24px; border-radius: 5px; margin: 5px; cursor: pointer; font-size: 16px;">ğŸ—‘ï¸ Supprimer</button>' +
        	'</div>' +
        
        	'</div></div>';
    
    	// Ajouter la popup au body
    	var popup = document.createElement('div');
    	popup.id = 'editRoundPopup';
    	popup.innerHTML = formHtml;
    	document.body.appendChild(popup);
	}

	// Fonctions auxiliaires pour la modification
	function updateEditGPROptions() {
    	var roundType = document.getElementById('editRoundType').value;
    	var gprOptions = document.getElementById('editGprOptions');
    
    	if (roundType === 'gpr') {
        	gprOptions.style.display = 'block';
    	} else {
        	gprOptions.style.display = 'none';
    	}
	}

	function updateEditFinaleOptions() {
    	var gprPhase = document.getElementById('editGprPhase').value;
    	var finaleOptions = document.getElementById('editFinaleOptions');
    
    	if (gprPhase === 'finale') {
        	finaleOptions.style.display = 'block';
    	} else {
        	finaleOptions.style.display = 'none';
    	}
	}

	// Sauvegarder les modifications
	function saveRoundEdit(roundId) {
    	var newDate = document.getElementById('editRoundDate').value;
    	var newCourse = document.getElementById('editRoundCourse').value;
    	var newType = document.getElementById('editRoundType').value;
    	var newGprPhase = document.getElementById('editGprPhase').value;
    	var newFinaleFormat = document.getElementById('editFinaleFormat').value;
    
    	if (!confirm('Sauvegarder les modifications de cette partie ?')) {
        	return;
    	}
    
    	// Mettre Ã  jour l'objet round
    	var round = rounds.find(r => r.id === roundId);
    	var roundIndex = rounds.findIndex(r => r.id === roundId);
    	var dateIndex = roundIndex;
    
    	if (round && roundIndex !== -1) {
        	// Mettre Ã  jour les donnÃ©es de base
        	round.date = newDate;
        	round.course = newCourse;
        	round.type = newType;
        
        	if (newType === 'gpr') {
            	round.gprPhase = newGprPhase;
            	round.gprFinaleFormat = newFinaleFormat;
        	}
        
        	// Mettre Ã  jour les arrays parallÃ¨les (utiliser roundIndex au lieu de dateIndex)
			if (roundIndex !== -1) {
    			dates[roundIndex] = newDate;
    			courses[roundIndex] = newCourse;
    			// Garder le mÃªme tee pour simplicitÃ©, ou ajouter une option pour le modifier
			}
        
        	// Mettre Ã  jour les scores des joueurs
        	var roundScores = scores.filter(s => s.roundId === roundId);
        	for (var i = 0; i < roundScores.length; i++) {
            	var score = roundScores[i];
            	var newScore = parseInt(document.getElementById('editScore_' + score.playerId).value);
            
            	if (newScore && newScore !== score.score) {
                	// Recalculer le handicap de parcours et le net
                	var player = players.find(p => p.id === score.playerId);
                	var teeForPlayer = (score.playerId === 1) ? 'bleu' : 'blanc'; // Logique simplifiÃ©e
                	var courseHandicap = calculateCourseHandicap(player.handicap, newCourse, teeForPlayer);
                	var netScore = newScore - courseHandicap;
                
                	// Mettre Ã  jour le score
                	score.score = newScore;
                	score.net = netScore;
                	score.courseHandicap = courseHandicap;
                
                	// Mettre Ã  jour allScores
                	var playerIndex = players.findIndex(p => p.id === score.playerId);
                	if (playerIndex !== -1 && dateIndex !== -1) {
                    	allScores[playerIndex][dateIndex] = newScore;
                	}
            	}
        	}
        
        	// Sauvegarder dans Firebase
        	Promise.all([
            	saveScoresToFirebase(),
            	saveDatesToFirebase()
        	]).then(function() {
            	console.log('Modifications sauvegardÃ©es dans Firebase');
            	alert('âœ… Partie modifiÃ©e avec succÃ¨s !');
            	cancelRoundEdit();
            
            	// RafraÃ®chir l'affichage
            	if (document.getElementById('details').style.display === 'block') {
                	loadDetails();
                	document.getElementById('roundSelect').value = roundId;
                	showRoundDetail();
            	}
            
        	}).catch(function(error) {
            	console.error('Erreur de modification:', error);
            	alert('âŒ Erreur lors de la modification: ' + error.message);
        	});
    	}
	}

	// Fermer la popup de modification
	function cancelRoundEdit() {
    	var popup = document.getElementById('editRoundPopup');
    	if (popup) {
        	popup.remove();
    	}
	}

	// Fonction pour gÃ©nÃ©rer des scores de test
	function generateTestRound() {
    	if (!confirm('GÃ©nÃ©rer une partie de test avec des scores alÃ©atoires ?')) {
        	return;
    	}
    
    	// SÃ©lectionner un terrain au hasard
    	var courseNames = Object.keys(coursesDatabase);
    	var randomCourse = courseNames[Math.floor(Math.random() * courseNames.length)];
    
    	// Date d'aujourd'hui
    	var today = new Date().toISOString().split('T')[0];
    
    	// SÃ©lectionner 6-8 joueurs actifs au hasard
    	var activePlayers = players.filter(p => p.active);
    	var numPlayers = Math.floor(Math.random() * 3) + 6; // 6 Ã  8 joueurs
    	var selectedPlayers = [];
    
    	for (var i = 0; i < Math.min(numPlayers, activePlayers.length); i++) {
        	var randomIndex = Math.floor(Math.random() * activePlayers.length);
        	var player = activePlayers[randomIndex];
        	if (selectedPlayers.findIndex(p => p.id === player.id) === -1) {
            	selectedPlayers.push(player);
        	}
    	}
    
    	// GÃ©nÃ©rer les scores (par + handicap Â± variation alÃ©atoire)
    	var newRoundId = rounds.length + 1;
    	var year = parseInt(today.split('-')[0]);
    	var month = parseInt(today.split('-')[1]);
    
    	// Ajouter la partie
    	rounds.push({
        	id: newRoundId,
        	date: today,
        	course: randomCourse,
        	tee: 'blanc',
        	type: 'gpr',
        	year: year,
        	month: month
    	});
    
    	dates.push(today);
    	courses.push(randomCourse);
    	teeUsed.push('blanc');
    
    	// Ã‰tendre allScores
    	for (var i = 0; i < allScores.length; i++) {
        	allScores[i].push(null);
    	}
    
    	// GÃ©nÃ©rer les scores
    	for (var i = 0; i < selectedPlayers.length; i++) {
        	var player = selectedPlayers[i];
        	var playerIndex = players.findIndex(p => p.id === player.id);
        
        	// Score = 72 (par moyen) + handicap + variation (-5 Ã  +10)
        	var baseScore = 72 + player.handicap;
        	var variation = Math.floor(Math.random() * 16) - 5; // -5 Ã  +10
        	var testScore = Math.max(65, Math.min(120, Math.round(baseScore + variation)));
        
        	// Sauvegarder le score
        	allScores[playerIndex][allScores[playerIndex].length - 1] = testScore;
        
        	// Calculer handicap de parcours et net
        	var teeForPlayer = (player.id === 1) ? 'blanc' : 'blanc';
        	var courseHandicap = calculateCourseHandicap(player.handicap, randomCourse, teeForPlayer);
        	var netScore = testScore - courseHandicap;
        	var playerName = player.name || (player.firstName + ' ' + player.lastName);
        
        	scores.push({
            	roundId: newRoundId,
            	playerId: player.id,
            	playerName: playerName,
            	score: testScore,
            	courseHandicap: courseHandicap,
            	net: netScore,
            	tee: teeForPlayer,
            	type: 'gpr',
            	year: year,
            	month: month
        	});
    	}
    
    	// Sauvegarder
    	Promise.all([
        	saveScoresToFirebase(),
        	saveDatesToFirebase()
    	]).then(function() {
        	alert('âœ… Partie de test gÃ©nÃ©rÃ©e avec ' + selectedPlayers.length + ' joueurs !\nTerrain: ' + randomCourse);
        
        	// Aller voir la partie
        	showDetails();
        	loadDetails();
        	document.getElementById('roundSelect').value = newRoundId;
        	showRoundDetail();
        
    	}).catch(function(error) {
        	console.error('Erreur gÃ©nÃ©ration test:', error);
        	alert('âŒ Erreur: ' + error.message);
    	});
	}
	// Nouvelles fonctions pour le systÃ¨me GPR

	// Afficher/masquer les options GPR
	function updateGPROptions() {
   		console.log('updateGPROptions appelÃ©e'); // Pour debug
    	var roundType = document.getElementById('newRoundType').value;
    	var gprOptions = document.getElementById('gprOptions');
    
    	console.log('Type sÃ©lectionnÃ©:', roundType); // Pour debug
    
    	if (roundType === 'gpr') {
        	gprOptions.style.display = 'block';
        	console.log('Options GPR affichÃ©es'); // Pour debug
    	} else {
        	gprOptions.style.display = 'none';
        	console.log('Options GPR masquÃ©es'); // Pour debug
    	}
	}

	// Afficher/masquer les options de finale
	function updateFinaleOptions() {
    	var gprPhase = document.getElementById('gprPhase').value;
    	var finaleOptions = document.getElementById('finaleOptions');
    
    	if (gprPhase === 'finale') {
        	finaleOptions.style.display = 'block';
    	} else {
        	finaleOptions.style.display = 'none';
    	}
	}

	// Calculer les points GPR selon les nouvelles rÃ¨gles
	function calculateGPRPoints(position, isNet, isFinale, finaleFormat) {
    	// Points exhibition
    	var exhibitionBrutPoints = [80, 68, 60, 52, 45, 40, 35, 30, 25, 20, 15, 10];
    	var exhibitionNetPoints = [120, 105, 90, 78, 70, 62, 54, 46, 38, 30, 22, 15];
    
    	// Points finale (base pour 2 jours - 200 points par jour)
    	var finaleBrutPoints = [175, 140, 120, 100, 85, 70, 60, 50, 40, 30, 20, 10];
    	var finaleNetPoints = [225, 190, 165, 140, 125, 110, 90, 75, 60, 45, 35, 25];
    
    	var points;
    
    	if (isFinale) {
        	points = isNet ? finaleNetPoints : finaleBrutPoints;
        	// Finale 1 jour = mÃªme distribution que 2 jours (400 points total)
        	// Pas besoin de doubler, les points sont dÃ©jÃ  corrects pour 400 total
    	} else {
        	points = isNet ? exhibitionNetPoints : exhibitionBrutPoints;
    	}
    
    	// Position est 1-indexÃ©e, tableau est 0-indexÃ©
    	return points[Math.min(position - 1, points.length - 1)] || 0;
	}

	// Exclure Ã‰ric Gosselin (ID 12) du pointage GPR
	function isEricGosselin(playerId) {
    	return playerId === 13;
	}

	// Variables globales pour le calendrier
	var calendarEvents = [];
	var teeTimeCounter = 1;

	// Fonction pour afficher le calendrier
	function showCalendar() {
    	console.log('showCalendar() appelÃ©e'); // Debug
		hideAllSections();

		var calendarSection = document.getElementById('calendar');
    	console.log('Section calendar trouvÃ©e:', calendarSection); // Debug
    
    	if (calendarSection) {
        	calendarSection.style.display = 'block';
        	console.log('Calendar display dÃ©fini Ã  block'); // Debug
    	} else {
        	console.error('Section calendar non trouvÃ©e!');
        	return;
    	}
    
    	setActiveButton('showCalendar');
    
    	console.log('Avant loadCalendarData()'); // AJOUTER
    	loadCalendarData();
    	console.log('AprÃ¨s loadCalendarData()'); // AJOUTER
    
    	console.log('Avant showMonthView()'); // AJOUTER
    	showMonthView();
    	console.log('AprÃ¨s showMonthView()'); // AJOUTER
	}

	// Charger les donnÃ©es du calendrier depuis Firebase
	function showCalendar() {
    	console.log('showCalendar() appelÃ©e');
    
    	hideAllSections();
    
    	var calendarSection = document.getElementById('calendar');
    	if (calendarSection) {
        	calendarSection.style.display = 'block';
    	}
    
    	setActiveButton('showCalendar');
    
    	// Initialiser avec un tableau vide pour l'instant
    	calendarEvents = [];
    
    	// Afficher directement la vue mensuelle
    	showMonthView();
	}

	// Sauvegarder les Ã©vÃ©nements dans Firebase
	function saveCalendarToFirebase() {
    	return database.ref('calendarEvents').set(calendarEvents);
	}

	// Afficher le formulaire d'ajout
	function showAddEvent() {
    	var form = document.getElementById('addEventForm');
    	form.style.display = form.style.display === 'none' ? 'block' : 'none';
    
    	if (form.style.display === 'block') {
        	// Initialiser le formulaire
        	document.getElementById('eventDate').value = '';
        	document.getElementById('eventComments').value = '';
        
        	// Charger les terrains
        	loadEventCourseOptions();
        
        	// Charger les joueurs comme organisateurs potentiels
        	loadOrganizerOptions();
        
        	// RÃ©initialiser les heures de dÃ©part
        	teeTimeCounter = 1;
        	document.getElementById('teeTimesList').innerHTML = '';
        	addTeeTime(); // Ajouter une premiÃ¨re heure par dÃ©faut
    	}
	}

	// Charger les options de terrains
	function loadEventCourseOptions() {
    	var select = document.getElementById('eventCourse');
    	select.innerHTML = '<option value="">-- SÃ©lectionner un terrain --</option>';
    
    	var courseNames = Object.keys(coursesDatabase).sort();
    	for (var i = 0; i < courseNames.length; i++) {
        	var option = document.createElement('option');
        	option.value = courseNames[i];
        	option.textContent = courseNames[i];
        	select.appendChild(option);
    	}
	}

	// Charger les options d'organisateurs
	function loadOrganizerOptions() {
    	var select = document.getElementById('eventOrganizer');
    	select.innerHTML = '<option value="">-- SÃ©lectionner --</option>';
    
    	for (var i = 0; i < players.length; i++) {
        	var player = players[i];
        	if (player.active) {
            	var option = document.createElement('option');
            	option.value = player.id;
            	option.textContent = player.name || (player.firstName + ' ' + player.lastName);
            	select.appendChild(option);
        	}
    	}
	}

	// Ajouter une heure de dÃ©part
	function addTeeTime() {
    	var container = document.getElementById('teeTimesList');
    	var teeTimeId = 'teeTime_' + teeTimeCounter;
    
    	var html = '<div class="tee-time-item" id="' + teeTimeId + '">' +
        	       '<div style="flex: 1;">' +
            	   '<label style="font-weight: bold;">DÃ©part #' + teeTimeCounter + ':</label>' +
            	   '<input type="time" id="time_' + teeTimeId + '" style="margin: 0 10px;">' +
            	   '<button class="btn-danger" onclick="removeTeeTime(\'' + teeTimeId + '\')">âŒ</button>' +
            	   '</div>' +
            	   '</div>' +
            	   '<div class="foursome-slot" id="foursome_' + teeTimeId + '">' +
            	   '<select class="player-slot" id="p1_' + teeTimeId + '">' +
            	   '<option value="">Joueur 1</option>' +
            	   '</select>' +
            	   '<select class="player-slot" id="p2_' + teeTimeId + '">' +
            	   '<option value="">Joueur 2</option>' +
            	   '</select>' +
            	   '<select class="player-slot" id="p3_' + teeTimeId + '">' +
            	   '<option value="">Joueur 3</option>' +
            	   '</select>' +
            	   '<select class="player-slot" id="p4_' + teeTimeId + '">' +
            	   '<option value="">Joueur 4</option>' +
            	   '</select>' +
            	   '</div>';
    
    	// CrÃ©er un div temporaire
    	var tempDiv = document.createElement('div');
    	tempDiv.innerHTML = html;
    	container.appendChild(tempDiv);
    
    	// Remplir les selects avec les joueurs
    	for (var slot = 1; slot <= 4; slot++) {
        	var select = document.getElementById('p' + slot + '_' + teeTimeId);
        	for (var i = 0; i < players.length; i++) {
            	var player = players[i];
            	if (player.active) {
                	var option = document.createElement('option');
                	option.value = player.id;
                	option.textContent = player.name || (player.firstName + ' ' + player.lastName);
                	select.appendChild(option);
            	}
        	}
    	}
    
    	teeTimeCounter++;
	}

	// Supprimer une heure de dÃ©part
	function removeTeeTime(teeTimeId) {
    	var element = document.getElementById(teeTimeId);
    	if (element && element.parentElement) {
        	element.parentElement.remove();
    	}
	}

	// Sauvegarder l'Ã©vÃ©nement
	function saveEvent() {
    	var date = document.getElementById('eventDate').value;
    	var course = document.getElementById('eventCourse').value;
    	var type = document.getElementById('eventType').value;
    	var organizerId = document.getElementById('eventOrganizer').value;
    	var comments = document.getElementById('eventComments').value;
    
    	if (!date || !course) {
        	alert('Veuillez remplir au moins la date et le terrain.');
        	return;
    	}
    
    	// Collecter les heures de dÃ©part
    	var teeTimes = [];
    	var teeTimeElements = document.querySelectorAll('[id^="teeTime_"]');
    
    	for (var i = 0; i < teeTimeElements.length; i++) {
        	var teeTimeId = teeTimeElements[i].id;
        	var time = document.getElementById('time_' + teeTimeId).value;
        
        	if (time) {
            	var foursome = [];
            	for (var slot = 1; slot <= 4; slot++) {
                	var playerId = document.getElementById('p' + slot + '_' + teeTimeId).value;
                	if (playerId) {
                    	foursome.push(parseInt(playerId));
                	}
            	}
            
            	teeTimes.push({
                	time: time,
                	players: foursome
            	});
        	}
    	}
    
    	// CrÃ©er l'Ã©vÃ©nement
    	var newEvent = {
        	id: Date.now(), // ID unique basÃ© sur timestamp
        	date: date,
        	course: course,
        	type: type,
        	organizerId: organizerId ? parseInt(organizerId) : null,
        	organizerName: organizerId ? getPlayerName(parseInt(organizerId)) : 'Non dÃ©fini',
        	teeTimes: teeTimes,
        	comments: comments,
        	createdAt: new Date().toISOString(),
        	createdBy: 'current_user' // Ã€ remplacer par l'utilisateur actuel
    	};
    
    	calendarEvents.push(newEvent);
    
    	// Sauvegarder dans Firebase
    	saveCalendarToFirebase().then(function() {
        	alert('âœ… Partie planifiÃ©e avec succÃ¨s!');
        	showAddEvent(); // Fermer le formulaire
        	refreshCalendarView();
    	}).catch(function(error) {
        	alert('âŒ Erreur: ' + error.message);
    	});
	}

	// Sauvegarder et notifier
	function saveAndNotify() {
    	saveEvent();
    	// Ici, on ajoutera la logique de notification push
    	alert('ğŸ“¢ Notifications envoyÃ©es aux joueurs!');
	}

	// Vue mensuelle du calendrier
	function showMonthView() {
    	var calendarViewElement = document.getElementById('calendarView');
    
    	if (!calendarViewElement) {
        	console.error('Element calendarView non trouvÃ©!');
        	return;
    	}
    
    	var today = new Date();
    	var currentMonth = today.getMonth();
    	var currentYear = today.getFullYear();
    
    	var html = '<div style="text-align: center; margin-bottom: 20px;">' +
        	       '<button onclick="changeMonth(-1)">â—€</button>' +
            	   '<span style="font-size: 20px; margin: 0 20px; font-weight: bold;">' +
            	   getMonthName(currentMonth) + ' ' + currentYear +
            	   '</span>' +
            	   '<button onclick="changeMonth(1)">â–¶</button>' +
            	   '</div>';
    
    	html += '<div class="calendar-grid">';
    
    	// En-tÃªtes des jours
    	var days = ['Dim', 'Lun', 'Mar', 'Mer', 'Jeu', 'Ven', 'Sam'];
    	for (var i = 0; i < days.length; i++) {
        	html += '<div class="calendar-header">' + days[i] + '</div>';
    	}
    
    	// Jours du mois
    	var firstDay = new Date(currentYear, currentMonth, 1).getDay();
    	var daysInMonth = new Date(currentYear, currentMonth + 1, 0).getDate();
    
    	// Jours vides au dÃ©but
    	for (var i = 0; i < firstDay; i++) {
        	html += '<div class="calendar-day" style="background: #f9f9f9;"></div>';
    	}
    
    	// Jours du mois
    	for (var day = 1; day <= daysInMonth; day++) {
        	html += '<div class="calendar-day">' +
            	    '<div class="calendar-day-number">' + day + '</div>' +
                	'</div>';
    	}
    
    	html += '</div>';
    
    	calendarViewElement.innerHTML = html;
	}

	function getMonthName(month) {
    	var months = ['Janvier', 'FÃ©vrier', 'Mars', 'Avril', 'Mai', 'Juin',
        	          'Juillet', 'AoÃ»t', 'Septembre', 'Octobre', 'Novembre', 'DÃ©cembre'];
    	return months[month];
	}
	
	// Vue liste
	function showListView() {
    	var futureEvents = calendarEvents.filter(e => new Date(e.date) >= new Date())
        	                             .sort((a, b) => new Date(a.date) - new Date(b.date));
    
    	var html = '<h3>ğŸ“… Prochaines Parties</h3>';
    
    	if (futureEvents.length === 0) {
        	html += '<p style="text-align: center; color: #666;">Aucune partie planifiÃ©e</p>';
    	} else {
        	html += '<div style="max-height: 500px; overflow-y: auto;">';
        
        	for (var i = 0; i < futureEvents.length; i++) {
            	var event = futureEvents[i];
            	var eventDate = new Date(event.date);
            	var dateStr = eventDate.toLocaleDateString('fr-FR', {
            	    weekday: 'long',
                	year: 'numeric',
                	month: 'long',
                	day: 'numeric'
            	});
            
            	html += '<div class="card" style="margin: 10px 0; cursor: pointer;" onclick="showEventDetail(' + event.id + ')">' +
                	    '<div style="display: flex; justify-content: space-between; align-items: center;">' +
                	    '<div>' +
                	    '<h4 style="margin: 0;">' + getEventIcon(event.type) + ' ' + dateStr + '</h4>' +
                	    '<p style="margin: 5px 0;"><strong>' + event.course + '</strong></p>' +
                	    '<small>OrganisÃ© par: ' + event.organizerName + '</small>' +
                	    '</div>' +
                	    '<div style="text-align: right;">' +
                	    '<strong>' + event.teeTimes.length + ' dÃ©part(s)</strong><br>' +
                	    '<small>Premier: ' + (event.teeTimes[0] ? event.teeTimes[0].time : 'N/A') + '</small>' +
                	    '</div>' +
                	    '</div>';
            
            	if (event.comments) {
                	html += '<div style="margin-top: 10px; padding: 10px; background: #f8f9fa; border-radius: 5px;">' +
                    	    '<small>' + event.comments + '</small>' +
                        	'</div>';
            	}
            
            	html += '</div>';
        	}
        
        	html += '</div>';
    	}
    
    	document.getElementById('calendarView').innerHTML = html;
	}

	// Afficher les dÃ©tails d'un Ã©vÃ©nement
	function showEventDetail(eventId) {
    	var event = calendarEvents.find(e => e.id === eventId);
    	if (!event) return;
    
    	var html = '<div class="event-detail-overlay" onclick="closeEventDetail()"></div>' +
        	       '<div class="event-detail-popup">' +
            	   '<h3>' + getEventIcon(event.type) + ' ' + new Date(event.date).toLocaleDateString('fr-FR') + '</h3>' +
            	   '<p><strong>Terrain:</strong> ' + event.course + '</p>' +
            	   '<p><strong>Organisateur:</strong> ' + event.organizerName + '</p>';
    
    	if (event.comments) {
        	html += '<div style="background: #f8f9fa; padding: 10px; border-radius: 5px; margin: 15px 0;">' +
            	    '<strong>Notes:</strong><br>' + event.comments +
                	'</div>';
    	}
    
    	html += '<h4>â° Heures de DÃ©part</h4>';
    
    	for (var i = 0; i < event.teeTimes.length; i++) {
        	var teeTime = event.teeTimes[i];
        	html += '<div style="margin: 10px 0; padding: 10px; background: #e8f5e8; border-radius: 5px;">' +
            	    '<strong>ğŸ•’ ' + teeTime.time + '</strong>' +
                	'<div style="display: grid; grid-template-columns: repeat(2, 1fr); gap: 10px; margin-top: 10px;">';
        
        	for (var j = 0; j < teeTime.players.length; j++) {
            	var player = players.find(p => p.id === teeTime.players[j]);
            	var playerName = player ? (player.name || (player.firstName + ' ' + player.lastName)) : 'Joueur #' + teeTime.players[j];
            	html += '<div style="background: white; padding: 5px 10px; border-radius: 3px;">' +
                	    (j + 1) + '. ' + playerName +
                    	'</div>';
        	}
        
        	html += '</div></div>';
    	}
    
    	html += '<div style="text-align: center; margin-top: 20px;">' +
        	    '<button class="btn" onclick="editEvent(' + eventId + ')">âœï¸ Modifier</button>' +
        	    '<button class="btn-danger" onclick="deleteEvent(' + eventId + ')">ğŸ—‘ï¸ Supprimer</button>' +
        	    '<button class="btn-secondary" onclick="closeEventDetail()">âŒ Fermer</button>' +
        	    '</div>' +
        	    '</div>';
    
    	// Ajouter Ã  la page
    	var detailDiv = document.createElement('div');
    	detailDiv.id = 'eventDetailPopup';
    	detailDiv.innerHTML = html;
    	document.body.appendChild(detailDiv);
	}

	// Fermer les dÃ©tails
	function closeEventDetail() {
    	var popup = document.getElementById('eventDetailPopup');
    	if (popup) {
        	popup.remove();
    	}
	}

	// Fonctions utilitaires
	function getEventIcon(type) {
    	switch(type) {
        	case 'gpr': return 'ğŸ¯';
        	case 'diablo': return 'ğŸ†';
        	case 'felton': return 'ğŸ†';
        	case 'doubled': return 'ğŸ¯';
        	default: return 'â›³';
    	}
	}

	function getMonthName(month) {
    	var months = ['Janvier', 'FÃ©vrier', 'Mars', 'Avril', 'Mai', 'Juin',
        	          'Juillet', 'AoÃ»t', 'Septembre', 'Octobre', 'Novembre', 'DÃ©cembre'];
    	return months[month];
	}

	function getPlayerName(playerId) {
    	var player = players.find(p => p.id === playerId);
    	return player ? (player.name || (player.firstName + ' ' + player.lastName)) : 'Inconnu';
	}

	function changeMonth(direction) {
    	// Ã€ implÃ©menter : navigation entre les mois
	}

	function cancelAddEvent() {
    	showAddEvent();
	}

	function refreshCalendarView() {
    	// RafraÃ®chir la vue actuelle
    	if (document.querySelector('.calendar-grid')) {
        	showMonthView();
    	} else {
        	showListView();
    	}
	}

	// Ajouter Ã  hideAllSections
	function hideAllSections() {
    	var sections = ['overview', 'playerScores', 'courses', 'diablo', 'gpr', 'felton', 'doubled', 'progress', 'details', 'handicapEvolution', 'playerManagement', 'addRound', 'calendar'];
    	for (var i = 0; i < sections.length; i++) {
        	var element = document.getElementById(sections[i]);
        	if (element) {
            	element.style.display = 'none';
        	}
    	}
	}

    // Initialisation au chargement
    window.onload = function() {
        // Charger les donnÃ©es depuis Firebase
        loadDataFromFirebase();
	}
	
</script>
</body>
</html>