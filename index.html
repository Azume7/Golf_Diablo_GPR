<!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Gestion Tournois Golf - Scores D√©taill√©s</title>
    <!-- Firebase SDKs -->
	<script src="https://www.gstatic.com/firebasejs/9.22.0/firebase-app-compat.js"></script>
	<script src="https://www.gstatic.com/firebasejs/9.22.0/firebase-database-compat.js"></script>
	<style>
        body {
            font-family: Arial, sans-serif;
            background: #f0f0f0;
            margin: 0;
            padding: 20px;
        }
        .container {
            max-width: 1400px;
            margin: 0 auto;
            background: white;
            border-radius: 10px;
            padding: 30px;
            box-shadow: 0 4px 8px rgba(0,0,0,0.1);
        }
        h1 { color: #2c5530; text-align: center; margin-bottom: 30px; }
        .nav { text-align: center; margin-bottom: 30px; }
		.nav-row {
    		display: flex;
    		justify-content: center;
    		gap: 10px;
    		margin-bottom: 10px;
    		flex-wrap: wrap;
		}
		.nav-save {
    		display: flex;
    		justify-content: center;
    		margin-top: 15px;
		}
		.nav button {
    		color: white; border: none;
    		padding: 10px 20px; margin: 5px; border-radius: 5px; cursor: pointer;
    		font-size: 14px;
    		transition: all 0.3s ease;
		}
		.nav button:hover { 
    		transform: translateY(-2px);
    		box-shadow: 0 4px 8px rgba(0,0,0,0.2);
		}
		.nav button.active { 
    		box-shadow: 0 0 15px rgba(255,255,255,0.5);
    		font-weight: bold;
		}

		/* Couleurs des boutons */
		.nav-yellow { background: #f39c12; }
		.nav-yellow:hover { background: #e67e22; }
		.nav-purple { background: #9b59b6; }
		.nav-purple:hover { background: #8e44ad; }
		.nav-green { background: #27ae60; }
		.nav-green:hover { background: #229954; }
		.nav-blue { background: #3498db; }
		.nav-blue:hover { background: #2980b9; }
		.nav-save-btn { 
    		background: #e74c3c; 
    		font-weight: bold;
    		padding: 12px 30px;
    		font-size: 16px;
		}
		.nav-save-btn:hover { background: #c0392b; }
        .section { display: none; }
        .section.active { display: block; }
        .btn {
            background: #4a7c59; color: white; border: none;
            padding: 10px 15px; border-radius: 5px; cursor: pointer; margin: 5px;
        }
        .btn:hover { background: #2c5530; }
        .btn-secondary {
            background: #6c757d; color: white; border: none;
            padding: 10px 15px; border-radius: 5px; cursor: pointer; margin: 5px;
        }
        .btn-danger {
            background: #dc3545; color: white; border: none;
            padding: 8px 12px; border-radius: 5px; cursor: pointer; margin: 5px;
        }
        .card {
            background: #f9f9f9; padding: 20px; margin: 15px 0;
            border-radius: 8px; border-left: 4px solid #4a7c59;
        }
        .table {
            width: 100%; border-collapse: collapse; margin: 20px 0;
        }
        .table th, .table td {
            border: 1px solid #ddd; padding: 8px; text-align: left;
        }
        .table th { background: #4a7c59; color: white; }
        .table tr:nth-child(even) { background: #f2f2f2; }
        .alert-success {
            background: #d4edda; color: #155724; border: 1px solid #c3e6cb;
            padding: 15px; margin: 15px 0; border-radius: 5px;
        }
        .alert-danger {
            background: #f8d7da; color: #721c24; border: 1px solid #f5c6cb;
            padding: 15px; margin: 15px 0; border-radius: 5px;
        }
        .form-row {
            margin: 10px 0;
        }
        .form-row label {
            display: inline-block;
            width: 150px;
            font-weight: bold;
        }
        .form-row input, .form-row select {
            padding: 8px;
            border: 1px solid #ddd;
            border-radius: 4px;
        }
        .player-card {
            background: #fff;
            border: 2px solid #4a7c59;
            border-radius: 10px;
            padding: 20px;
            margin: 15px 0;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }
        .player-stats {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 15px;
            margin-top: 15px;
        }
        .stat-box {
            background: #f8f9fa;
            padding: 15px;
            border-radius: 8px;
            text-align: center;
            border: 1px solid #e9ecef;
        }
        .stat-value {
            font-size: 24px;
            font-weight: bold;
            color: #2c5530;
        }
        .stat-label {
            font-size: 14px;
            color: #666;
            margin-top: 5px;
        }
        .score-history {
            max-height: 400px;
            overflow-y: auto;
            margin-top: 20px;
        }
        .score-row {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 10px;
            border-bottom: 1px solid #eee;
        }
        .score-row:nth-child(even) {
            background: #f8f9fa;
        }
        .best-score {
            color: #28a745;
            font-weight: bold;
        }
        .worst-score {
            color: #dc3545;
            font-weight: bold;
        }
        .tournament-badge {
            padding: 3px 8px;
            border-radius: 12px;
            font-size: 12px;
            font-weight: bold;
        }
        .badge-diablo {
            background: #ff6b6b;
            color: white;
        }
        .badge-gpr {
            background: #4ecdc4;
            color: white;
        }
        .course-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(350px, 1fr));
            gap: 20px;
            margin-top: 20px;
        }
        .course-card {
            background: white;
            border: 1px solid #ddd;
            border-radius: 8px;
            padding: 15px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }
        .course-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 10px;
        }
        .course-name {
            font-weight: bold;
            color: #2c5530;
            font-size: 16px;
        }
        .tee-info {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 8px;
            margin: 5px 0;
            background: #f8f9fa;
            border-radius: 5px;
            border-left: 4px solid #4a7c59;
        }
        .tee-color {
            font-weight: bold;
            padding: 2px 8px;
            border-radius: 10px;
            color: white;
            font-size: 12px;
        }
        .tee-blanc { background: #666; }
        .tee-bleu { background: #007bff; }
        .tee-vert { background: #28a745; }
        .tee-jaune { background: #ffc107; color: black; }
        .tee-noir { background: #000; }
        .add-course-form {
            background: #f8f9fa;
            padding: 20px;
            border-radius: 8px;
            border: 2px dashed #4a7c59;
            margin-top: 20px;
        }
        .tee-form-row {
            display: grid;
            grid-template-columns: 1fr 1fr 1fr 1fr auto;
            gap: 10px;
            align-items: center;
            margin: 10px 0;
        }
        .handicap-info {
            background: #e7f3ff;
            padding: 10px;
            border-radius: 5px;
            margin: 10px 0;
            font-size: 14px;
        }
		/* REMPLACEZ VOS STYLES CALENDRIER PAR CEUX-CI */

		.calendar-grid {
    		display: grid !important;
    		grid-template-columns: repeat(7, 1fr) !important;
    		gap: 2px !important;
    		border: 2px solid #333 !important;
    		background: #f8f9fa !important;
    		margin: 20px 0 !important;
    		padding: 5px !important;
    		min-height: 420px !important;
    		width: 100% !important;
    		box-sizing: border-box !important;
		}

		.calendar-header {
    		background: #2c5530 !important;
    		color: white !important;
    		padding: 12px 8px !important;
    		text-align: center !important;
    		font-weight: bold !important;
    		font-size: 14px !important;
    		border: 1px solid white !important;
    		min-height: 40px !important;
    		display: flex !important;
    		align-items: center !important;
    		justify-content: center !important;
		}

		.calendar-day {
    		background: white !important;
    		border: 1px solid #ddd !important;
    		min-height: 80px !important;
    		padding: 8px !important;
    		cursor: pointer !important;
    		position: relative !important;
    		display: block !important;
    		box-sizing: border-box !important;
		}

		.calendar-day:hover {
    		background: #f0f8ff !important;
		}

		.calendar-day-number {
    		font-weight: bold !important;
    		font-size: 16px !important;
    		color: #333 !important;
    		margin-bottom: 5px !important;
    		line-height: 1 !important;
		}

		.today {
    		background: #e8f5e8 !important;
    		border: 2px solid #4a7c59 !important;
		}

		.other-month {
    		background: #f9f9f9 !important;
    		color: #999 !important;
		}

		.other-month .calendar-day-number {
    		color: #999 !important;
		}

		.calendar-event {
    		background: #4a7c59 !important;
    		color: white !important;
    		padding: 2px 5px !important;
    		margin: 2px 0 !important;
    		border-radius: 3px !important;
    		font-size: 11px !important;
    		cursor: pointer !important;
    		overflow: hidden !important;
    		text-overflow: ellipsis !important;
    		white-space: nowrap !important;
		}

		.calendar-event:hover {
    		background: #2c5530 !important;
		}

		/* S'assurer que le conteneur parent ne limite pas la taille */
		#calendarView {
    		display: block !important;
    		width: 100% !important;
    		min-height: 500px !important;
    		overflow: visible !important;
		}

		#calendar {
    		display: none;
    		width: 100% !important;
		}

		#calendar.active {
    		display: block !important;
		}

        .nav-controls {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 20px;
            padding: 15px;
            background: #f8f9fa;
            border-radius: 8px;
        }

        .month-nav {
            display: flex;
            align-items: center;
            gap: 20px;
        }

        .month-nav button {
            background: #4a7c59;
            color: white;
            border: none;
            padding: 8px 15px;
            border-radius: 5px;
            cursor: pointer;
            font-size: 16px;
        }

        .month-nav button:hover {
            background: #2c5530;
        }

        .month-title {
            font-size: 24px;
            font-weight: bold;
            color: #2c5530;
            min-width: 200px;
            text-align: center;
        }

        .view-buttons {
            display: flex;
            gap: 10px;
        }

        .btn {
            background: #4a7c59;
            color: white;
            border: none;
            padding: 8px 15px;
            border-radius: 5px;
            cursor: pointer;
        }

        .btn:hover {
            background: #2c5530;
        }

        .btn-secondary {
            background: #6c757d;
        }

        .btn-secondary:hover {
            background: #5a6268;
        }

        .card {
            background: white;
            padding: 20px;
            margin: 15px 0;
            border-radius: 8px;
            border: 1px solid #ddd;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }

        .today {
            background: #e8f5e8 !important;
            border: 2px solid #4a7c59;
        }

        .other-month {
            background: #f9f9f9;
            color: #999;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>üèåÔ∏è GOLF DIABLO et GPR - Scores D√©taill√©s üèåÔ∏è</h1>
        
        <div class="nav">
            <!-- Premi√®re ligne -->
            <div class="nav-row">
                <button onclick="showAddRound()" class="nav-yellow">‚ûï Nouvelle Partie</button>
                <button onclick="showDiablo()" class="nav-purple">üèÜ Coupe Diablo</button>
                <button onclick="showOverview()" class="active nav-green">Vue d'ensemble</button>
                <button onclick="showPlayerScores()" class="nav-green">Scores par Joueur</button>
                <button onclick="showCourses()" class="nav-blue">üèåÔ∏è Terrains</button>
            </div>
            <!-- Deuxi√®me ligne -->
            <div class="nav-row">
                <button onclick="showProgress()" class="nav-yellow">üìä Progression</button>
                <button onclick="showGPR()" class="nav-purple">üéØ Coupe GPR</button>
                <button onclick="showHandicapEvolution()" class="nav-green">üìà √âvolution Handicaps</button>
                <button onclick="showDetails()" class="nav-green">üìã D√©tails</button>
                <button onclick="showPlayerManagement()" class="nav-blue">üë• Joueurs</button>
            </div>
            <!-- Bouton de sauvegarde centr√© -->
            <div class="nav-save">
                <button onclick="saveAllToFirebase()" class="nav-save-btn">üíæ Sauvegarder</button>
				<button onclick="showCalendar()" class="nav-blue">üìÖ Calendrier</button>
            </div>
        </div>

        <!-- Section Vue d'ensemble -->
        <div id="overview" class="section active">
            <div class="card">
                <h2>üìä Statistiques G√©n√©rales</h2>
                <div id="overviewStats"></div>
            </div>
        </div>

        <!-- Section Scores par Joueur -->
        <div id="playerScores" class="section">
            <div class="card">
                <h2>üë• S√©lectionner un Joueur</h2>
                <select id="playerSelect" style="width: 300px; padding: 10px;" onchange="showPlayerDetail()">
                    <option value="">-- Choisir un joueur --</option>
                </select>
            </div>
            <div id="playerDetail"></div>
        </div>

        <!-- Section Terrains -->
        <div id="courses" class="section">
            <div class="card">
                <h2>üèåÔ∏è Gestion des Terrains</h2>
                <p>Base de donn√©es compl√®te avec ratings et slopes pour le calcul des handicaps</p>
                <div class="handicap-info">
                    <strong>‚ÑπÔ∏è Calcul des Handicaps:</strong> Les handicaps de parcours sont calcul√©s avec la formule officielle compl√®te : 
                    <em>(Handicap Index √ó Slope Rating) √∑ 113 + (Course Rating - Par)</em>. 
                    <br>Rating = difficult√© pour un scratch, Slope = difficult√© relative, Par = nombre de coups de r√©f√©rence.
                </div>
                <button class="btn" onclick="toggleAddCourseForm()">‚ûï Ajouter un Terrain</button>
                <button class="btn-secondary" onclick="exportCourses()">üìÅ Exporter Terrains</button>
            </div>
            
            <div id="addCourseForm" class="add-course-form" style="display: none;">
                <h3>‚ûï Ajouter un Nouveau Terrain</h3>
                <div class="form-row">
                    <label>Nom du terrain:</label>
                    <input type="text" id="newCourseName" placeholder="Ex: Club de Golf Exemple" style="width: 300px;">
                </div>
                
                <h4>D√©parts disponibles:</h4>
                <div id="teeInputs">
                    <div class="tee-form-row">
                        <select>
                            <option value="blanc">Blanc</option>
                            <option value="bleu">Bleu</option>
                            <option value="vert">Vert</option>
                            <option value="jaune">Jaune</option>
                            <option value="noir">Noir</option>
                        </select>
                        <input type="number" placeholder="Rating (ex: 69.5)" step="0.1" min="60" max="80">
                        <input type="number" placeholder="Slope (ex: 123)" min="85" max="155">
                        <button type="button" class="btn-danger" onclick="removeTeeInput(this)">‚ùå</button>
                    </div>
                </div>
                
                <button class="btn-secondary" onclick="addTeeInput()">‚ûï Ajouter un D√©part</button>
                <br><br>
                <button class="btn" onclick="saveCourse()">üíæ Sauvegarder le Terrain</button>
                <button class="btn-secondary" onclick="cancelAddCourse()">‚ùå Annuler</button>
            </div>
            
            <div id="coursesList"></div>
        </div>

        <!-- Section Diablo -->
        <div id="diablo" class="section">
            <h2>üèÜ Coupe Diablo </h2>
            <div class="card">
                <label><strong>S√©lectionner l'ann√©e:</strong></label>
                <select id="diabloYearSelect" style="width: 150px; padding: 8px; margin: 0 10px;" onchange="loadDiablo()">
                    <option value="">-- Toutes les ann√©es --</option>
                </select>
                <span id="diabloStatus" style="margin-left: 20px; padding: 5px 10px; border-radius: 15px;"></span>
            </div>
            <div id="diabloContent"></div>
        </div>

        <!-- Section GPR -->
        <div id="gpr" class="section">
            <h2>üéØ Coupe GPR (Mai √† Juillet)</h2>
            <div class="card">
                <label><strong>S√©lectionner l'ann√©e:</strong></label>
                <select id="gprYearSelect" style="width: 150px; padding: 8px; margin: 0 10px;" onchange="loadGPR()">
                    <option value="">-- Toutes les ann√©es --</option>
                </select>
                <span id="gprStatus" style="margin-left: 20px; padding: 5px 10px; border-radius: 15px;"></span>
            </div>
            <div id="gprContent"></div>
        </div>

        <!-- Section Progression -->
        <div id="progress" class="section">
            <h2>üìà Progression des Coupes En Cours</h2>
            <div id="progressContent"></div>
        </div>

        <!-- Section D√©tails -->
        <div id="details" class="section">
            <h2>üìä D√©tails par Partie</h2>
            <div class="card">
                <select id="roundSelect" style="width: 100%; padding: 8px;" onchange="showRoundDetail()">
                    <button class="btn" onclick="generateTestRound()" style="margin-left: 10px;">üé≤ G√©n√©rer Partie Test</button>
					<option value="">-- S√©lectionner une partie --</option>
                </select>
            </div>
            <div id="detailsContent"></div>
        </div>
	
	<!-- Section √âvolution Handicaps -->
	<div id="handicapEvolution" class="section">
    	    <div class="card">
        	<h2>üìà √âvolution des Handicaps</h2>
        	<p>Suivez la progression des handicaps de chaque joueur au fil des parties</p>
        
        	<div style="margin: 20px 0;">
            	    <label><strong>S√©lectionner les joueurs √† comparer:</strong></label>
            	    <div id="playerCheckboxes" style="display: grid; grid-template-columns: repeat(auto-fit, minmax(200px, 1fr)); gap: 10px; margin: 15px 0;"></div>
            	    <button class="btn" onclick="updateHandicapChart()">üîÑ Mettre √† jour le graphique</button>
            	    <button class="btn-secondary" onclick="selectAllPlayers()">‚úÖ Tous</button>
            	    <button class="btn-secondary" onclick="clearAllPlayers()">‚ùå Aucun</button>
            	    <button class="btn-secondary" onclick="exportHandicapData()">üìä Exporter Donn√©es</button>
        	</div>
        
        	<div style="background: #f8f9fa; padding: 15px; border-radius: 8px; margin: 15px 0;">
            	    <strong>L√©gende:</strong>
            	    <span style="color: #28a745;">üü¢ Am√©lioration</span> |
            	    <span style="color: #dc3545;">üî¥ D√©gradation</span> |
            	    <span style="color: #6c757d;">‚ö™ Stable</span>
        	</div>
    	    </div>
    
    	    <div id="handicapChart" class="card">
        	<canvas id="handicapCanvas" width="1000" height="500" style="max-width: 100%; border: 1px solid #ddd; border-radius: 8px;"></canvas>
    	    </div>
    
    	    <div id="handicapStats" class="card"></div>
	</div>

	<!-- Section Gestion des Joueurs -->
	<div id="playerManagement" class="section">
    	    <div class="card">
        	<h2>üë• Gestion des Joueurs</h2>
        	<p>Ajouter, modifier et g√©rer les informations des joueurs</p>
        
        	<div style="margin: 20px 0;">
            	    <button class="btn" onclick="showAddPlayerForm()">‚ûï Ajouter un Joueur</button>
            	    <button class="btn-secondary" onclick="exportPlayersData()">üìÅ Exporter Liste</button>
            	    <button class="btn-secondary" onclick="importPlayersData()">üì• Importer Liste</button>
            	    <input type="file" id="importFile" accept=".json,.csv" style="display: none;" onchange="handleFileImport(event)">
        	</div>
        
        	<div id="addPlayerForm" class="add-course-form" style="display: none;">
            	    <h3>‚ûï Ajouter un Nouveau Joueur</h3>
            	    <div class="form-row">
                	<label>Pr√©nom:</label>
                	<input type="text" id="newPlayerFirstName" placeholder="Ex: Jean" style="width: 200px;">
            	    </div>
            	    <div class="form-row">
                	<label>Nom:</label>
                	<input type="text" id="newPlayerLastName" placeholder="Ex: Dupont" style="width: 200px;">
            	    </div>
            	    <div class="form-row">
                	<label>T√©l√©phone:</label>
                	<input type="tel" id="newPlayerPhone" placeholder="Ex: 514-555-1234" style="width: 200px;">
            	    </div>
            	    <div class="form-row">
                	<label>Courriel:</label>
                	<input type="email" id="newPlayerEmail" placeholder="Ex: jean.dupont@example.com" style="width: 300px;">
            	    </div>
            	    <div class="form-row">
                	<label>Handicap Initial:</label>
                	<input type="number" id="newPlayerHandicap" placeholder="Ex: 15.5" step="0.1" min="0" max="36.4" style="width: 100px;">
            	    </div>
            	    <div class="form-row">
                	<label>Date d'adh√©sion:</label>
                	<input type="date" id="newPlayerDateJoined" style="width: 200px;">
            	    </div>
            	    <br>
            	    <button class="btn" onclick="saveNewPlayer()">üíæ Sauvegarder</button>
            	    <button class="btn-secondary" onclick="cancelAddPlayer()">‚ùå Annuler</button>
        	</div>
    	    </div>
    
    	    <div id="playersGrid" class="course-grid"></div>
	</div>

	<!-- Section Ajouter une Partie -->
	<div id="addRound" class="section">
    	    <div class="card">
        	<h2>‚ûï Ajouter une Nouvelle Partie</h2>
        	<p>Enregistrer les scores d'une nouvelle partie de golf</p>
        
        	<!-- Informations de base de la partie -->
        	<div class="card" style="background: #f8f9fa;">
            	    <h3>üìÖ Informations de la Partie</h3>
            
            	    <div class="form-row">
                	<label>Date de la partie:</label>
                	<input type="date" id="newRoundDate" style="width: 200px;">
            	    </div>
            
            	    <div class="form-row">
                	<label>Terrain:</label>
                	<select id="newRoundCourse" style="width: 300px;" onchange="updateAvailableTees()">
                    	    <option value="">-- S√©lectionner un terrain --</option>
                	</select>
            	    </div>
            
            	    <div class="form-row">
                	<label>D√©part par d√©faut:</label>
                	<select id="newRoundDefaultTee" style="width: 150px;">
                    	    <option value="">-- Choisir --</option>
                	</select>
                	<small style="margin-left: 10px; color: #666;">Les joueurs peuvent avoir des d√©parts individuels</small>
            	    </div>
            
            	    <div class="form-row">
    					<label>Type de partie:</label>
    					<select id="newRoundType" style="width: 200px;" onchange="updateGPROptions()">
        					<option value="gpr">üéØ GPR (Mai-Juillet)</option>
        					<option value="diablo">üèÜ Diablo (Septembre)</option>
        					<option value="amicale">‚õ≥ Partie Amicale</option>
    					</select>
					</div>

					<!-- Nouvelles options GPR -->
					<div id="gprOptions" style="display: block; margin-top: 15px; padding: 15px; background: #e7f3ff; border-radius: 8px;">
    					<h4 style="margin-top: 0; color: #2c5530;">‚öôÔ∏è Configuration GPR</h4>
    
    					<div class="form-row">
        					<label>Phase GPR:</label>
        					<select id="gprPhase" style="width: 200px;" onchange="updateFinaleOptions()">
            					<option value="exhibition">üìä Partie d'Exhibition</option>
            					<option value="finale">üèÜ Partie de Finale</option>
        						</select>
    						</div>
    
    					<div id="finaleOptions" style="display: none; margin-top: 10px;">
        					<div class="form-row">
            					<label>Format finale:</label>
            					<select id="finaleFormat" style="width: 200px;">
                					<option value="2days">üìÖ Finale 2 jours (points r√©partis)</option>
                					<option value="1day">‚ö° Finale 1 jour (tous les points)</option>
            					</select>
        					</div>
    					</div>
    
    					<div style="margin-top: 15px; padding: 10px; background: #fff3cd; border-radius: 5px;">
        					<strong>‚ÑπÔ∏è Rappel :</strong> Si votre handicap est de 12 et moins, vous partez des bleus
    					</div>
					</div>
        	</div>
			<!-- S√©lection des joueurs et scores -->
        	<div class="card">
            	    <h3>üë• Joueurs et Scores</h3>
            	    <p>S√©lectionnez les joueurs pr√©sents et saisissez leurs scores</p>
            
            	    <div style="margin: 15px 0;">
                	<button class="btn-secondary" onclick="selectAllPlayersForRound()">‚úÖ Tous les joueurs</button>
                	<button class="btn-secondary" onclick="clearAllPlayersForRound()">‚ùå Aucun joueur</button>
                	<button class="btn-secondary" onclick="selectFrequentPlayers()">‚≠ê Joueurs fr√©quents</button>
            	    </div>
            
            	    <div id="playersScoreGrid" style="display: grid; grid-template-columns: repeat(auto-fit, minmax(350px, 1fr)); gap: 15px; margin-top: 20px;"></div>
        	</div>
        
        	<!-- Boutons d'action -->
        	<div class="card" style="text-align: center;">
            	    <button class="btn" onclick="saveNewRound()">üíæ Enregistrer la Partie</button>
            	    <button class="btn-secondary" onclick="previewNewRound()">üëÅÔ∏è Aper√ßu</button>
            	    <button class="btn-secondary" onclick="resetNewRoundForm()">üîÑ R√©initialiser</button>
        	</div>
        
        	<!-- Aper√ßu de la partie -->
        	<div id="newRoundPreview" class="card" style="display: none;">
            	    <h3>üëÅÔ∏è Aper√ßu de la Partie</h3>
            	    <div id="previewContent"></div>
        	</div>
    	    
	<!-- Section Calendrier - √Ä ajouter apr√®s la section addRound dans votre HTML -->
	<div id="calendar" class="section">
    	<div class="card">
    		<h2>üìÖ Calendrier des Parties</h2>
    		<p>Planifiez vos parties de golf et consultez les prochains √©v√©nements</p>
        
    		<!-- Navigation et contr√¥les -->
    		<div style="display: flex; justify-content: space-between; align-items: center; margin: 20px 0; padding: 15px; background: #f8f9fa; border-radius: 8px;">
       			<div style="display: flex; gap: 10px;">
           			<button class="btn" onclick="showAddEvent()">‚ûï Planifier une Partie</button>
           			<button class="btn-secondary" onclick="showListView()">üìã Vue Liste</button>
           			<button class="btn-secondary" onclick="showMonthView()">üìÖ Vue Calendrier</button>
       			</div>
            
       			<!-- Navigation mensuelle -->
       			<div style="display: flex; align-items: center; gap: 20px;">
           			<button class="btn-secondary" onclick="changeMonth(-1)">‚óÄ Pr√©c√©dent</button>
           			<div id="monthTitle" style="font-size: 20px; font-weight: bold; color: #2c5530; min-width: 180px; text-align: center;">
               			D√©cembre 2024
           			</div>
           			<button class="btn-secondary" onclick="changeMonth(1)">Suivant ‚ñ∂</button>
       			</div>
    		</div>

    		<!-- Formulaire d'ajout d'√©v√©nement -->
    		<div id="addEventForm" class="add-course-form" style="display: none;">
       			<h3>‚ûï Planifier une Nouvelle Partie</h3>
            
       			<div style="display: grid; grid-template-columns: 1fr 1fr; gap: 20px;">
           			<div>
               			<div class="form-row">
                   			<label>Date de la partie:</label>
                   			<input type="date" id="eventDate" style="width: 100%; padding: 8px;">
               			</div>
                    
               			<div class="form-row">
                   			<label>Terrain:</label>
                   			<select id="eventCourse" style="width: 100%; padding: 8px;">
                       			<option value="">-- S√©lectionner un terrain --</option>
                   			</select>
               			</div>
                    
               			<div class="form-row">
                   			<label>Type de partie:</label>
                   			<select id="eventType" style="width: 100%; padding: 8px;">
                       			<option value="amicale">‚õ≥ Partie Amicale</option>
                       			<option value="gpr">üéØ Coupe GPR</option>
                       			<option value="diablo">üèÜ Coupe Diablo</option>
                       			<option value="felton">üèÜ Coupe FelTon</option>
                       			<option value="doubled">üéØ Double D's Cup</option>
                   			</select>
               			</div>
                    
               			<div class="form-row">
                   			<label>Organisateur:</label>
                   			<select id="eventOrganizer" style="width: 100%; padding: 8px;">
                       			<option value="">-- S√©lectionner --</option>
                   			</select>
               			</div>
           			</div>
                
           			<div>
               			<div class="form-row">
                   			<label>Heures de d√©part:</label>
                   			<div id="teeTimesList" style="max-height: 200px; overflow-y: auto; border: 1px solid #ddd; padding: 10px; border-radius: 5px; background: white;">
                       			<!-- Les heures de d√©part seront ajout√©es ici -->
                   			</div>
                   			<button class="btn-secondary" onclick="addTeeTime()" style="margin-top: 10px;">‚ûï Ajouter une heure</button>
               			</div>
                    
               			<div class="form-row">
                   			<label>Commentaires/Notes:</label>
                   			<textarea id="eventComments" rows="4" style="width: 100%; padding: 8px;" 
                           			placeholder="Ex: Apportez vos balles, terrain difficile, souper apr√®s la partie..."></textarea>
               			</div>
           			</div>
       			</div>
            
       			<div style="text-align: center; margin-top: 20px;">
           			<button class="btn" onclick="saveEvent()">üíæ Enregistrer</button>
           			<button class="btn-secondary" onclick="cancelAddEvent()">‚ùå Annuler</button>
           			<button class="btn" onclick="saveAndNotify()" style="background: #e74c3c;">üì¢ Enregistrer et Notifier</button>
       			</div>
    		</div>
    	</div>
    
    	<!-- Vue du calendrier -->
    	<div id="calendarView" class="card">
    		<!-- Vide - sera rempli par JavaScript -->
		</div>
    
    	<!-- Vue liste -->
    	<div id="listView" class="card" style="display: none;">
        	<div style="text-align: center; padding: 50px; color: #666;">
        		<h3>üìã Vue Liste</h3>
        		<p>La liste des √©v√©nements va s'afficher ici</p>
        	</div>
    	</div>
	</div>

    <script>
		// Configuration Firebase
		const firebaseConfig = {
    		apiKey: "AIzaSyCHh6Fb-m18O-_1Ei6sTEdfnJMyNrSl590",
    		authDomain: "golf-scores-app-bba13.firebaseapp.com",
    		databaseURL: "https://golf-scores-app-bba13-default-rtdb.firebaseio.com",
    		projectId: "golf-scores-app-bba13",
    		storageBucket: "golf-scores-app-bba13.firebasestorage.app",
    		messagingSenderId: "170312505084",
    		appId: "1:170312505084:web:074ae5e6d9d74c70efa979"
		};

		// Initialiser Firebase
		firebase.initializeApp(firebaseConfig);
		const database = firebase.database();

		// √âtat de chargement
		var isDataLoaded = false;
		var loadingElement = null;

		// Fonction pour afficher le statut de chargement
		function showLoading(message) {
    		if (!loadingElement) {
        		loadingElement = document.createElement('div');
        		loadingElement.style.cssText = 'position: fixed; top: 50%; left: 50%; transform: translate(-50%, -50%); background: rgba(0,0,0,0.8); color: white; padding: 20px; border-radius: 10px; z-index: 9999;';
        		document.body.appendChild(loadingElement);
    		}
    		loadingElement.innerHTML = '<div style="text-align: center;"><div style="margin-bottom: 10px;">üîÑ</div>' + message + '</div>';
    		loadingElement.style.display = 'block';
		}

		function hideLoading() {
    		if (loadingElement) {
        		loadingElement.style.display = 'none';
    		}
		}

        // Base de donn√©es des terrains avec ratings, slopes et pars
        var coursesDatabase = {
            "Parcours de l'√Æle": [
                {tee: "blanc", rating: 68.6, slope: 122, par: 70},
                {tee: "bleu", rating: 70.9, slope: 127, par: 70}
            ],
            "Parcours de l'Irlande": [
                {tee: "blanc", rating: 69.4, slope: 126, par: 71},
                {tee: "bleu", rating: 72.2, slope: 131, par: 71}
            ],
            "Parcours Atlantide": [
                {tee: "blanc", rating: 68.6, slope: 126, par: 72},
                {tee: "bleu", rating: 70.2, slope: 132, par: 72}
            ],
            "Parcours Don Quichotte": [
                {tee: "blanc", rating: 65.9, slope: 113, par: 71},
                {tee: "bleu", rating: 68.4, slope: 117, par: 71}
            ],
            "Triangle D'Or": [
                {tee: "blanc", rating: 69.8, slope: 123, par: 72},
                {tee: "bleu", rating: 70.8, slope: 127, par: 72}
            ],
            "Hemmingford Parcours Fronti√®re": [
                {tee: "blanc", rating: 70.3, slope: 123, par: 71},
                {tee: "bleu", rating: 71.1, slope: 125, par: 71}
            ],
            "Vall√©e des Forts": [
                {tee: "blanc", rating: 70.2, slope: 127, par: 72},
                {tee: "bleu", rating: 71.9, slope: 135, par: 72}
            ],
            "St-Zotique": [
                {tee: "blanc", rating: 68, slope: 114, par: 72},
                {tee: "bleu", rating: 70.1, slope: 118, par: 72}
            ],
            "Parcours Le Pr√©sidentiel": [
                {tee: "blanc", rating: 69.7, slope: 118, par: 72},
                {tee: "bleu", rating: 71.5, slope: 123, par: 72}
            ],
            "Parcours Le Doral": [
                {tee: "blanc", rating: 70, slope: 124, par: 72},
                {tee: "bleu", rating: 71.7, slope: 128, par: 72}
            ],
            "Parcours Woodlands": [
                {tee: "blanc", rating: 68.7, slope: 116, par: 72},
                {tee: "bleu", rating: 70.1, slope: 119, par: 72}
            ],
            "Parcours Bellevue": [
                {tee: "blanc", rating: 69, slope: 115, par: 72},
                {tee: "bleu", rating: 70.3, slope: 118, par: 72}
            ],
            "Rivi√®re-Rouge": [
                {tee: "blanc", rating: 68.8, slope: 123, par: 71},
                {tee: "bleu", rating: 70.5, slope: 124, par: 71}
            ],
            "Les L√©gendes": [
                {tee: "blanc", rating: 70.8, slope: 118, par: 72},
                {tee: "bleu", rating: 72.3, slope: 126, par: 72}
            ],
            "La Seigneurie": [
                {tee: "blanc", rating: 68.5, slope: 123, par: 70},
                {tee: "bleu", rating: 69.5, slope: 126, par: 70}
            ],
            "Napierville": [
                {tee: "blanc", rating: 68.2, slope: 125, par: 72},
                {tee: "bleu", rating: 70.7, slope: 129, par: 72}
            ],
            "St-Polycarpe": [
                {tee: "blanc", rating: 66.8, slope: 118, par: 72},
                {tee: "bleu", rating: 71, slope: 125, par: 72}
            ],
            "Rive-Sud": [
                {tee: "blanc", rating: 71.2, slope: 124, par: 72},
                {tee: "bleu", rating: 72.4, slope: 127, par: 72}
            ],
            "Rivi√®re-Beaudette": [
                {tee: "blanc", rating: 69.2, slope: 117, par: 72},
                {tee: "bleu", rating: 70.6, slope: 120, par: 72}
            ],
            "Vaudreuil": [
                {tee: "blanc", rating: 66.5, slope: 108, par: 70},
                {tee: "bleu", rating: 68.2, slope: 112, par: 70}
            ],
            "Brocart": [
                {tee: "blanc", rating: 68, slope: 115, par: 72},
                {tee: "vert", rating: 69.4, slope: 118, par: 72},
                {tee: "jaune", rating: 69.4, slope: 118, par: 72}
            ],
            "Faon": [
                {tee: "vert", rating: 70.7, slope: 122, par: 71},
                {tee: "jaune", rating: 69.2, slope: 123, par: 71}
            ],
            "Beloeil": [
                {tee: "blanc", rating: 67.2, slope: 123, par: 71},
                {tee: "bleu", rating: 70, slope: 132, par: 71}
            ],
            "Golfdes√éles": [
                {tee: "blanc", rating: 66.5, slope: 110, par: 70},
                {tee: "bleu", rating: 68.5, slope: 115, par: 70}
            ],
            "St-C√©saire": [
                {tee: "blanc", rating: 70, slope: 122, par: 72},
                {tee: "bleu", rating: 70, slope: 122, par: 72}
            ],
            "Golf Cowansville": [
                {tee: "blanc", rating: 69.6, slope: 118, par: 72},
                {tee: "bleu", rating: 71, slope: 123, par: 72}
            ],
            "Ch√¢teau Bromont": [
                {tee: "blanc", rating: 69.3, slope: 123, par: 72},
                {tee: "bleu", rating: 69.8, slope: 116, par: 72}
            ],
            "Golf Coaticook": [
                {tee: "blanc", rating: 66.4, slope: 114, par: 71},
                {tee: "bleu", rating: 68, slope: 119, par: 71}
            ],
            "Golf Farnham": [
                {tee: "blanc", rating: 67.8, slope: 121, par: 71},
                {tee: "bleu", rating: 69.4, slope: 124, par: 71}
            ],
            "Milby": [
                {tee: "blanc", rating: 69.5, slope: 123, par: 73},
                {tee: "bleu", rating: 71.1, slope: 131, par: 73}
            ],
            "Manoir des Sables": [
                {tee: "blanc", rating: 69, slope: 118, par: 71},
                {tee: "bleu", rating: 69, slope: 123, par: 71}
            ],
            "Mont Orford": [
                {tee: "blanc", rating: 69, slope: 118, par: 72},
                {tee: "bleu", rating: 69, slope: 126, par: 72}
            ],
            "Royal Bromont": [
                {tee: "blanc", rating: 67, slope: 114, par: 72},
                {tee: "bleu", rating: 69.3, slope: 120, par: 72}
            ],
            "Parcours du Vieux Village": [
                {tee: "blanc", rating: 68.2, slope: 114, par: 72},
                {tee: "bleu", rating: 70.3, slope: 124, par: 72}
            ],
            "Royal Laurentien": [
                {tee: "blanc", rating: 66.2, slope: 115, par: 71},
                {tee: "bleu", rating: 68.6, slope: 121, par: 71}
            ],
            "Le Diable": [
                {tee: "blanc", rating: 69.9, slope: 126, par: 70},
                {tee: "bleu", rating: 72, slope: 131, par: 70}
            ],
            "Le G√©ant": [
                {tee: "vert", rating: 68, slope: 123, par: 72},
                {tee: "noir", rating: 70.4, slope: 125, par: 72}
            ],
            "Arundel": [
                {tee: "blanc", rating: 69.7, slope: 126, par: 72},
                {tee: "bleu", rating: 70.7, slope: 128, par: 72}
            ],
            "La Belle": [
                {tee: "blanc", rating: 68, slope: 121, par: 73},
                {tee: "bleu", rating: 69, slope: 124, par: 73}
            ],
            "Le Ma√Ætre": [
                {tee: "blanc", rating: 68.7, slope: 121, par: 72},
                {tee: "bleu", rating: 70.2, slope: 125, par: 72}
            ],
            "La B√™te": [
                {tee: "blanc", rating: 68.7, slope: 124, par: 72},
                {tee: "bleu", rating: 71.4, slope: 128, par: 72}
            ],
            "Lorraine": [
                {tee: "blanc", rating: 69.5, slope: 123, par: 72},
                {tee: "bleu", rating: 70.4, slope: 124, par: 72}
            ],
            "St-Jean limit√©": [
                {tee: "blanc", rating: 69.3, slope: 120, par: 72},
                {tee: "bleu", rating: 71.4, slope: 123, par: 72}
            ]
        };

        // 1. MODIFIER LE TABLEAU PLAYERS pour ajouter la propri√©t√© 'name' (REMPLACER VOTRE TABLEAU ACTUEL)
		var rounds = [];
		
		var players = [];

        // Donn√©es des parties avec d√©parts sp√©cifiques
        var dates = [
            '2023-06-03', '2023-06-10', '2023-07-01', '2023-07-02', '2023-09-01', '2023-09-02', '2023-09-03',
            '2024-05-04', '2024-05-18', '2024-05-25', '2024-06-08', '2024-06-15', '2024-06-29', '2024-06-30',
            '2024-09-06', '2024-09-07', '2024-09-08', '2025-05-03', '2025-05-17', '2025-06-07', '2025-06-14', '2025-06-21'
        ];

        var courses = [
            'Rivi√®re-Rouge', 'Hemmingford Parcours Fronti√®re', 'Parcours Don Quichotte', 'Parcours Don Quichotte',
            'Le Diable', 'Le G√©ant', 'Le G√©ant', 'Vaudreuil', 'Hemmingford Parcours Fronti√®re', 'Vall√©e des Forts',
            'Parcours Bellevue', 'Rivi√®re-Rouge', 'Parcours Don Quichotte', 'Parcours Don Quichotte',
            'Manoir des Sables', 'Manoir des Sables', 'Manoir des Sables', 'Vaudreuil', 'Hemmingford Parcours Fronti√®re',
            'Lorraine', 'Parcours Bellevue', 'St-Jean limit√©'
        ];

        // D√©parts utilis√©s pour chaque partie (Antonio = bleu pour certaines parties, sinon blanc pour tous)
        var teeUsed = [
            'blanc', 'blanc', 'blanc', 'bleu', 'blanc', 'blanc', 'blanc', 'bleu', 'bleu', 'bleu', 'bleu', 'bleu', 'bleu', 'bleu',
            'blanc', 'blanc', 'bleu', 'bleu', 'bleu', 'bleu', 'blanc', 'bleu'
        ];

        // Fonction pour calculer le handicap de parcours avec la formule compl√®te
        function calculateCourseHandicap(playerHandicapIndex, courseName, teeColor) {
            if (!coursesDatabase[courseName]) {
                console.warn('Terrain non trouv√©:', courseName);
                return playerHandicapIndex; // Fallback vers handicap fixe
            }
            
            var courseData = coursesDatabase[courseName];
            var teeData = courseData.find(t => t.tee === teeColor);
            
            if (!teeData) {
                // Si le d√©part sp√©cifique n'existe pas, prendre le premier disponible
                teeData = courseData[0];
                console.warn('D√©part', teeColor, 'non trouv√© pour', courseName, ', utilisation de', teeData.tee);
            }
            
            // Formule compl√®te: (Handicap Index √ó Slope Rating) √∑ 113 + (Course Rating - Par)
            var slopeAdjustment = (playerHandicapIndex * teeData.slope) / 113;
            var ratingAdjustment = teeData.rating - teeData.par;
            var courseHandicap = slopeAdjustment + ratingAdjustment;
            
            return Math.round(courseHandicap * 10) / 10; // Arrondir √† 1 d√©cimale
        }

	// Cache pour √©viter les recalculs r√©p√©t√©s
	var handicapCache = {};

    // Fonctions Firebase
    function savePlayersToFirebase() {
        return database.ref('players').set(players);
    }

    function saveScoresToFirebase() {
        return database.ref('allScores').set(allScores);
    }

    function saveCoursesToFirebase() {
        return database.ref('coursesDatabase').set(coursesDatabase);
    }

    function saveDatesToFirebase() {
        return database.ref('gameData').set({
            dates: dates,
            courses: courses,
            teeUsed: teeUsed
	    });
    }

	function saveRoundsToFirebase() {
    	// Nettoyer les propri√©t√©s undefined avant de sauvegarder
    	var cleanedRounds = rounds.map(function(round) {
        	var cleanRound = {
            	id: round.id,
            	date: round.date,
            	course: round.course,
            	tee: round.tee,
            	type: round.type,
            	year: round.year,
            	month: round.month
        	};
        
        	// Ajouter les propri√©t√©s GPR seulement si elles existent
        	if (round.gprPhase) {
            	cleanRound.gprPhase = round.gprPhase;
        	}
        	if (round.gprFinaleFormat) {
            	cleanRound.gprFinaleFormat = round.gprFinaleFormat;
        	}
        
        	return cleanRound;
   		});
    
    	return database.ref('rounds').set(cleanedRounds);
	}

    function loadDataFromFirebase() {
    	showLoading('Chargement des donn√©es...');

    	return Promise.all([
        	database.ref('players').once('value'),
        	database.ref('allScores').once('value'),
        	database.ref('coursesDatabase').once('value'),
        	database.ref('gameData').once('value')
    	]).then(function(snapshots) {
        	// Charger les joueurs
        	if (snapshots[0].exists()) {
            	players = snapshots[0].val();
        	}
    
        	// Charger les scores
        	if (snapshots[1].exists()) {
            	allScores = snapshots[1].val();
        	}
    
        	// Charger les terrains
        	if (snapshots[2].exists()) {
            	coursesDatabase = snapshots[2].val();
        	}
    
        	// Charger les donn√©es de parties
        	if (snapshots[3].exists()) {
            	var gameData = snapshots[3].val();
            	if (gameData.dates) dates = gameData.dates;
            	if (gameData.courses) courses = gameData.courses;
            	if (gameData.teeUsed) teeUsed = gameData.teeUsed;
        	}
        
        	// Charger les rounds
        	return database.ref('rounds').once('value');
        
    		}).then(function(snapshot) {
        		if (snapshot.exists()) {
            		rounds = snapshot.val();
            		console.log('Rounds charg√©s:', rounds.length);
            
            		// V√©rifier les m√©tadonn√©es GPR
            		var gprRounds = rounds.filter(r => r.type === 'gpr');
            		console.log('Parties GPR trouv√©es:', gprRounds.length);
            		var finaleRounds = gprRounds.filter(r => r.gprPhase === 'finale');
            		console.log('Parties finale trouv√©es:', finaleRounds.length);
        		}

        		console.log('Donn√©es charg√©es:', players.length, 'joueurs,', dates.length, 'parties');
        		isDataLoaded = true;
        		hideLoading();
    
        		// Initialiser l'interface apr√®s chargement
        		fixAllPlayerNames();
        		initializeData();
        		loadOverview();
        
    	}).catch(function(error) {
        	console.error('Erreur de chargement:', error);
        	hideLoading();
        	alert('Erreur de chargement des donn√©es: ' + error.message);
    	});
	}

	// Fonction pour calculer le diff√©rentiel de score
	function calculateScoreDifferentialReal(grossScore, courseName, teeColor) {
    	    if (grossScore <= 0) {
    			return null;
			}
			if (!coursesDatabase[courseName]) {
        	console.warn('Terrain non trouv√©:', courseName);
        	return null;
    	    }
    
    	    var courseData = coursesDatabase[courseName];
    	    var teeData = courseData.find(t => t.tee === teeColor);
    
    	    if (!teeData) {
        	teeData = courseData[0];
        	console.warn('D√©part', teeColor, 'non trouv√© pour', courseName, ', utilisation de', teeData.tee);
    	    }
    
    	    // Score Differential = (Gross Score - Course Rating) √ó 113 / Slope Rating
    	    var differential = (grossScore - teeData.rating) * 113 / teeData.slope;
    	    return Math.round(differential * 10) / 10;
	}

	// 3. FONCTION POUR CALCULER LE NOUVEAU HANDICAP BAS√â SUR LES DIFF√âRENTIELS
	function calculateNewHandicapFromDifferentials(differentials, initialHandicap) {
    	    if (differentials.length < 5) {
        	// Pas assez de scores, garder le handicap initial
        	return initialHandicap;
    	    }
    
    	    // Trier les diff√©rentiels (meilleurs en premier)
    	    var sortedDifferentials = [...differentials].sort((a, b) => a - b);
    
    	    // D√©terminer combien de scores utiliser
    	    var scoresToUse = 1;
    	    if (differentials.length >= 20) {
        	scoresToUse = 8;
    	    } else if (differentials.length >= 15) {
        	scoresToUse = 5;
    	    } else if (differentials.length >= 10) {
        	scoresToUse = 3;
    	    } else if (differentials.length >= 7) {
        	scoresToUse = 2;
    	    }
    
    	    // Prendre les meilleurs diff√©rentiels
    	    var bestDifferentials = sortedDifferentials.slice(0, scoresToUse);
    
    	    // Calculer la moyenne
    	    var average = bestDifferentials.reduce((sum, d) => sum + d, 0) / scoresToUse;
    
    	    // Appliquer le facteur 0.96 et arrondir
    	    var newHandicap = average * 0.96;
    
    	    // Limiter entre 0 et 36.4
    	    newHandicap = Math.max(0, Math.min(36.4, newHandicap));
    
    	    return Math.round(newHandicap * 10) / 10;
	}

	// 4. FONCTION POUR FORCER LA MISE √Ä JOUR COMPL√àTE
	function forceHandicapEvolutionUpdate() {
    	    console.log("üöÄ FORCE MISE √Ä JOUR √âVOLUTION HANDICAPS");
    	    console.log("=========================================");
    
    	    // Recalculer toutes les donn√©es
    	    prepareHandicapEvolutionData();
    
    	    // Mettre √† jour l'affichage imm√©diatement
    	    if (typeof displayHandicapStats === 'function') {
        	displayHandicapStats();
    	    }
    
    	    // Mettre √† jour le graphique si des joueurs sont s√©lectionn√©s
    	    if (typeof selectedPlayers !== 'undefined' && selectedPlayers.length > 0) {
        	if (typeof drawHandicapChart === 'function') {
            	    drawHandicapChart();
        	}
    	    }
    
    	    // Afficher un r√©sum√© des changements
    	    console.log("\nüìä R√âSUM√â DES √âVOLUTIONS:");
    	    console.log("========================");
    
    	    for (var playerId in handicapEvolutionData) {
        	var playerData = handicapEvolutionData[playerId];
        	var evolution = playerData.evolution;
        
        	if (evolution.length >= 2) {
            	    var initial = evolution[0].handicap;
            	    var final = evolution[evolution.length - 1].handicap;
            	    var change = final - initial;
            	    var totalGames = evolution.length - 1;
            
            	    var status = '';
            	    if (change < -1) status = 'üìà AM√âLIORATION';
            	    else if (change > 1) status = 'üìâ D√âGRADATION';
            	    else status = '‚û°Ô∏è STABLE';
            
            	    console.log(`${playerData.playerName}:`);
            	    console.log(`  ${initial.toFixed(1)} ‚Üí ${final.toFixed(1)} (${change > 0 ? '+' : ''}${change.toFixed(1)}) ${status}`);
            	    console.log(`  ${totalGames} parties jou√©es`);
        	}
    	    }
    
    	    console.log("\n‚úÖ MISE √Ä JOUR TERMIN√âE - V√©rifiez le tableau des statistiques!");
	}

	// Fonction pour recalculer le handicap d'un joueur bas√© sur ses scores jusqu'√† une date donn√©e
	function calculateHandicapAtDate(playerId, upToDate) {
    	    var player = players.find(p => p.id === playerId);
    	    if (!player) return null;
    
    	    var playerIndex = players.findIndex(p => p.id === playerId);
    	    if (playerIndex === -1) return player.handicap;
    
    	    var playerScores = [];
    
    	    // Collecter tous les scores du joueur jusqu'√† la date sp√©cifi√©e
    	    for (var i = 0; i < dates.length; i++) {
        	if (new Date(dates[i]) <= new Date(upToDate)) {
            	    var grossScore = allScores[playerIndex][i];
            
            	    if (grossScore > 0) {
                	var courseName = courses[i];
                	var teeForPlayer = (playerId === 1) ? teeUsed[i] : 'blanc';
                	var differential = calculateScoreDifferential(grossScore, courseName, teeForPlayer);
                
                	if (differential > 0) {
                    	    playerScores.push({
                        	date: dates[i],
                        	differential: differential
                    	    });
                	}
            	    }
        	}
    	    }
    
    	    // Calculer le handicap selon les r√®gles officielles
    	    if (playerScores.length < 5) {
        	// Pas assez de scores, garder le handicap initial
        	return player.handicap;
    	    }
    
    	    var differentials = playerScores.map(s => s.differential);
    	    differentials.sort((a, b) => a - b);
    
    	    var scoresToUse = 1;
    	    if (playerScores.length >= 20) scoresToUse = 8;
    	    else if (playerScores.length >= 15) scoresToUse = 5;
    	    else if (playerScores.length >= 10) scoresToUse = 3;
    	    else if (playerScores.length >= 7) scoresToUse = 2;
    
    	    var bestDifferentials = differentials.slice(0, scoresToUse);
    	    var average = bestDifferentials.reduce((sum, d) => sum + d, 0) / scoresToUse;
    
    	    return Math.round(average * 0.96 * 10) / 10;
	}

	// Fonction pour obtenir le handicap d'un joueur √† une date donn√©e
	function getPlayerHandicapAtDate(playerId, gameDate) {
    	    // Chercher dans le cache first
    	    var cacheKey = playerId + '_' + gameDate;
    	    if (handicapCache[cacheKey]) {
        	return handicapCache[cacheKey];
    	    }
    
    	    // Calculer et mettre en cache
    	    var handicap = calculateHandicapAtDate(playerId, gameDate);
    	    handicapCache[cacheKey] = handicap;
    
    	    return handicap;
	}

	// Fonction pour forcer la recalculation de l'√©volution des handicaps
	function fixHandicapEvolution() {
    	    console.log("üîÑ Correction de l'√©volution des handicaps...");
    
    	    // Vider le cache
    	    handicapCache = {};
    
    	    // Recalculer les donn√©es d'√©volution avec les vrais handicaps
    	    handicapEvolutionData = {};
    
    	    for (var i = 0; i < players.length; i++) {
        	var player = players[i];
        	var evolution = [];
        	var playerName = player.name || (player.firstName + ' ' + player.lastName);
        
        	// Handicap initial (avant toute partie)
        	var initialHandicap = player.handicap;
        
        	evolution.push({
            	    date: dates[0] || '2023-01-01',
            	    handicap: initialHandicap,
            	    gameNumber: 0,
            	    change: 0
        	});
        
        	// Calculer l'√©volution apr√®s chaque partie
        	for (var j = 0; j < dates.length; j++) {
            	    if (allScores[i][j] > 0) {
                	// Calculer le handicap √† cette date
                	var newHandicap = getPlayerHandicapAtDate(player.id, dates[j]);
                	var previousHandicap = j === 0 ? initialHandicap : evolution[evolution.length - 1].handicap;
                	var change = newHandicap - previousHandicap;
                
                	evolution.push({
                    	    date: dates[j],
                    	    handicap: newHandicap,
                    	    gameNumber: j + 1,
                    	    change: change,
                    	    score: allScores[i][j],
                    	    course: courses[j]
                	});
            	    }
        	}
        
        	handicapEvolutionData[player.id] = {
            	    player: player,
            	    playerName: playerName,
            	    evolution: evolution
        	};
    	    }
    
    	    console.log("‚úÖ √âvolution des handicaps corrig√©e!");
    
    	    // V√©rifier les r√©sultats
    	    console.log("üìä Nouveaux r√©sultats:");
    	    for (var playerId in handicapEvolutionData) {
        	var playerData = handicapEvolutionData[playerId];
        	var evolution = playerData.evolution;
        
        	if (evolution.length >= 2) {
            	    var initial = evolution[0].handicap;
            	    var final = evolution[evolution.length - 1].handicap;
            	    var change = final - initial;
            
            	    console.log(playerData.playerName + ": " + initial.toFixed(1) + " ‚Üí " + final.toFixed(1) + " (" + (change > 0 ? "+" : "") + change.toFixed(1) + ")");
        	}
    	    }
    
    	    // Recharger l'affichage
    	    displayHandicapStats();
    	    if (selectedPlayers && selectedPlayers.length > 0) {
        	drawHandicapChart();
    	    }
	}

        // Scores r√©els pour chaque joueur
        var allScores = [];
           
        var rounds = [];
        var scores = [];
		var gprRoundsData = [];
		var handicapCache = {};
		// Syst√®me GPR : tracking des finales
		var gprFinaleData = {};
		var GPR_TOTAL_PLAYERS = 12; // Base de calcul pour les absences
		var gprBest4Data = {}; // Stockage des 4 meilleures parties par joueur
		// Variables globales pour le calcul GPR
		var playerPoints = {};
		var playerBest4Points = {};
		var roundDetails = [];
		// Nouvelles constantes pour le syst√®me GPR
		var GPR_TOTAL_PLAYERS = 12; // Base de calcul pour les absences
		var GPR_FINALE_TOTAL_POINTS = 400; // Points fixes pour la finale

		// Fonction pour calculer les points d'absence (derni√®re place)
		function calculateAbsenteePoints(presentPlayers, isNet, isFinale, finaleFormat) {
		    var totalPlayers = GPR_TOTAL_PLAYERS;
		    var absentees = totalPlayers - presentPlayers;
		    
		    if (absentees <= 0) return 0;
		    
		    // Points selon le type de partie
		    var pointsScale = isFinale ? 
    			(isNet ? [225, 190, 165, 140, 125, 110, 90, 75, 60, 45, 35, 25] : 
            			 [175, 140, 120, 100, 85, 70, 60, 50, 40, 30, 20, 10]) :
    			(isNet ? [120, 105, 90, 78, 70, 62, 54, 46, 38, 30, 22, 15] : 
            			 [80, 68, 60, 52, 45, 40, 35, 30, 25, 20, 15, 10]);

			// Calculer la moyenne des points des derni√®res places
			var totalAbsenteePoints = 0;
			for (var i = 0; i < absentees; i++) {
    			var position = presentPlayers + i + 1;
    			totalAbsenteePoints += pointsScale[Math.min(position - 1, pointsScale.length - 1)];
			}

			return Math.round(totalAbsenteePoints / absentees);
		}

		// Fonction pour identifier les parties finale
		function isFinaleRound(round) {
    		return round.type === 'gpr' && round.gprPhase === 'finale';
		}

		// Fonction pour calculer les points d'absence (r√®gle des 12 joueurs)
		function calculateAbsenteePoints(presentPlayers, isNet, isFinale) {
    		var absentees = GPR_TOTAL_PLAYERS - presentPlayers;
    		if (absentees <= 0) return 0;
    
    		var pointsScale = isFinale ? 
        		(isNet ? [225, 190, 165, 140, 125, 110, 90, 75, 60, 45, 35, 25] : 
                		 [175, 140, 120, 100, 85, 70, 60, 50, 40, 30, 20, 10]) :
        		(isNet ? [120, 105, 90, 78, 70, 62, 54, 46, 38, 30, 22, 15] : 
                		 [80, 68, 60, 52, 45, 40, 35, 30, 25, 20, 15, 10]);
    
    		// Calculer la moyenne des points des derni√®res places
    		var totalAbsenteePoints = 0;
    		for (var i = 0; i < absentees; i++) {
        		var position = presentPlayers + i + 1;
        		totalAbsenteePoints += pointsScale[Math.min(position - 1, pointsScale.length - 1)];
    		}
    
    		return Math.round(totalAbsenteePoints / absentees);
		}
		
		// Fonction pour calculer les 4 meilleures parties d'exhibition
		function calculateBest4Exhibition(playerId, year) {
		    console.log('=== calculateBest4Exhibition ===');
    		console.log('Joueur ID:', playerId, 'Ann√©e:', year);
			
			// Obtenir toutes les parties exhibition de l'ann√©e (pas les finales)
			var exhibitionRounds = rounds.filter(r => 
		        r.type === 'gpr' && 
		        r.year === year && 
		        (!r.gprPhase || r.gprPhase === 'exhibition')
		    );

			console.log('Rounds exhibition de l\'ann√©e:', exhibitionRounds.length);
		    
		    // Calculer les points pour chaque partie (m√™me si le joueur √©tait absent)
		    var partiesWithPoints = [];
		    
		    for (var i = 0; i < exhibitionRounds.length; i++) {
		        var round = exhibitionRounds[i];
		        var roundScores = scores.filter(s => s.roundId === round.id && s.playerId !== 13);
		        
		        // V√©rifier si le joueur a particip√©
		        var playerScore = roundScores.find(s => s.playerId === playerId);
		        
		        var brutPos, netPos, brutPoints, netPoints;
		        
		        if (playerScore) {
		            // Joueur pr√©sent - calculer sa position r√©elle
		            var brutRanking = [...roundScores].sort((a, b) => a.score - b.score);
		            var netRanking = [...roundScores].sort((a, b) => a.net - b.net);
		            
		            brutPos = brutRanking.findIndex(s => s.playerId === playerId) + 1;
		            netPos = netRanking.findIndex(s => s.playerId === playerId) + 1;
		            
		            brutPoints = [80, 68, 60, 52, 45, 40, 35, 30, 25, 20, 15, 10][Math.min(brutPos - 1, 11)];
		            netPoints = [120, 105, 90, 78, 70, 62, 54, 46, 38, 30, 22, 15][Math.min(netPos - 1, 11)];
		        } else {
		            // Joueur absent - calculer les points d'absence
		            var presentPlayers = roundScores.length;
		            brutPoints = calculateAbsenteePoints(presentPlayers, false, false);
		            netPoints = calculateAbsenteePoints(presentPlayers, true, false);
		            brutPos = presentPlayers + 1;
		            netPos = presentPlayers + 1;
		            
		            // Cr√©er un score fictif pour l'absent
		            playerScore = {
		                playerId: playerId,
		                score: 999,
		                net: 999,
		                absent: true
		            };
		        }
		        
		        partiesWithPoints.push({
		            roundId: round.id,
		            date: round.date,
		            course: round.course,
		            totalPoints: brutPoints + netPoints,
		            brutPoints: brutPoints,
		            netPoints: netPoints,
		            brutPos: brutPos,
		            netPos: netPos,
		            score: playerScore,
		            absent: !roundScores.find(s => s.playerId === playerId)
		        });
		    }
		    
		    console.log('Parties avec points calcul√©es:', partiesWithPoints.length);
		    
		    // Trier par points d√©croissants et prendre les 4 meilleures (ou toutes si moins de 5)
		    partiesWithPoints.sort((a, b) => b.totalPoints - a.totalPoints);
		    var result = partiesWithPoints.length >= 5 ? partiesWithPoints.slice(0, 4) : partiesWithPoints;
		    
		    console.log('Best 4 pour joueur', playerId, ':', result.length, 'parties s√©lectionn√©es');
		    return result;
		}

		// Fonction pour cumuler les scores de finale
		function calculateFinaleScores(year) {
    		console.log('=== calculateFinaleScores appel√©e pour ann√©e:', year);
    		var finaleRounds = rounds.filter(r => {
    			var yearMatch = !year || r.year == year;
    			return yearMatch && r.type === 'gpr' && r.gprPhase === 'finale';
			});

    		console.log('Rounds finale trouv√©s:', finaleRounds);
    		if (finaleRounds.length > 0) {
        		console.log('Format finale:', finaleRounds[0].gprFinaleFormat);
    		}
    
    		var finaleResults = {};
    
    		if (finaleRounds.length === 0) {
        		console.log('Aucune finale trouv√©e');
        		return {};
    		}
    
    		// Identifier les joueurs participants (exclure √âric Gosselin ID 12)
    		for (var i = 0; i < finaleRounds.length; i++) {
        		var round = finaleRounds[i];
        		var roundScores = scores.filter(s => s.roundId === round.id && s.playerId !== 13);
        
        		for (var j = 0; j < roundScores.length; j++) {
            		var score = roundScores[j];
            
            		if (!finaleResults[score.playerId]) {
                		finaleResults[score.playerId] = {
                    		player: players.find(p => p.id === score.playerId),
                    		totalBrut: 0,
                    		totalNet: 0,
                    		daysPlayed: 0
                		};
            		}
            
            		finaleResults[score.playerId].totalBrut += score.score;
            		finaleResults[score.playerId].totalNet += score.net;
            		finaleResults[score.playerId].daysPlayed++;
        		}
    		}
    
			// === AJOUT DES ABSENTS ===
			console.log('=== AJOUT ABSENTS FINALE ' + year + ' ===');

			// Obtenir tous les joueurs GPR de l'ann√©e
			var allGPRScores = scores.filter(s => 
    			s.year == year && 
    			s.type === 'gpr' && 
    			s.playerId !== 13
			);

			var gprPlayerIds = [];
			for (var i = 0; i < allGPRScores.length; i++) {
    			if (gprPlayerIds.indexOf(allGPRScores[i].playerId) === -1) {
        			gprPlayerIds.push(allGPRScores[i].playerId);
    			}
			}

			console.log('Joueurs GPR trouv√©s:', gprPlayerIds.length, 'joueurs');
			console.log('IDs:', gprPlayerIds);

			// Ajouter ceux qui manquent
			for (var i = 0; i < gprPlayerIds.length; i++) {
    			var playerId = gprPlayerIds[i];
    			if (!finaleResults[playerId]) {
        			var player = players.find(p => p.id === playerId);
        			finaleResults[playerId] = {
            			player: player,
            			totalBrut: 999,
            			totalNet: 999,
            			daysPlayed: 0,
            			absent: true
        			};
        			console.log('AJOUT ABSENT:', player.name || (player.firstName + ' ' + player.lastName));
    			}
			}

    		// Distribuer les 400 points fixes de finale
    		var playersArray = [];
    		for (var playerId in finaleResults) {
        		playersArray.push({
            		playerId: parseInt(playerId),
            		data: finaleResults[playerId]
        		});
    		}

    		// Classement finale par score brut cumul√©
    		playersArray.sort((a, b) => {
        		if (a.data.daysPlayed === 0 && b.data.daysPlayed === 0) return 0;
        		if (a.data.daysPlayed === 0) return 1;
        		if (b.data.daysPlayed === 0) return -1;
        		return a.data.totalBrut - b.data.totalBrut;
    		});

    		// V√©rifier si c'est une finale 1 jour ou 2 jours
    		var isFinale1Day = false;
    		if (finaleRounds.length > 0 && finaleRounds[0].gprFinaleFormat === '1day') {
        		isFinale1Day = true;
    		}

    		// Points finale FIXES - toujours 400 points au total
			var finaleBrutPoints = [175, 140, 120, 100, 85, 70, 60, 50, 40, 30, 20, 10];
			var finaleNetPoints = [225, 190, 165, 140, 125, 110, 90, 75, 60, 45, 35, 25];

			console.log('Format finale:', isFinale1Day ? '1 jour' : '2 jours');
			console.log('Nombre de jours de finale:', finaleRounds.length);
			console.log('Points brut √† distribuer:', finaleBrutPoints.reduce((a,b) => a+b, 0));
			console.log('Points net √† distribuer:', finaleNetPoints.reduce((a,b) => a+b, 0));

			// Distribution des points brut
			for (var i = 0; i < playersArray.length; i++) {
    			var pointsBrut = finaleBrutPoints[Math.min(i, finaleBrutPoints.length - 1)];
    			playersArray[i].data.pointsBrut = pointsBrut;
    			playersArray[i].data.positionBrut = i + 1;
			}

			// Classement finale par score net cumul√©
			playersArray.sort((a, b) => {
    			if (a.data.daysPlayed === 0 && b.data.daysPlayed === 0) return 0;
    			if (a.data.daysPlayed === 0) return 1;
    			if (b.data.daysPlayed === 0) return -1;
    			return a.data.totalNet - b.data.totalNet;
			});

			// Distribution des points net
			for (var i = 0; i < playersArray.length; i++) {
    			var pointsNet = finaleNetPoints[Math.min(i, finaleNetPoints.length - 1)];
    			playersArray[i].data.pointsNet = pointsNet;
    			playersArray[i].data.positionNet = i + 1;
    			playersArray[i].data.totalPointsFinale = playersArray[i].data.pointsBrut + pointsNet;
			}

    		// Debug - V√©rifier le total des points
    		var totalBrutDistribue = 0;
    		var totalNetDistribue = 0;
    		for (var i = 0; i < playersArray.length; i++) {
        		totalBrutDistribue += playersArray[i].data.pointsBrut || 0;
        		totalNetDistribue += playersArray[i].data.pointsNet || 0;
    		}
    		console.log('=== DEBUG FINALE ===');
    		console.log('Total points brut distribu√©s:', totalBrutDistribue);
    		console.log('Total points net distribu√©s:', totalNetDistribue);
    		console.log('TOTAL G√âN√âRAL:', totalBrutDistribue + totalNetDistribue);

    		// Remettre dans l'objet finaleResults
    		for (var i = 0; i < playersArray.length; i++) {
        		var playerId = playersArray[i].playerId;
        		finaleResults[playerId] = playersArray[i].data;
    		}

    		return finaleResults;
		}

	// Fonction pour recalculer le handicap d'un joueur bas√© sur ses scores jusqu'√† une date donn√©e
	function calculateHandicapAtDate(playerId, upToDate) {
    	    var playerScores = [];
    
    	    // Collecter tous les scores du joueur jusqu'√† la date sp√©cifi√©e
    	    for (var i = 0; i < dates.length; i++) {
        	if (new Date(dates[i]) <= new Date(upToDate)) {
            	    if (grossScore > 0) {
    					var courseName = courses[i];
    					var teeForPlayer = (playerId === 1) ? teeUsed[i] : 'blanc';
    					var differential = calculateScoreDifferential(grossScore, courseName, teeForPlayer);
    
    					if (differential !== null) {
        					playerScores.push({
            					date: dates[i],
            					differential: differential
        					});
    					}
					}
            
            	if (grossScore > 0) {
                    var courseName = courses[i];
                    var teeForPlayer = (playerId === 1) ? teeUsed[i] : 'blanc';
                    var differential = calculateScoreDifferential(grossScore, courseName, teeForPlayer);
                
                    if (differential > 0) {
                        playerScores.push({
                            date: dates[i],
                            differential: differential
                        });
                    }
                }
            }
        }
    
    	// Trier par date (plus r√©cent en premier)
    	playerScores.sort((a, b) => new Date(b.date) - new Date(a.date));
    
    	// Calculer le handicap selon les r√®gles officielles
    	if (playerScores.length < 5) {
            // Pas assez de scores, garder le handicap initial
            var initialPlayer = players.find(p => p.id === playerId);
            return initialPlayer ? initialPlayer.handicap : null;
        }
    
    	var differentials = playerScores.map(s => s.differential);
    	differentials.sort((a, b) => a - b);
    
    	var scoresToUse = 1;
    	if (playerScores.length >= 20) scoresToUse = 8;
    	else if (playerScores.length >= 15) scoresToUse = 5;
    	else if (playerScores.length >= 10) scoresToUse = 3;
    	else if (playerScores.length >= 7) scoresToUse = 2;
    
    	var bestDifferentials = differentials.slice(0, scoresToUse);
    	var average = bestDifferentials.reduce((sum, d) => sum + d, 0) / scoresToUse;
    
    	return Math.round(average * 0.96 * 10) / 10;
    }

    // Fonction pour obtenir le handicap d'un joueur √† une date donn√©e
    function getPlayerHandicapAtDate(playerId, gameDate) {
    	// Chercher dans le cache first
    	var cacheKey = playerId + '_' + gameDate;
    	if (handicapCache[cacheKey]) {
            return handicapCache[cacheKey];
    	}
    
    	// Calculer et mettre en cache
    	var handicap = calculateHandicapAtDate(playerId, gameDate);
    	handicapCache[cacheKey] = handicap;
    
    	return handicap;
    }

    function initializeData() {
    	// Si rounds n'existe pas, le cr√©er
    	if (typeof rounds === 'undefined' || !rounds || rounds.length === 0) {
        	console.log('Pas de rounds charg√©s, cr√©ation depuis dates/courses');
        	rounds = [];
        
        	// Construire rounds depuis les anciennes donn√©es
        	for (var i = 0; i < dates.length; i++) {
            	var courseName = courses[i];
            	var isDiablo = (courseName === 'Le Diable' || courseName === 'Le G√©ant' || courseName === 'Manoir des Sables');
            	var gameDate = new Date(dates[i]);
            	var year = gameDate.getFullYear();
            	var month = gameDate.getMonth() + 1;
            
            	rounds.push({
                	id: i + 1,
                	date: dates[i],
                	course: courseName,
                	tee: teeUsed[i],
                	type: isDiablo ? 'diablo' : 'gpr',
                	year: year,
                	month: month
            	});
        	}
    	} else {
        	console.log('Rounds d√©j√† charg√©s depuis Firebase, conservation compl√®te');
        	console.log('Nombre de rounds:', rounds.length);
        	var gprFinales = rounds.filter(r => r.gprPhase === 'finale');
        	console.log('Dont finales GPR:', gprFinales.length);
    	}
    
    	// Toujours reconstruire scores
    	scores = [];
    	handicapCache = {};
    
    	// Reconstruire les scores bas√©s sur rounds existants
    	for (var i = 0; i < rounds.length; i++) {
        	var round = rounds[i];
        	var roundIndex = i; // L'index dans allScores correspond √† l'ordre des rounds
        
        	// Ajouter les scores pour cette partie
        	for (var j = 0; j < players.length; j++) {
            	var grossScore = allScores[j][roundIndex];
            
            	if (grossScore > 0) {
                	var player = players[j];
                	var teeForPlayer = teeUsed[roundIndex];
                
                	// Antonio (id=1) joue des bleus pour certaines parties
                	if (player.id !== 1) {
                    	teeForPlayer = 'blanc';
                	}
                
                	var courseHandicap = calculateCourseHandicap(player.handicap, round.course, teeForPlayer);
                	var netScore = grossScore - courseHandicap;
                
                	scores.push({
                    	roundId: round.id,
                    	playerId: player.id,
                    	playerName: player.name || (player.firstName + ' ' + player.lastName),
                    	score: grossScore,
                    	courseHandicap: courseHandicap,
                    	net: netScore,
                    	tee: teeForPlayer,
                    	type: round.type,
                    	year: round.year,
                    	month: round.month
                	});
            	}
        	}
    	}
    
    	console.log('InitializeData termin√© - Scores reconstruits:', scores.length);
	}

	// Fonction pour calculer le diff√©rentiel de score (Score Differential)
	function calculateScoreDifferential(grossScore, courseName, teeColor) {
    	    if (!coursesDatabase[courseName]) {
        	console.warn('Terrain non trouv√©:', courseName);
        	return null;
    	    }
    
    	    var courseData = coursesDatabase[courseName];
    	    var teeData = courseData.find(t => t.tee === teeColor);
    
    	    if (!teeData) {
        	teeData = courseData[0];
        	console.warn('D√©part', teeColor, 'non trouv√© pour', courseName, ', utilisation de', teeData.tee);
    	    }
    
    	    // Score Differential = (Gross Score - Course Rating) √ó 113 / Slope Rating
    	    var differential = (grossScore - teeData.rating) * 113 / teeData.slope;
    	    return Math.round(differential * 10) / 10;
	}

        // Fonctions de navigation
        function showOverview() {
            hideAllSections();
            document.getElementById('overview').style.display = 'block';
            setActiveButton('showOverview');
            loadOverview();
        }

        function showPlayerScores() {
            hideAllSections();
            document.getElementById('playerScores').style.display = 'block';
            setActiveButton('showPlayerScores');
            loadPlayerSelector();
        }

        function showCourses() {
            hideAllSections();
            document.getElementById('courses').style.display = 'block';
            setActiveButton('showCourses');
            loadCoursesList();
        }

        function showDiablo() {
            hideAllSections();
            document.getElementById('diablo').style.display = 'block';
            setActiveButton('showDiablo');
            loadDiablo();
        }

        function showGPR() {
            hideAllSections();
            document.getElementById('gpr').style.display = 'block';
            setActiveButton('showGPR');
            loadGPR();
        }

        function showProgress() {
            hideAllSections();
            document.getElementById('progress').style.display = 'block';
            setActiveButton('showProgress');
            loadProgress();
        }

        function showDetails() {
            hideAllSections();
            document.getElementById('details').style.display = 'block';
            setActiveButton('showDetails');
            loadDetails();
        }

		function showHandicapEvolution() {
            hideAllSections();
            document.getElementById('handicapEvolution').style.display = 'block';
            setActiveButton('showHandicapEvolution');
            loadDetails();
        }

		function showPlayerManagement() {
            hideAllSections();
            document.getElementById('playerManagement').style.display = 'block';
            setActiveButton('showPlayerManagement');
            loadDetails();
        }

		function showAddRound() {
            hideAllSections();
            document.getElementById('addRound').style.display = 'block';
            setActiveButton('showAddRound');
            loadDetails();
        }

        function hideAllSections() {
    		var sections = ['overview', 'playerScores', 'courses', 'diablo', 'gpr', 'progress', 'details', 'handicapEvolution', 'playerManagement', 'addRound', 'calendar'];
    		for (var i = 0; i < sections.length; i++) {
        		var element = document.getElementById(sections[i]);
        		if (element) {
            		element.style.display = 'none';
        		}
    		}
		}

        function setActiveButton(buttonFunction) {
    		var buttons = document.querySelectorAll('.nav button:not(.nav-save-btn)');
    		for (var i = 0; i < buttons.length; i++) {
        		buttons[i].classList.remove('active');
    		}
    
    		// Ajouter active au bon bouton selon la fonction
    		var activeSelector = '';
    		switch(buttonFunction) {
        		case 'showAddRound': activeSelector = 'button[onclick="showAddRound()"]'; break;
        		case 'showProgress': activeSelector = 'button[onclick="showProgress()"]'; break;
        		case 'showDiablo': activeSelector = 'button[onclick="showDiablo()"]'; break;
        		case 'showGPR': activeSelector = 'button[onclick="showGPR()"]'; break;
        		case 'showOverview': activeSelector = 'button[onclick="showOverview()"]'; break;
        		case 'showHandicapEvolution': activeSelector = 'button[onclick="showHandicapEvolution()"]'; break;
        		case 'showPlayerScores': activeSelector = 'button[onclick="showPlayerScores()"]'; break;
        		case 'showDetails': activeSelector = 'button[onclick="showDetails()"]'; break;
        		case 'showCourses': activeSelector = 'button[onclick="showCourses()"]'; break;
        		case 'showPlayerManagement': activeSelector = 'button[onclick="showPlayerManagement()"]'; break;
				case 'showCalendar': activeSelector = 'button[onclick="showCalendar()"]'; break;
    		}
    
    		if (activeSelector) {
        		var activeButton = document.querySelector('.nav ' + activeSelector);
        		if (activeButton) {
            		activeButton.classList.add('active');
        		}
    		}
		}

        // FONCTION loadOverview() - TROUVEZ ET REMPLACEZ CETTE PARTIE :

	function loadOverview() {
    	var totalGames = rounds.length;
    	var totalScores = scores.length;
    	var activePlayers = getUniquePlayersCount(scores);
    	var totalCourses = Object.keys(coursesDatabase).length;

    	var diabloGames = rounds.filter(r => r.type === 'diablo').length;
    	var gprGames = rounds.filter(r => r.type === 'gpr').length;

    	var html = '<div class="player-stats">' +
        	       '<div class="stat-box">' +
            	   '<div class="stat-value">' + totalGames + '</div>' +
                   '<div class="stat-label">Parties Total</div>' +
            	   '</div>' +
            	   '<div class="stat-box">' +
            	   '<div class="stat-value">' + activePlayers + '</div>' +
            	   '<div class="stat-label">Joueurs Actifs</div>' +
            	   '</div>' +
            	   '<div class="stat-box">' +
            	   '<div class="stat-value">' + totalCourses + '</div>' +
            	   '<div class="stat-label">Terrains en Base</div>' +
            	   '</div>' +
            	   '<div class="stat-box">' +
            	   '<div class="stat-value">' + diabloGames + '</div>' +
            	   '<div class="stat-label">Parties Diablo</div>' +
            	   '</div>' +
            	   '<div class="stat-box">' +
            	   '<div class="stat-value">' + gprGames + '</div>' +
            	   '<div class="stat-label">Parties GPR</div>' +
            	   '</div>' +
            	   '</div>';

    	// CLASSEMENT COMPLET DE TOUS LES JOUEURS
    	var allPlayerStats = [];
    	for (var i = 0; i < players.length; i++) {
        	var player = players[i];
        	var playerScores = scores.filter(s => s.playerId === player.id);
        	if (playerScores.length > 0) {
            	var avgGross = playerScores.reduce((sum, s) => sum + s.score, 0) / playerScores.length;
            	var avgNet = playerScores.reduce((sum, s) => sum + s.net, 0) / playerScores.length;
            	var bestGross = Math.min(...playerScores.map(s => s.score));
            	var bestNet = Math.min(...playerScores.map(s => s.net));
            
            	allPlayerStats.push({
                	player: player,
                	playerName: player.name || (player.firstName + ' ' + player.lastName),
                	games: playerScores.length,
                	avgGross: avgGross,
                	avgNet: avgNet,
                	bestGross: bestGross,
                	bestNet: bestNet
            	});
        	}
    	}

    	allPlayerStats.sort((a, b) => a.avgNet - b.avgNet);

    	html += '<h3>üèÜ CLASSEMENT COMPLET DE TOUS LES JOUEURS</h3>' +
        	    '<p style="background: #e7f3ff; padding: 10px; border-radius: 5px; margin: 10px 0;">Class√© par score net moyen (plus bas = meilleur). Total: ' + allPlayerStats.length + ' joueurs avec au moins 1 partie.</p>' +
        	    '<table class="table">' +
        	    '<thead><tr><th>üèÜ Rang</th><th>üë§ Joueur</th><th>üéÆ Parties</th><th>üèåÔ∏è Handicap</th><th>üìä Moy. Brut</th><th>‚≠ê Moy. Net</th><th>üéØ Meilleur Net</th><th>üí™ Meilleur Brut</th></tr></thead>' +
        	    '<tbody>';

    	for (var i = 0; i < allPlayerStats.length; i++) {
        	var stat = allPlayerStats[i];
        	var rowStyle = '';
        	var rankIcon = '';
        
        	// Podium avec ic√¥nes
        	if (i === 0) {
            	rowStyle = ' style="background: linear-gradient(45deg, #FFD700, #FFF8DC); font-weight: bold;"';
            	rankIcon = 'ü•á';
        	} else if (i === 1) {
            	rowStyle = ' style="background: linear-gradient(45deg, #C0C0C0, #F5F5F5); font-weight: bold;"';
            	rankIcon = 'ü•à';
        	} else if (i === 2) {
            	rowStyle = ' style="background: linear-gradient(45deg, #CD7F32, #F4E4BC); font-weight: bold;"';
            	rankIcon = 'ü•â';
        	} else if (i < 5) {
            	rowStyle = ' style="background: #e8f4fd; font-weight: 500;"';
            	rankIcon = '‚≠ê';
        	} else if (i >= allPlayerStats.length - 3 && allPlayerStats.length > 5) {
            	rowStyle = ' style="background: #ffe8e8;"';
            	rankIcon = 'üìà';
        	}
        
        	html += '<tr' + rowStyle + '>' +
            	    '<td><strong>' + rankIcon + ' ' + (i + 1) + '</strong></td>' +
            	    '<td><strong>' + stat.playerName + '</strong></td>' +
            	    '<td>' + stat.games + '</td>' +
            	    '<td>' + stat.player.handicap.toFixed(1) + '</td>' +
            	    '<td>' + stat.avgGross.toFixed(1) + '</td>' +
            	    '<td><strong style="color: ' + (i < 3 ? '#28a745' : '#333') + ';">' + stat.avgNet.toFixed(1) + '</strong></td>' +
            	    '<td>' + stat.bestNet.toFixed(1) + '</td>' +
            	    '<td>' + stat.bestGross + '</td>' +
            	    '</tr>';
    	}

    	html += '</tbody></table>';

    	// ANALYSE STATISTIQUE D√âTAILL√âE
    	if (allPlayerStats.length > 0) {
        	html += '<div class="card" style="background: #f8f9fa; margin-top: 20px;">' +
            	    '<h4>üìä Analyse Statistique Compl√®te</h4>' +
            	    '<div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(250px, 1fr)); gap: 15px;">';
        
        	var bestPlayer = allPlayerStats[0];
        	var worstPlayer = allPlayerStats[allPlayerStats.length - 1];
        	var avgNetAll = allPlayerStats.reduce((sum, stat) => sum + stat.avgNet, 0) / allPlayerStats.length;
        	var medianIndex = Math.floor(allPlayerStats.length / 2);
        	var medianNet = allPlayerStats[medianIndex].avgNet;
        	var spread = worstPlayer.avgNet - bestPlayer.avgNet;
        
        	html += '<div class="stat-box" style="background: #e8f5e8; border-left: 5px solid #28a745;">' +
            	    '<div class="stat-value" style="color: #28a745;">ü•á ' + bestPlayer.avgNet.toFixed(1) + '</div>' +
            	    '<div class="stat-label">Champion<br><strong>' + bestPlayer.playerName + '</strong></div>' +
            	    '</div>' +
                
            	    '<div class="stat-box" style="background: #ffe8e8; border-left: 5px solid #dc3545;">' +
            	    '<div class="stat-value" style="color: #dc3545;">üìà ' + worstPlayer.avgNet.toFixed(1) + '</div>' +
            	    '<div class="stat-label">√Ä Am√©liorer<br><strong>' + worstPlayer.playerName + '</strong></div>' +
            	    '</div>' +
                
            	    '<div class="stat-box" style="background: #e3f2fd; border-left: 5px solid #2196f3;">' +
            	    '<div class="stat-value" style="color: #2196f3;">üìä ' + avgNetAll.toFixed(1) + '</div>' +
            	    '<div class="stat-label">Moyenne Groupe</div>' +
            	    '</div>' +
                
            	    '<div class="stat-box" style="background: #f3e5f5; border-left: 5px solid #9c27b0;">' +
            	    '<div class="stat-value" style="color: #9c27b0;">üìè ' + medianNet.toFixed(1) + '</div>' +
            	    '<div class="stat-label">Score M√©dian</div>' +
            	    '</div>' +
                
            	    '<div class="stat-box" style="background: #fff3e0; border-left: 5px solid #ff9800;">' +
            	    '<div class="stat-value" style="color: #ff9800;">üìè ' + spread.toFixed(1) + '</div>' +
            	    '<div class="stat-label">√âcart Total</div>' +
            	    '</div>';
        
        	// Distribution par niveau
        	var excellent = allPlayerStats.filter(s => s.avgNet < avgNetAll - 2).length;
        	var good = allPlayerStats.filter(s => s.avgNet >= avgNetAll - 2 && s.avgNet < avgNetAll).length;
        	var average = allPlayerStats.filter(s => s.avgNet >= avgNetAll && s.avgNet < avgNetAll + 2).length;
        	var improving = allPlayerStats.filter(s => s.avgNet >= avgNetAll + 2).length;
        
        	html += '<div class="stat-box" style="background: #f0f0f0; border-left: 5px solid #666;">' +
            	    '<div class="stat-value" style="color: #666; font-size: 16px;">üìà Distribution</div>' +
                	'<div class="stat-label" style="font-size: 12px; line-height: 1.3;">' +
                	'üåü Excellent: <strong>' + excellent + '</strong><br>' +
                	'üëç Bon: <strong>' + good + '</strong><br>' +
                	'üìä Moyen: <strong>' + average + '</strong><br>' +
                	'üîÑ √Ä am√©liorer: <strong>' + improving + '</strong>' +
                	'</div>' +
                	'</div>';
        
        	html += '</div></div>';
    	}

    	document.getElementById('overviewStats').innerHTML = html;
	}

        // VOIR LES TERRAINS

	function loadCoursesList() {
    	    var html = '';
    	    console.log('=== CHARGEMENT DES TERRAINS ===');
			var courseNames = Object.keys(coursesDatabase).sort();
    
    	    // Afficher les statistiques
    	    var totalTees = 0;
    	    for (var courseName in coursesDatabase) {
        	totalTees += coursesDatabase[courseName].length;
    	    }
    
    	    html += '<div style="background: #f8f9fa; padding: 15px; border-radius: 8px; margin-bottom: 20px;">' +
            	    '<strong>üìä R√©sum√©:</strong> ' + courseNames.length + ' terrains avec ' + totalTees + ' d√©parts au total' +
            	    '</div>';
    
    	    html += '<div class="course-grid">';
    
    	    for (var i = 0; i < courseNames.length; i++) {
        	var courseName = courseNames[i];
        	var tees = coursesDatabase[courseName];
        
        	html += '<div class="course-card">' +
        			'<div class="course-header">' +
        			'<div class="course-name">üèåÔ∏è ' + courseName + '</div>' +
        			'<div>' +
        			'<button class="btn-secondary" onclick="editCourse(\'' + courseName + '\')" style="margin-right: 5px;">‚úèÔ∏è Modifier</button>' +
        			'<button class="btn-danger" onclick="deleteCourse(\'' + courseName + '\')">üóëÔ∏è Supprimer</button>' +
        			'</div>' +
        			'</div>';
        
        	// Afficher chaque d√©part avec ses d√©tails
        	for (var j = 0; j < tees.length; j++) {
            	    var tee = tees[j];
            
            	    // D√©terminer la couleur du d√©part
            	    var teeIcon = '';
            	    switch(tee.tee) {
                	case 'blanc': teeIcon = '‚ö™'; break;
                	case 'bleu': teeIcon = 'üîµ'; break;
                	case 'vert': teeIcon = 'üü¢'; break;
                	case 'jaune': teeIcon = 'üü°'; break;
                	case 'noir': teeIcon = '‚ö´'; break;
                	default: teeIcon = 'üèåÔ∏è'; break;
            	    }
            
            	    // Niveau de difficult√© bas√© sur le slope
            	    var difficulty = '';
            	    var difficultyColor = '';
            	    if (tee.slope < 113) {
                	difficulty = 'Facile';
                	difficultyColor = '#28a745';
            	    } else if (tee.slope < 125) {
                	difficulty = 'Moyen';
                	difficultyColor = '#ffc107';
            	    } else if (tee.slope < 135) {
                	difficulty = 'Difficile';
                	difficultyColor = '#fd7e14';
            	    } else {
                	difficulty = 'Tr√®s difficile';
                	difficultyColor = '#dc3545';
            	    }
            
            	    html += '<div class="tee-info" style="border-left: 4px solid ' + difficultyColor + ';">' +
                    	    '<div style="display: flex; align-items: center; gap: 10px;">' +
                    	    '<span style="font-size: 18px;">' + teeIcon + '</span>' +
                    	    '<div>' +
                    	    '<span class="tee-color tee-' + tee.tee + '" style="padding: 3px 8px; border-radius: 12px; font-size: 11px; font-weight: bold;">' + 
                    	    tee.tee.toUpperCase() + '</span>' +
                    	    '<br><small style="color: ' + difficultyColor + '; font-weight: bold;">' + difficulty + '</small>' +
                    	    '</div>' +
                    	    '</div>' +
                    	    '<div style="text-align: right; font-family: monospace;">' +
                    	    '<div><strong>Rating:</strong> ' + tee.rating + '</div>' +
                    	    '<div><strong>Slope:</strong> ' + tee.slope + '</div>' +
                    	    '<div><strong>Par:</strong> ' + tee.par + '</div>' +
                    	    '</div>' +
                    	    '</div>';
        	}
        
        	html += '</div>';
    	    }
    
    	    html += '</div>';
    
			console.log('HTML g√©n√©r√©:', html.substring(0, 500));
    	    document.getElementById('coursesList').innerHTML = html;
	}

    function toggleAddCourseForm() {
        var form = document.getElementById('addCourseForm');
        if (form.style.display === 'none') {
            form.style.display = 'block';
            document.getElementById('newCourseName').value = '';
            // Reset form with one tee input
            document.getElementById('teeInputs').innerHTML = 
                '<div class="tee-form-row">' +
                '<select>' +
                '<option value="blanc">Blanc</option>' +
                '<option value="bleu">Bleu</option>' +
                '<option value="vert">Vert</option>' +
                '<option value="jaune">Jaune</option>' +
                '<option value="noir">Noir</option>' +
                '</select>' +
                '<input type="number" placeholder="Rating (ex: 69.5)" step="0.1" min="60" max="80">' +
                '<input type="number" placeholder="Slope (ex: 123)" min="85" max="155">' +
                '<input type="number" placeholder="Par (ex: 72)" min="68" max="76">' +
                '<button type="button" class="btn-danger" onclick="removeTeeInput(this)">‚ùå</button>' +
                '</div>';
        } else {
            form.style.display = 'none';
        }
    }

    function addTeeInput() {
        var container = document.getElementById('teeInputs');
        var newRow = document.createElement('div');
        newRow.className = 'tee-form-row';
        newRow.innerHTML = 
            '<select>' +
            '<option value="blanc">Blanc</option>' +
            '<option value="bleu">Bleu</option>' +
            '<option value="vert">Vert</option>' +
            '<option value="jaune">Jaune</option>' +
            '<option value="noir">Noir</option>' +
            '</select>' +
            '<input type="number" placeholder="Rating (ex: 69.5)" step="0.1" min="60" max="80">' +
            '<input type="number" placeholder="Slope (ex: 123)" min="85" max="155">' +
            '<input type="number" placeholder="Par (ex: 72)" min="68" max="76">' +
            '<button type="button" class="btn-danger" onclick="removeTeeInput(this)">‚ùå</button>';
        container.appendChild(newRow);
    }

    function removeTeeInput(button) {
        var container = document.getElementById('teeInputs');
        if (container.children.length > 1) {
            button.parentElement.remove();
        }
    }

    function saveCourse() {
        var courseName = document.getElementById('newCourseName').value.trim();
        if (!courseName) {
            alert('Veuillez saisir le nom du terrain.');
            return;
        }
            
        if (coursesDatabase[courseName]) {
            if (!confirm('Ce terrain existe d√©j√†. Voulez-vous le remplacer?')) {
                return;
            }
        }
            
        var teeRows = document.querySelectorAll('#teeInputs .tee-form-row');
        var tees = [];
            
        for (var i = 0; i < teeRows.length; i++) {
            var row = teeRows[i];
            var select = row.querySelector('select');
            var ratingInput = row.querySelectorAll('input')[0];
            var slopeInput = row.querySelectorAll('input')[1];
            var parInput = row.querySelectorAll('input')[2];
                
            var teeColor = select.value;
            var rating = parseFloat(ratingInput.value);
            var slope = parseInt(slopeInput.value);
            var par = parseInt(parInput.value);
                
            if (!rating || !slope || !par || rating < 60 || rating > 80 || slope < 85 || slope > 155 || par < 68 || par > 76) {
                alert('Veuillez remplir tous les champs avec des valeurs valides (Rating: 60-80, Slope: 85-155, Par: 68-76).');
                return;
            }
                
            tees.push({
                tee: teeColor,
                rating: rating,
                slope: slope,
                par: par
            });
        }
            
        coursesDatabase[courseName] = tees;
        // Sauvegarder dans Firebase
        saveCoursesToFirebase().then(function() {
            console.log('Terrain sauvegard√© dans Firebase');
        }).catch(function(error) {
            console.error('Erreur de sauvegarde terrain:', error);
            alert('Erreur de sauvegarde: ' + error.message);
        });
        saveCourseData();
        loadCoursesList();
        toggleAddCourseForm();
            
        document.getElementById('coursesList').insertAdjacentHTML('afterbegin',
            '<div class="alert-success">‚úÖ Terrain "' + courseName + '" ajout√© avec succ√®s!</div>'
        );
            
        setTimeout(function() {
            var alert = document.querySelector('#coursesList .alert-success');
            if (alert) alert.remove();
        }, 3000);
    }

    function cancelAddCourse() {
        toggleAddCourseForm();
    }

    function deleteCourse(courseName) {
    	if (confirm('√ätes-vous s√ªr de vouloir supprimer le terrain "' + courseName + '"?')) {
        	delete coursesDatabase[courseName];
        
        	// Sauvegarder dans Firebase
        	saveCoursesToFirebase().then(function() {
            	console.log('Terrain supprim√© de Firebase');
        	}).catch(function(error) {
            	console.error('Erreur de suppression terrain:', error);
            	alert('Erreur de suppression: ' + error.message);
        	});
        
        	saveCourseData();
        	loadCoursesList();
        
        	document.getElementById('coursesList').insertAdjacentHTML('afterbegin',
            	'<div class="alert-danger">üóëÔ∏è Terrain "' + courseName + '" supprim√©.</div>'
       		);
        
        	setTimeout(function() {
            	var alert = document.querySelector('#coursesList .alert-danger');
            	if (alert) alert.remove();
        	}, 3000);
    	}
	}

	// Nouvelle fonction pour √©diter un terrain existant
	function editCourse(courseName) {
    	var courseData = coursesDatabase[courseName];
    	if (!courseData) {
        	alert('Terrain non trouv√©!');
        	return;
    	}

    	// Cr√©er le formulaire d'√©dition
    	var formHtml = 
    		'<div style="position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.5); z-index: 1000; overflow-y: auto;">' +
    		'<div style="background: white; padding: 30px; margin: 50px auto; border-radius: 10px; box-shadow: 0 4px 20px rgba(0,0,0,0.3); max-width: 700px; width: 90%;">' +
        	'<h3 style="margin-top: 0; color: #2c5530;">‚úèÔ∏è Modifier le Terrain</h3>' +
    
    		'<div style="margin: 15px 0;">' +
        	'<label style="display: block; font-weight: bold; margin-bottom: 5px;">Nom du terrain:</label>' +
        	'<input type="text" id="editCourseName" value="' + courseName.replace(/"/g, '&quot;') + '" style="width: 100%; padding: 8px; border: 1px solid #ddd; border-radius: 4px;">' +
    		'</div>' +
        
    		'<h4>D√©parts disponibles:</h4>' +
        	'<div id="editTeeInputs">';

    	// Ajouter les d√©parts existants
    	for (var i = 0; i < courseData.length; i++) {
        	var tee = courseData[i];
        	formHtml += '<div class="tee-form-row">' +
            	'<select>' +
            	'<option value="blanc"' + (tee.tee === 'blanc' ? ' selected' : '') + '>Blanc</option>' +
            	'<option value="bleu"' + (tee.tee === 'bleu' ? ' selected' : '') + '>Bleu</option>' +
        		'<option value="vert"' + (tee.tee === 'vert' ? ' selected' : '') + '>Vert</option>' +
        		'<option value="jaune"' + (tee.tee === 'jaune' ? ' selected' : '') + '>Jaune</option>' +
        		'<option value="noir"' + (tee.tee === 'noir' ? ' selected' : '') + '>Noir</option>' +
            	'</select>' +
            	'<input type="number" value="' + tee.rating + '" step="0.1" min="60" max="80" placeholder="Rating">' +
        		'<input type="number" value="' + tee.slope + '" min="85" max="155" placeholder="Slope">' +
        		'<input type="number" value="' + tee.par + '" min="68" max="76" placeholder="Par">' +
        		'<button type="button" class="btn-danger" onclick="removeEditTeeInput(this)">‚ùå</button>' +
            	'</div>';
    	}

    	formHtml += '</div>' +
        	'<button class="btn-secondary" onclick="addEditTeeInput()">‚ûï Ajouter un D√©part</button>' +
        	'<br><br>' +
    		'<div style="margin-top: 25px; text-align: center;">' +
    		'<button onclick="saveCourseEdit(\'' + courseName + '\')" style="background: #4a7c59; color: white; border: none; padding: 12px 24px; border-radius: 5px; margin: 5px; cursor: pointer; font-size: 16px;">üíæ Sauvegarder</button>' +
        	'<button onclick="cancelCourseEdit()" style="background: #6c757d; color: white; border: none; padding: 12px 24px; border-radius: 5px; margin: 5px; cursor: pointer; font-size: 16px;">‚ùå Annuler</button>' +
        	'</div>' +
    		'</div></div>';

    	// Ajouter la popup au body
    	var popup = document.createElement('div');
    	popup.id = 'editCoursePopup';
    	popup.innerHTML = formHtml;
    	document.body.appendChild(popup);
	}

	// Ajouter un nouveau d√©part dans l'√©dition
	function addEditTeeInput() {
    	var container = document.getElementById('editTeeInputs');
   		var newRow = document.createElement('div');
    	newRow.className = 'tee-form-row';
    	newRow.innerHTML = 
        	'<select>' +
        	'<option value="blanc">Blanc</option>' +
    		'<option value="bleu">Bleu</option>' +
    		'<option value="vert">Vert</option>' +
        	'<option value="jaune">Jaune</option>' +
        	'<option value="noir">Noir</option>' +
    		'</select>' +
    		'<input type="number" placeholder="Rating (ex: 69.5)" step="0.1" min="60" max="80">' +
        	'<input type="number" placeholder="Slope (ex: 123)" min="85" max="155">' +
        	'<input type="number" placeholder="Par (ex: 72)" min="68" max="76">' +
    		'<button type="button" class="btn-danger" onclick="removeEditTeeInput(this)">‚ùå</button>';
    	container.appendChild(newRow);
	}

	// Supprimer un d√©part dans l'√©dition
	function removeEditTeeInput(button) {
    	var container = document.getElementById('editTeeInputs');
    	if (container.children.length > 1) {
        	button.parentElement.remove();
    	} else {
        	alert('Un terrain doit avoir au moins un d√©part.');
    	}
	}

	// Sauvegarder les modifications du terrain
	function saveCourseEdit(originalCourseName) {
    	var newCourseName = document.getElementById('editCourseName').value.trim();
    	if (!newCourseName) {
        	alert('Veuillez saisir le nom du terrain.');
        	return;
    	}
    
    	// V√©rifier si le nouveau nom existe d√©j√† (sauf si c'est le m√™me)
    	if (newCourseName !== originalCourseName && coursesDatabase[newCourseName]) {
        	alert('Un terrain avec ce nom existe d√©j√†.');
        	return;
    	}
    
    	var teeRows = document.querySelectorAll('#editTeeInputs .tee-form-row');
    	var tees = [];
    
    	for (var i = 0; i < teeRows.length; i++) {
        	var row = teeRows[i];
        	var select = row.querySelector('select');
    		var ratingInput = row.querySelectorAll('input')[0];
   			var slopeInput = row.querySelectorAll('input')[1];
        	var parInput = row.querySelectorAll('input')[2];
        
        	var teeColor = select.value;
    		var rating = parseFloat(ratingInput.value);
    		var slope = parseInt(slopeInput.value);
			var par = parseInt(parInput.value);
        
        	if (!rating || !slope || !par || rating < 60 || rating > 80 || slope < 85 || slope > 155 || par < 68 || par > 76) {
        		alert('Veuillez remplir tous les champs avec des valeurs valides (Rating: 60-80, Slope: 85-155, Par: 68-76).');
        		return;
        		}
        
        	tees.push({
        		tee: teeColor,
        		rating: rating,
        		slope: slope,
            	par: par
        	});
    	}
    
    	// Si le nom a chang√©, supprimer l'ancien
    	if (newCourseName !== originalCourseName) {
    		delete coursesDatabase[originalCourseName];
        
        	// Mettre √† jour toutes les r√©f√©rences dans les parties existantes
        	for (var i = 0; i < courses.length; i++) {
        		if (courses[i] === originalCourseName) {
            		courses[i] = newCourseName;
            	}
        	}
        
        	// Mettre √† jour les rounds
        	for (var i = 0; i < rounds.length; i++) {
        		if (rounds[i].course === originalCourseName) {
            		rounds[i].course = newCourseName;
            	}
        	}
    	}
    
    	// Sauvegarder le terrain (nouveau nom ou modifi√©)
    	coursesDatabase[newCourseName] = tees;
    
		// Sauvegarder dans Firebase
    	Promise.all([
    		saveCoursesToFirebase(),
    		saveDatesToFirebase()
    	]).then(function() {
        	console.log('Terrain modifi√© dans Firebase');
        	var action = newCourseName !== originalCourseName ? 'renomm√© et modifi√©' : 'modifi√©';
    		alert('‚úÖ Terrain "' + newCourseName + '" ' + action + ' avec succ√®s!');
    		cancelCourseEdit();
			loadCoursesList();
        
    	}).catch(function(error) {
    		console.error('Erreur de modification terrain:', error);
    		alert('Erreur de modification: ' + error.message);
    	});
	}

	// Fermer la popup d'√©dition
	function cancelCourseEdit() {
    	var popup = document.getElementById('editCoursePopup');
    	if (popup) {
        	popup.remove();
    	}
	}
    function exportCourses() {
        var dataToExport = {
            courses: coursesDatabase,
            exportDate: new Date().toISOString(),
            totalCourses: Object.keys(coursesDatabase).length
        };
            
        var dataStr = JSON.stringify(dataToExport, null, 2);
        var dataBlob = new Blob([dataStr], {type: 'application/json'});
            
        var link = document.createElement('a');
        link.href = URL.createObjectURL(dataBlob);
        link.download = 'terrains-golf-' + new Date().toISOString().split('T')[0] + '.json';
        link.click();
    }

    function saveCourseData() {
        try {
            var dataString = JSON.stringify(coursesDatabase);
            // Simulate saving to storage
            console.log('Courses saved:', Object.keys(coursesDatabase).length + ' terrains');
        } catch (e) {
            console.error('Erreur de sauvegarde:', e);
        }
    }

    // Scores par joueur
    function loadPlayerSelector() {
    	var select = document.getElementById('playerSelect');
    	select.innerHTML = '<option value="">-- Choisir un joueur --</option>';
    
    	for (var i = 0; i < players.length; i++) {
        var player = players[i];
        var option = document.createElement('option');
        option.value = player.id;
        option.textContent = player.name || (player.firstName + ' ' + player.lastName); // CORRECTION
        select.appendChild(option);
    	}
	}

    function showPlayerDetail() {
    	var playerId = parseInt(document.getElementById('playerSelect').value);
    	var container = document.getElementById('playerDetail');
    
    	if (!playerId) {
        container.innerHTML = '';
        return;
    	}
    
    	var player = players.find(p => p.id === playerId);
    	var playerScores = scores.filter(s => s.playerId === playerId);
    
    	if (playerScores.length === 0) {
        container.innerHTML = '<div class="card"><p>Aucun score enregistr√© pour ce joueur.</p></div>';
        return;
    	}
    
    	var playerName = player.name || (player.firstName + ' ' + player.lastName); // CORRECTION
    
    	// Statistiques du joueur
    	var avgGross = playerScores.reduce((sum, s) => sum + s.score, 0) / playerScores.length;
    	var avgNet = playerScores.reduce((sum, s) => sum + s.net, 0) / playerScores.length;
    	var bestGross = Math.min(...playerScores.map(s => s.score));
    	var worstGross = Math.max(...playerScores.map(s => s.score));
    	var bestNet = Math.min(...playerScores.map(s => s.net));
    	var worstNet = Math.max(...playerScores.map(s => s.net));
    
    	var diabloScores = playerScores.filter(s => s.type === 'diablo');
    	var gprScores = playerScores.filter(s => s.type === 'gpr');
    
    	var html = '<div class="player-card">' +
               	   '<h3>üèåÔ∏è ' + playerName + ' (Handicap Index: ' + player.handicap + ')</h3>' +  // UTILISER playerName
               
               	   '<div class="player-stats">' +
                   '<div class="stat-box">' +
           	       '<div class="stat-value">' + playerScores.length + '</div>' +
           	       '<div class="stat-label">Parties Jou√©es</div>' +
           	       '</div>' +
                   '<div class="stat-box">' +
               	   '<div class="stat-value">' + avgGross.toFixed(1) + '</div>' +
                   '<div class="stat-label">Score Brut Moyen</div>' +
           	       '</div>' +
           	       '<div class="stat-box">' +
           	       '<div class="stat-value">' + avgNet.toFixed(1) + '</div>' +
               	   '<div class="stat-label">Score Net Moyen</div>' +
               	   '</div>' +
                   '<div class="stat-box">' +
           	       '<div class="stat-value">' + bestGross + '</div>' +
           	       '<div class="stat-label">Meilleur Score Brut</div>' +
           	       '</div>' +
               	   '<div class="stat-box">' +
               	   '<div class="stat-value">' + bestNet.toFixed(1) + '</div>' +
                   '<div class="stat-label">Meilleur Score Net</div>' +
           	       '</div>' +
           	       '<div class="stat-box">' +
           	       '<div class="stat-value">' + diabloScores.length + '</div>' +
               	   '<div class="stat-label">Parties Diablo</div>' +
               	   '</div>' +
                   '<div class="stat-box">' +
           	       '<div class="stat-value">' + gprScores.length + '</div>' +
           	       '<div class="stat-label">Parties GPR</div>' +
           	       '</div>' +
               	   '</div>' +
               
               	   '<h4>üìã Historique des Scores</h4>' +
                   '<div class="score-history">';
    
    	// Trier les scores par date (plus r√©cents en premier)
        playerScores.sort((a, b) => {
        var roundA = rounds.find(r => r.id === a.roundId);
        var roundB = rounds.find(r => r.id === b.roundId);
        return new Date(roundB.date) - new Date(roundA.date);
    	});
    
    	for (var i = 0; i < playerScores.length; i++) {
        var score = playerScores[i];
        var round = rounds.find(r => r.id === score.roundId);
        
        var scoreClass = '';
        if (score.score === bestGross) scoreClass = 'best-score';
        else if (score.score === worstGross) scoreClass = 'worst-score';
        
        var badgeClass = score.type === 'diablo' ? 'badge-diablo' : 'badge-gpr';
        var badgeText = score.type === 'diablo' ? 'üèÜ Diablo' : 'üéØ GPR';
        
        var teeIcon = score.tee === 'bleu' ? 'üîµ' : '‚ö™';
        
        html += '<div class="score-row">' +
                '<div>' +
                '<strong>' + round.date.split('-').reverse().join('/') + '</strong><br>' +
            	'<small>' + round.course + ' ' + teeIcon + ' ' + score.tee + '</small>' +
            	'</div>' +
            	'<div class="tournament-badge ' + badgeClass + '">' + badgeText + '</div>' +
            	'<div style="text-align: right;">' +
                '<span class="' + scoreClass + '">Brut: ' + score.score + '</span><br>' +
            	'<small>Handicap: ' + score.courseHandicap.toFixed(1) + ' | Net: ' + score.net.toFixed(1) + '</small>' +
            	'</div>' +
            	'</div>';
    	}
    
    	html += '</div></div>';
    	container.innerHTML = html;
	}

        // 1. REMPLACER LA FONCTION loadDiablo() par celle-ci :

	function loadDiablo() {
    	loadYearSelectors();
    
    	var selectedYear = document.getElementById('diabloYearSelect').value;
    
    	var diabloScores = scores.filter(s => {
        	return s.type === 'diablo' && (!selectedYear || s.year == selectedYear);
    	});

    	if (diabloScores.length === 0) {
        	document.getElementById('diabloContent').innerHTML = '<p>Aucune partie Diablo trouv√©e pour cette p√©riode.</p>';
        	document.getElementById('diabloStatus').innerHTML = '';
        	return;
    	}

    	updateDiabloStatus(selectedYear);

    	var playerStats = {};
    
    	for (var i = 0; i < diabloScores.length; i++) {
        	var score = diabloScores[i];
        	if (!playerStats[score.playerId]) {
            	var player = players.find(p => p.id === score.playerId);
            	var playerName = player ? (player.name || (player.firstName + ' ' + player.lastName)) : ('Joueur #' + score.playerId);
            
            	playerStats[score.playerId] = {
                	player: player,
                	playerName: playerName,
                	totalRounds: 0,
                	totalNet: 0
            	};
        	}
        	playerStats[score.playerId].totalRounds++;
        	playerStats[score.playerId].totalNet += score.net;
    	}

    	var leaderboard = [];
    	for (var playerId in playerStats) {
        	var stats = playerStats[playerId];
        	leaderboard.push({
            	player: stats.player,
            	playerName: stats.playerName,
            	rounds: stats.totalRounds,
            	avgNet: stats.totalNet / stats.totalRounds
        	});
    	}

    	leaderboard.sort((a, b) => a.avgNet - b.avgNet);

    	var yearText = selectedYear ? selectedYear : 'Toutes les ann√©es';
    	var html = '';
    
    	// === TABLEAU R√âCAPITULATIF DIABLO (existant) ===
    	html += '<div class="card" style="margin-top: 30px;">' +
        	    '<h4>üìä Tableau R√©capitulatif - Scores par Partie</h4>' +
            	'<div style="overflow-x: auto;">' +
            	'<table class="table" style="font-size: 12px;">' +
            	'<thead><tr><th>Joueur</th>';

    	var diabloRounds = rounds.filter(r => {
        	return r.type === 'diablo' && (!selectedYear || r.year == selectedYear);
    	});
    
    	diabloRounds.sort((a, b) => new Date(a.date) - new Date(b.date));
    
    	for (var i = 0; i < diabloRounds.length; i++) {
        	var round = diabloRounds[i];
        	var dateStr = round.date.split('-').reverse().join('/');
        	html += '<th style="writing-mode: vertical-rl; text-orientation: mixed; padding: 5px; min-width: 60px;">' + 
            	    dateStr + '</th>';
    	}
    
    	if (selectedYear && diabloRounds.length >= 3) {
        	html += '<th style="background: #8b1a1a !important; color: white !important; font-weight: bold; text-align: center;">Total Diablo</th>';
    	}
    
    	html += '</tr></thead><tbody>';
    	    
    	    // Construire les donn√©es pour chaque joueur
    	    var playerDiabloData = {};
    	    
    	    for (var i = 0; i < diabloScores.length; i++) {
        	    var score = diabloScores[i];
        	    if (!playerDiabloData[score.playerId]) {
            	    var player = players.find(p => p.id === score.playerId);
            	    var playerName = player ? (player.name || (player.firstName + ' ' + player.lastName)) : ('Joueur #' + score.playerId);
            	    
            	    playerDiabloData[score.playerId] = {
                	    playerName: playerName,
                	    scores: {},
                	    totalNet: 0,
                	    totalDiff: 0,
                	    gamesPlayed: 0
            	    };
        	    }
        	    
        	    // Calculer le diff√©rentiel
        	    var round = rounds.find(r => r.id === score.roundId);
        	    var differential = calculateScoreDifferentialReal(score.score, round.course, score.tee);
        	    
        	    playerDiabloData[score.playerId].scores[score.roundId] = {
            	    score: score.score,
            	    net: score.net,
            	    differential: differential
        	    };
        	    
        	    playerDiabloData[score.playerId].totalNet += score.net;
        	    playerDiabloData[score.playerId].totalDiff += differential || 0;
        	    playerDiabloData[score.playerId].gamesPlayed++;
    	    }
    	    
    	    // Convertir en array et trier
    	    var playersArray = [];
    	    for (var playerId in playerDiabloData) {
        	    playersArray.push({
            	    playerId: parseInt(playerId),
            	    data: playerDiabloData[playerId]
        	    });
    	    }
    	    
    	    // Trier par moyenne net ou total selon l'ann√©e
    	    if (selectedYear && diabloRounds.length >= 3) {
        	    // Trier par total des 3 parties - ceux qui n'ont pas jou√© les 3 parties vont √† la fin
        	    playersArray.sort((a, b) => {
            	    // Compter les parties jou√©es pour l'ann√©e
            	    var aPlayed = 0;
            	    var bPlayed = 0;
            	    
            	    for (var i = 0; i < diabloRounds.length; i++) {
                	    if (a.data.scores[diabloRounds[i].id]) aPlayed++;
                	    if (b.data.scores[diabloRounds[i].id]) bPlayed++;
            	    }
            	    
            	    // Si un joueur n'a pas jou√© toutes les parties, il va √† la fin (12e position)
            	    if (aPlayed < diabloRounds.length && bPlayed === diabloRounds.length) return 1;
            	    if (bPlayed < diabloRounds.length && aPlayed === diabloRounds.length) return -1;
            	    
            	    // Sinon, trier par total net
            	    return a.data.totalNet - b.data.totalNet;
        	    });
    	    } else {
        	    // Trier par moyenne
        	    playersArray.sort((a, b) => {
            	    var avgA = a.data.gamesPlayed > 0 ? a.data.totalNet / a.data.gamesPlayed : 999;
            	    var avgB = b.data.gamesPlayed > 0 ? b.data.totalNet / b.data.gamesPlayed : 999;
            	    return avgA - avgB;
        	    });
    	    }
    	    
    	    // Afficher les lignes
    	    for (var p = 0; p < playersArray.length; p++) {
        	    var playerData = playersArray[p];
        	    var data = playerData.data;
        	    
        	    // Style de ligne selon le rang
        	    var rowStyle = '';
        	    if (p === 0) rowStyle = ' style="background: #fff4e6;"'; // Or
        	    else if (p === 1) rowStyle = ' style="background: #f0f0f0;"'; // Argent
        	    else if (p === 2) rowStyle = ' style="background: #fff0e6;"'; // Bronze
        	    
        	    html += '<tr' + rowStyle + '><td><strong>' + (p + 1) + '. ' + data.playerName + '</strong></td>';
        	    
        	    // Scores pour chaque partie
        	    var partiesTotalNet = 0;
        	    var partiesTotalDiff = 0;
        	    var partiesCount = 0;
        	    
        	    for (var i = 0; i < diabloRounds.length; i++) {
            	    var round = diabloRounds[i];
            	    var scoreData = data.scores[round.id];
            	    
            	    if (scoreData) {
                	    // Obtenir le par du terrain
                	    var round = diabloRounds[i];
                	    var coursePar = 72; // Par d√©faut
                	    if (coursesDatabase[round.course]) {
                    	    var courseData = coursesDatabase[round.course];
                    	    var teeData = courseData.find(t => t.tee === (scoreData.tee || round.tee));
                    	    if (teeData && teeData.par) {
                        	    coursePar = teeData.par;
                    	    }
                	    }
                	    
                	    // Calculer le diff√©rentiel (score net - par)
                	    var differential = Math.round(scoreData.net) - coursePar;
                	    var differentialStr = differential > 0 ? '+' + differential : differential.toString();
                	    
                	    html += '<td style="text-align: center;">' +
                    	        '<span style="font-size: 16px; font-weight: bold;">' + differentialStr + '</span> ' +
                    	        '<span style="font-size: 12px;">(' + scoreData.score + ')</span></td>';
                    	        
                	    // Pour le calcul du total Diablo
                	    if (selectedYear) {
                    	    partiesTotalNet += scoreData.net;
                    	    partiesCount++;
                	    }
            	    } else {
                	    html += '<td style="text-align: center; color: #ccc;">-</td>';
            	    }
        	    }
        	    
        	    // Colonne Total si ann√©e sp√©cifique et au moins 3 parties
        	    if (selectedYear && diabloRounds.length >= 3) {
            	    if (partiesCount === diabloRounds.length) {
                	    // Calculer le total des pars pour les parties jou√©es
                	    var totalPar = 0;
                	    var totalScore = 0;
                	    
                	    for (var i = 0; i < diabloRounds.length; i++) {
                    	    var round = diabloRounds[i];
                    	    var scoreData = data.scores[round.id];
                    	    
                    	    if (scoreData) {
                        	    totalScore += scoreData.score;
                        	    
                        	    // Obtenir le par du terrain
                        	    var coursePar = 72; // Par d√©faut
                        	    if (coursesDatabase[round.course]) {
                            	        var courseData = coursesDatabase[round.course];
                            	        var teeData = courseData.find(t => t.tee === (scoreData.tee || round.tee));
                            	        if (teeData && teeData.par) {
                                	        coursePar = teeData.par;
                            	        }
                        	    }
                        	    totalPar += coursePar;
                    	    }
                	    }
                	    
                	    // Diff√©rentiel total (score net total - par total)
                	    var totalDifferential = Math.round(partiesTotalNet) - totalPar;
                	    var totalDiffStr = totalDifferential > 0 ? '+' + totalDifferential : totalDifferential.toString();
                	    
                	    html += '<td style="text-align: center; background: #8b1a1a; color: white;">' +
                    	        '<span style="font-size: 20px; font-weight: bold;">' + totalDiffStr + '</span> ' +
                    	        '<span style="font-size: 14px;">(' + totalScore + ')</span></td>';
            	    } else {
                	    html += '<td style="text-align: center; background: #8b1a1a; color: #999;">-</td>';
            	    }
        	    }
        	    
        	    html += '</tr>';
    	    }
    	    
    	    html += '</tbody></table></div>' +
            		'<div style="margin-top: 10px; font-size: 12px; color: #666;">' +
            		'<strong>L√©gende:</strong> Score brut (Diff√©rentiel) | ' +
            		'Le diff√©rentiel mesure la performance relative au parcours' +
            		'</div></div>';
    
    		// === NOUVEAU : D√âTAILS DE CHAQUE PARTIE DIABLO ===
    		html += '<div class="card" style="margin-top: 30px;">' +
            		'<h4>üìã D√©tails de chaque Partie</h4>';

    		for (var i = 0; i < diabloRounds.length; i++) {
       			var round = diabloRounds[i];
        		var roundScores = scores.filter(s => s.roundId === round.id);
        
        		if (roundScores.length === 0) continue;
        
        		// Obtenir le par du terrain
        		var coursePar = 72; // Par d√©faut
        		if (coursesDatabase[round.course]) {
            		var courseData = coursesDatabase[round.course];
            		var teeData = courseData.find(t => t.tee === round.tee);
            		if (teeData && teeData.par) {
                		coursePar = teeData.par;
            		}
        		}
        
        		html += '<div style="margin: 15px 0; padding: 15px; border: 2px solid #8b1a1a; border-radius: 10px; background: #fff8f8;">' +
                		'<div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 15px;">' +
                		'<div>' +
                		'<strong style="color: #8b1a1a; font-size: 16px;">üèÜ ' + round.date.split('-').reverse().join('/') + ' - ' + round.course + '</strong>' +
                		'<br><small>D√©part: ' + round.tee + ' | Par: ' + coursePar + ' | ' + roundScores.length + ' joueurs</small>' +
                		'</div>' +
                		'<button class="btn-secondary" onclick="toggleDiabloRoundDetail(\'diablo_round_' + round.id + '\')">üëÅÔ∏è Voir/Masquer</button>' +
                		'</div>';

        		html += '<div id="diablo_round_' + round.id + '" style="display: block;">' +
                		'<table class="table" style="font-size: 13px;">' +
                		'<thead>' +
                		'<tr style="background: #8b1a1a; color: white;">' +
                		'<th>Pos</th>' +
                		'<th>Joueur</th>' +
                		'<th>Score Brut</th>' +
                		'<th>Diff. Brut</th>' +
                		'<th>Hcp Parcours</th>' +
                		'<th>Score Net</th>' +
                		'<th>Diff. Net</th>' +
                		'<th>Diff√©rentiel</th>' +
                		'</tr>' +
                		'</thead>' +
                		'<tbody>';
        
        		// Trier par score net
        		roundScores.sort((a, b) => a.net - b.net);
        
        		for (var j = 0; j < roundScores.length; j++) {
            		var score = roundScores[j];
            
            		// Calculer les diff√©rentiels
            		var brutDiff = score.score - coursePar;
            		var netDiff = Math.round(score.net) - coursePar;
            		var differential = calculateScoreDifferentialReal(score.score, round.course, score.tee);
            
            		// Style pour le podium
            		var rowStyle = '';
            		if (j === 0) rowStyle = ' style="background: #fff4e6;"'; // Or
            		else if (j === 1) rowStyle = ' style="background: #f0f0f0;"'; // Argent
            		else if (j === 2) rowStyle = ' style="background: #fff0e6;"'; // Bronze
            
            		// Formatage des diff√©rentiels
            		var brutDiffStr = brutDiff > 0 ? '+' + brutDiff : brutDiff.toString();
            		var netDiffStr = netDiff > 0 ? '+' + netDiff : netDiff.toString();
            		var diffStr = differential ? differential.toFixed(1) : 'N/A';
            
            		// Ic√¥ne selon la position
            		var posIcon = '';
            		if (j === 0) posIcon = 'ü•á ';
            		else if (j === 1) posIcon = 'ü•à ';
            		else if (j === 2) posIcon = 'ü•â ';
            
            		html += '<tr' + rowStyle + '>' +
                    		'<td><strong>' + posIcon + (j + 1) + '</strong></td>' +
                    		'<td><strong>' + score.playerName + '</strong></td>' +
                    		'<td style="text-align: center; font-weight: bold;">' + score.score + '</td>' +
                    		'<td style="text-align: center; color: ' + (brutDiff < 0 ? '#28a745' : brutDiff > 0 ? '#dc3545' : '#333') + ';">' +
                    		'<strong>' + brutDiffStr + '</strong></td>' +
                    		'<td style="text-align: center;">' + score.courseHandicap.toFixed(1) + '</td>' +
                    		'<td style="text-align: center; font-weight: bold; color: #8b1a1a;">' + Math.round(score.net) + '</td>' +
                    		'<td style="text-align: center; color: ' + (netDiff < 0 ? '#28a745' : netDiff > 0 ? '#dc3545' : '#333') + ';">' +
                    		'<strong>' + netDiffStr + '</strong></td>' +
                    		'<td style="text-align: center;">' + diffStr + '</td>' +
                    		'</tr>';
        		}
        
        		html += '</tbody></table>';
        
        		// Statistiques de la partie
        		var avgBrut = roundScores.reduce((sum, s) => sum + s.score, 0) / roundScores.length;
        		var avgNet = roundScores.reduce((sum, s) => sum + s.net, 0) / roundScores.length;
        		var bestBrut = Math.min(...roundScores.map(s => s.score));
        		var bestNet = Math.min(...roundScores.map(s => s.net));
        
        		html += '<div style="margin-top: 10px; padding: 10px; background: #ffe8e8; border-radius: 5px; font-size: 12px;">' +
                		'<strong>üìä Statistiques de la partie:</strong><br>' +
                		'<div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(150px, 1fr)); gap: 10px; margin-top: 5px;">' +
                		'<div>üèåÔ∏è Meilleur brut: <strong>' + bestBrut + '</strong></div>' +
                		'<div>üéØ Meilleur net: <strong>' + Math.round(bestNet) + '</strong></div>' +
                		'<div>üìà Moyenne brut: <strong>' + avgBrut.toFixed(1) + '</strong></div>' +
                		'<div>üìä Moyenne net: <strong>' + avgNet.toFixed(1) + '</strong></div>' +
                		'</div>' +
                		'</div>';
        
        		html += '</div></div>';
    		}
    
    		// Statistiques globales du tournoi
    		if (diabloRounds.length > 0) {
        		html += '<div style="margin-top: 20px; padding: 15px; background: #8b1a1a; color: white; border-radius: 8px;">' +
                		'<h5 style="margin: 0 0 10px 0;">üèÜ R√©sum√© du Tournoi Diablo ' + yearText + '</h5>' +
                		'<div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(200px, 1fr)); gap: 15px;">' +
                		'<div>üìÖ Nombre de parties: <strong>' + diabloRounds.length + '</strong></div>' +
                		'<div>üë• Participants uniques: <strong>' + leaderboard.length + '</strong></div>' +
                		'<div>ü•á Leader actuel: <strong>' + (leaderboard[0] ? leaderboard[0].playerName : 'N/A') + '</strong></div>' +
                		'<div>üéØ Meilleur moyenne net: <strong>' + (leaderboard[0] ? leaderboard[0].avgNet.toFixed(1) : 'N/A') + '</strong></div>' +
                		'</div>' +
                		'</div>';
    		}
    
    		html += '</div>';
    
    		document.getElementById('diabloContent').innerHTML = html;
		}

		// Fonction pour afficher/masquer les d√©tails d'une partie Diablo
		function toggleDiabloRoundDetail(roundId) {
    		var element = document.getElementById(roundId);
    		if (element.style.display === 'none') {
        		element.style.display = 'block';
    		} else {
        		element.style.display = 'none';
    		}
		}

	// FONCTION loadGPR
	function loadGPR() {
	    loadYearSelectors();
    	console.log('=== D√âBUT loadGPR ===');

    	// D√âCLARER TOUTES LES VARIABLES AU D√âBUT DE LA FONCTION
    	playerPoints = {};
    	playerBest4Points = {};
    	roundDetails = [];

    	var selectedYear = document.getElementById('gprYearSelect').value;

    	var gprScores = scores.filter(s => {
        	return s.type === 'gpr' && (!selectedYear || s.year == selectedYear);
    	});

    	if (gprScores.length === 0) {
        	document.getElementById('gprContent').innerHTML = '<p>Aucune partie GPR trouv√©e pour cette p√©riode.</p>';
        	document.getElementById('gprStatus').innerHTML = '';
        	return;
    	}

    	updateGPRStatus(selectedYear);

    	var gprRounds = rounds.filter(r => {
        	return r.type === 'gpr' && (!selectedYear || r.year == selectedYear);
    	});
    
    	console.log('=== FILTRAGE PAR ANN√âE ===');
    	console.log('Ann√©e s√©lectionn√©e:', selectedYear);
    	console.log('Scores GPR trouv√©s:', gprScores.length);

    	// S√©parer les parties Exhibition et Finale
    	var exhibitionRounds = gprRounds.filter(r => !r.gprPhase || r.gprPhase === 'exhibition');
    	var finaleRounds = gprRounds.filter(r => r.gprPhase === 'finale');
    
    	// Pour le tableau r√©capitulatif, on veut TOUTES les finales si "Toutes les ann√©es"
    	var allFinaleRoundsForTable = finaleRounds;
    	if (!selectedYear) {
        	// Si "Toutes les ann√©es", prendre toutes les finales GPR
        	allFinaleRoundsForTable = rounds.filter(r => 
            	r.type === 'gpr' && 
            	r.gprPhase === 'finale'
        	);
    	}
    
    	console.log('Finales pour le tableau:', allFinaleRoundsForTable.length);
    	console.log('=== S√âPARATION DES ROUNDS GPR ===');
    	console.log('Total rounds GPR:', gprRounds.length);
    	console.log('Rounds exhibition:', exhibitionRounds.length);
    	console.log('Rounds finale:', finaleRounds.length);

    	// IMPORTANT : Filtrer pour avoir SEULEMENT les vraies exhibitions (pas les finales)
    	exhibitionRounds = exhibitionRounds.filter(r => r.gprPhase !== 'finale');
    	console.log('Rounds exhibition apr√®s filtrage:', exhibitionRounds.length);

    	// === TRAITEMENT DES PARTIES EXHIBITION ===
    	var pointsScale = [120, 105, 90, 78, 70, 62, 54, 46, 38, 30, 22, 15];
    	var grossPointsScale = [80, 68, 60, 52, 45, 40, 35, 30, 25, 20, 15, 10];

    	// Points pour les finales
    	var finaleNetPointsScale = [225, 190, 165, 140, 125, 110, 90, 75, 60, 45, 35, 25];
    	var finaleBrutPointsScale = [175, 140, 120, 100, 85, 70, 60, 50, 40, 30, 20, 10];

    	for (var i = 0; i < exhibitionRounds.length; i++) {
        	var round = exhibitionRounds[i];
        	var roundScores = gprScores.filter(s => s.roundId === round.id && s.playerId !== 13);

        	// Identifier TOUS les joueurs GPR de l'ann√©e (pour les absents)
        	var allGPRPlayers = scores.filter(s => 
            	s.year === round.year && 
            	s.type === 'gpr' && 
            	s.playerId !== 13
        	).map(s => s.playerId).filter((v, i, a) => a.indexOf(v) === i);

        	// Ajouter les absents avec score fictif √©lev√©
        	var presentPlayers = roundScores.map(s => s.playerId);
        	for (var p = 0; p < allGPRPlayers.length; p++) {
            	var playerId = allGPRPlayers[p];
            	if (!presentPlayers.includes(playerId)) {
                	var player = players.find(p => p.id === playerId);
                	// Ajouter un score fictif pour l'absent
                	roundScores.push({
                    	playerId: playerId,
                    	playerName: player.name || (player.firstName + ' ' + player.lastName),
                    	score: 999, // Score tr√®s √©lev√©
                    	net: 999,   // Net tr√®s √©lev√©
                    	absent: true
                	});
            	}
        	}

        	console.log('Partie du', round.date, '- Joueurs:', roundScores.length, '(dont absents)');

        	// Classement par score net avec gestion des ex-√¶quo
        	var netGroups = {};
        	roundScores.forEach(function(score, index) {
            	var netValue = score.net;
            	if (!netGroups[netValue]) {
                	netGroups[netValue] = [];
            	}
            	netGroups[netValue].push({score: score, originalIndex: index});
        	});

        	// Trier les groupes
        	var sortedNetGroups = Object.keys(netGroups).sort((a, b) => parseFloat(a) - parseFloat(b));

        	var netRanking = [];
        	var currentPosition = 0;

        	for (var g = 0; g < sortedNetGroups.length; g++) {
            	var group = netGroups[sortedNetGroups[g]];
            	var totalPoints = 0;

            	// Calculer les points totaux pour ce groupe
            	for (var j = 0; j < group.length; j++) {
                	totalPoints += pointsScale[Math.min(currentPosition + j, pointsScale.length - 1)];
            	}

            	var pointsPerPlayer = Math.round(totalPoints / group.length);

            	// Attribuer les points
            	for (var j = 0; j < group.length; j++) {
                	netRanking.push({
                    	player: group[j].score,
                    	position: currentPosition + 1,
                    	points: pointsPerPlayer
                	});
            	}

            	currentPosition += group.length;
        	}

        	// Faire la m√™me chose pour le classement brut
        	var grossGroups = {};
        	roundScores.forEach(function(score, index) {
            	var grossValue = score.score;
            	if (!grossGroups[grossValue]) {
                	grossGroups[grossValue] = [];
            	}
            	grossGroups[grossValue].push({score: score, originalIndex: index});
        	});

        	var sortedGrossGroups = Object.keys(grossGroups).sort((a, b) => parseFloat(a) - parseFloat(b));

        	var grossRanking = [];
        	currentPosition = 0;

        	for (var g = 0; g < sortedGrossGroups.length; g++) {
            	var group = grossGroups[sortedGrossGroups[g]];
            	var totalPoints = 0;

            	for (var j = 0; j < group.length; j++) {
                	totalPoints += grossPointsScale[Math.min(currentPosition + j, grossPointsScale.length - 1)];
            	}

            	var pointsPerPlayer = Math.round(totalPoints / group.length);

            	for (var j = 0; j < group.length; j++) {
                	grossRanking.push({
                    	player: group[j].score,
                    	position: currentPosition + 1,
                    	points: pointsPerPlayer
                	});
            	}

            	currentPosition += group.length;
        	}

        	// CR√âER LE ROUNDDETAIL
        	var roundDetail = {
            	round: round,
            	netRanking: netRanking,
            	grossRanking: grossRanking,
            	isExhibition: true,
            	isFinale: false
        	};

        	roundDetails.push(roundDetail);

        	// ACCUMULER LES POINTS POUR CHAQUE JOUEUR
        	for (var k = 0; k < roundScores.length; k++) {
            	var score = roundScores[k];

            	// Ne pas Ignorer les absents - ils doivent recevoir leur points!
                    
            	if (!playerPoints[score.playerId]) {
                	var player = players.find(p => p.id === score.playerId);
                	var playerName = player ? (player.name || (player.firstName + ' ' + player.lastName)) : ('Joueur #' + score.playerId);

                	playerPoints[score.playerId] = {
                    	player: player,
                    	playerName: playerName,
                    	totalPoints: 0,
                    	rounds: 0,
                    	exhibitionPoints: 0,
                    	finalePoints: 0,
                    	details: []
                	};
            	}

            	if (!playerBest4Points[score.playerId]) {
                	var player = players.find(p => p.id === score.playerId);
                	var playerName = player ? (player.name || (player.firstName + ' ' + player.lastName)) : ('Joueur #' + score.playerId);

                	playerBest4Points[score.playerId] = {
                    	player: player,
                    	playerName: playerName,
                    	best4Points: 0,
                    	finalePoints: 0,
                    	totalBest4: 0,
                    	best4Details: []
                	};
            	}

            	// Trouver les points pour ce joueur dans cette partie
            	var netResult = netRanking.find(r => r.player.playerId === score.playerId);
            	var grossResult = grossRanking.find(r => r.player.playerId === score.playerId);

            	var netPoints = netResult ? netResult.points : 0;
            	var grossPoints = grossResult ? grossResult.points : 0;
            	var totalRoundPoints = netPoints + grossPoints;

            	playerPoints[score.playerId].totalPoints += totalRoundPoints;
            	playerPoints[score.playerId].exhibitionPoints += totalRoundPoints;
            	playerPoints[score.playerId].rounds++;

            	// Stocker les d√©tails de cette partie exhibition
            	playerPoints[score.playerId].details.push({
                	round: round,
                	grossScore: score.score,
                	netScore: score.net,
                	grossPosition: grossResult ? grossResult.position : '-',
                	netPosition: netResult ? netResult.position : '-',
                	grossPoints: grossPoints,
                	netPoints: netPoints,
                	totalRoundPoints: totalRoundPoints,
                	courseHandicap: score.courseHandicap,
                	type: 'exhibition'
            	});
        	}
    	} // FIN DE LA BOUCLE DES EXHIBITIONS

    	// === CALCUL DES 4 MEILLEURES PARTIES ===
		var yearToCalculate = selectedYear ? parseInt(selectedYear) : new Date().getFullYear();
		console.log('Ann√©e pour calcul best4:', yearToCalculate, 'Type:', typeof yearToCalculate);
    	console.log('=== DEBUG CALCUL FINALE ===');
    	console.log('Ann√©e pour calcul finale:', yearToCalculate);
    	console.log('Type de yearToCalculate:', typeof yearToCalculate);
    	console.log('selectedYear:', selectedYear, 'type:', typeof selectedYear);
    
    	// DEBUG: V√©rifier les finales
    	console.log('=== DEBUG FINALES ===');
    	console.log('Ann√©e calcul√©e:', yearToCalculate);
    	var testFinaleRounds = rounds.filter(r => r.year === yearToCalculate && r.gprPhase === 'finale');
    	console.log('Parties finale trouv√©es:', testFinaleRounds);
    
    	for (var playerId in playerPoints) {
    		var playerIdInt = parseInt(playerId);
    
    		// S'assurer que playerBest4Points[playerId] existe
    		if (!playerBest4Points[playerId]) {
        		var player = players.find(p => p.id === playerIdInt);
        		playerBest4Points[playerId] = {
            		player: player,
            		playerName: player.name || (player.firstName + ' ' + player.lastName),
            		best4Points: 0,
            		finalePoints: 0,
            		totalBest4: 0,
            		best4Details: []
        		};
    		}
    
    		// Calculer les 4 meilleures exhibitions
    		var yearForCalculation = selectedYear ? parseInt(selectedYear) : new Date().getFullYear();
    		var best4Results = calculateBest4Exhibition(playerIdInt, yearForCalculation);
    
    		console.log('Calcul best4 pour joueur', playerId, 'ann√©e', yearForCalculation, ':', best4Results.length, 'parties');
    
    		var best4Total = 0;
    		playerBest4Points[playerId].best4Details = []; // R√©initialiser
    
    		for (var i = 0; i < best4Results.length; i++) {
        		best4Total += best4Results[i].totalPoints;
        
        		playerBest4Points[playerId].best4Details.push({
            		round: rounds.find(r => r.id === best4Results[i].roundId),
            		grossScore: best4Results[i].score.score,
            		netScore: best4Results[i].score.net,
            		grossPosition: best4Results[i].brutPos,
            		netPosition: best4Results[i].netPos,
            		grossPoints: best4Results[i].brutPoints,
            		netPoints: best4Results[i].netPoints,
            		totalRoundPoints: best4Results[i].totalPoints,
            		isSelected: true,
            		roundId: best4Results[i].roundId // Ajouter l'ID pour faciliter la v√©rification
        		});
    		}
    
    		playerBest4Points[playerId].best4Points = best4Total;
    		playerBest4Points[playerId].totalBest4 = best4Total;
    
    		console.log('Best4 total pour', playerBest4Points[playerId].playerName, ':', best4Total);
		}

    	// === TRAITEMENT DES FINALES (400 POINTS FIXES) ===
    	if (finaleRounds.length > 0) {
        	var finaleResults = calculateFinaleScores(yearToCalculate);

        	// Ajouter les points finale aux totaux des joueurs
        	for (var playerId in finaleResults) {
            	var finaleData = finaleResults[playerId];

            	if (!playerPoints[playerId]) {
                	playerPoints[playerId] = {
                    	player: finaleData.player,
                    	playerName: finaleData.player.name || (finaleData.player.firstName + ' ' + finaleData.player.lastName),
                    	totalPoints: 0,
                    	rounds: 0,
                    	exhibitionPoints: 0,
                    	finalePoints: 0,
                    	details: []
                	};
            	}

            	if (!playerBest4Points[playerId]) {
                	playerBest4Points[playerId] = {
                    	player: finaleData.player,
                    	playerName: finaleData.player.name || (finaleData.player.firstName + ' ' + finaleData.player.lastName),
                    	best4Points: 0,
                    	finalePoints: 0,
                    	totalBest4: 0,
                    	best4Details: []
                	};
            	}

            	// Les points finale sont d√©j√† corrects (400 points total)
            	var finalePoints = finaleData.totalPointsFinale || 0;
            	console.log('=== DEBUG MULTIPLICATION ===');
            	console.log('Joueur:', finaleData.player.name);
            	console.log('finaleData.totalPointsFinale:', finaleData.totalPointsFinale);
            	console.log('finaleData.daysPlayed:', finaleData.daysPlayed);
            	console.log('finalePoints utilis√©s:', finalePoints);

            	console.log('Joueur', finaleData.player.name, 'Points finale:', finalePoints);

            	playerPoints[playerId].totalPoints += finalePoints;
            	playerPoints[playerId].finalePoints = finalePoints;

            	playerBest4Points[playerId].finalePoints = finalePoints;
            	playerBest4Points[playerId].totalBest4 += finalePoints;

            	// Ajouter d√©tail finale
            	var finaleDetail = {
                	type: 'finale',
                	totalBrut: finaleData.totalBrut,
                	totalNet: finaleData.totalNet,
                	daysPlayed: finaleData.daysPlayed,
                	brutPosition: finaleData.positionBrut,
                	netPosition: finaleData.positionNet,
                	brutPoints: finaleData.pointsBrut,
                	netPoints: finaleData.pointsNet,
               		totalRoundPoints: finalePoints,
                	absent: finaleData.daysPlayed === 0
            	};

            	playerPoints[playerId].details.push(finaleDetail);
        	}

        	// Debug
        	console.log('=== V√âRIFICATION FINALE GPR ===');
        	var totalPointsDistribues = 0;
        	for (var playerId in finaleResults) {
            	totalPointsDistribues += finaleResults[playerId].totalPointsFinale || 0;
        	}
        	console.log('Total points finale distribu√©s:', totalPointsDistribues);

        	// Debug pour voir qui manque
        	console.log('=== DEBUG JOUEURS MANQUANTS ===');
        	for (var playerId in finaleResults) {
            	if (!playerPoints[playerId]) {
                	console.log('Joueur manquant dans playerPoints:', playerId, finaleResults[playerId].player.name);
            	}
        	}

        	// Ajouter les joueurs qui ont SEULEMENT des points de finale (absents √† toutes les exhibitions)
        	for (var playerId in finaleResults) {
            	if (!playerPoints[playerId]) {
                	var finaleData = finaleResults[playerId];

                	playerPoints[playerId] = {
                    	player: finaleData.player,
                    	playerName: finaleData.player.name || (finaleData.player.firstName + ' ' + finaleData.player.lastName),
                    	totalPoints: 0,
                    	rounds: 0,
                    	exhibitionPoints: 0,
                    	finalePoints: 0,
                    	details: []
                	};

                	console.log('Ajout joueur absent exhibitions:', playerPoints[playerId].playerName);
            	}

            	if (!playerBest4Points[playerId]) {
                	var finaleData = finaleResults[playerId];

                	playerBest4Points[playerId] = {
                    	player: finaleData.player,
                    	playerName: finaleData.player.name || (finaleData.player.firstName + ' ' + finaleData.player.lastName),
                    	best4Points: 0,
                    	finalePoints: 0,
                    	totalBest4: 0,
                    	best4Details: []
                	};
            	}
        	}
    	}

    	// Cr√©er les classements
    	var leaderboardComplete = [];
    	var leaderboardBest4 = [];

    	for (var playerId in playerPoints) {
        	var stats = playerPoints[playerId];
        	leaderboardComplete.push({
            	player: stats.player,
            	playerName: stats.playerName,
            	rounds: stats.rounds,
            	totalPoints: stats.totalPoints,
            	exhibitionPoints: stats.exhibitionPoints,
            	finalePoints: stats.finalePoints,
            	details: stats.details,
            	averagePoints: stats.rounds > 0 ? stats.totalPoints / stats.rounds : 0
        	});
    	}

    	for (var playerId in playerBest4Points) {
        	var stats = playerBest4Points[playerId];
        	leaderboardBest4.push({
            	player: stats.player,
            	playerName: stats.playerName,
            	best4Points: stats.best4Points,
            	finalePoints: stats.finalePoints,
            	totalBest4: stats.totalBest4,
            	best4Details: stats.best4Details,
            	partiesCount: stats.best4Details.length
        	});
    	}

    	leaderboardComplete.sort((a, b) => b.totalPoints - a.totalPoints);
    	leaderboardBest4.sort((a, b) => b.totalBest4 - a.totalBest4);

    	var yearText = selectedYear ? selectedYear : 'Toutes les ann√©es';

    	// Affichage du classement g√©n√©ral
    	var html = '<div class="card"><h3>Coupe GPR - ' + yearText
        	       
    	// === TABLEAU R√âCAPITULATIF DES POINTS PAR PARTIE ===
    	html += '<div class="card">' +
        	    '<h4>üìä Tableau R√©capitulatif - Points par Partie</h4>' +
            	'<p style="font-size: 14px; color: #666;">Les 4 meilleures parties d\'exhibition sont marqu√©es d\'une ‚≠ê</p>' +
            	'<div style="overflow-x: auto;">' +
            	'<table class="table" style="font-size: 12px;">' +
            	'<thead><tr><th>Joueur</th>';

    	// Combiner toutes les parties (exhibitions + finales) et trier par date
    	var allGameRounds = [];
    	
    	// Ajouter les exhibitions
    	for (var i = 0; i < exhibitionRounds.length; i++) {
        	var round = exhibitionRounds[i];
        	allGameRounds.push({
            	round: round,
            	type: 'exhibition',
            	date: round.date,
            	dateObj: new Date(round.date)
        	});
    	}
    	
    	// Ajouter les finales
    	for (var i = 0; i < allFinaleRoundsForTable.length; i++) {
        	var finaleRound = allFinaleRoundsForTable[i];
        	allGameRounds.push({
            	round: finaleRound,
            	type: 'finale',
            	date: finaleRound.date,
            	dateObj: new Date(finaleRound.date)
        	});
    	}
    	
    	// Trier par date chronologique
    	allGameRounds.sort((a, b) => a.dateObj - b.dateObj);

    	// En-t√™tes des colonnes (toutes les parties par ordre chronologique)
		for (var i = 0; i < allGameRounds.length; i++) {
    		var gameRound = allGameRounds[i];
    		var dateStr = gameRound.date.split('-').reverse().join('/');
    
    		if (gameRound.type === 'finale') {
        		var year = gameRound.round.year;
        		html += '<th style="background: #1e3a8a; color: white; font-weight: bold; text-align: center; padding: 8px;">Finale ' + year + '<br>' + dateStr + '</th>';
    		} else {
        		html += '<th style="writing-mode: vertical-rl; text-orientation: mixed; padding: 5px; min-width: 60px;">' + dateStr + '</th>';
    		}
		}

		// Ajouter les colonnes Best4 et Total SEULEMENT si une ann√©e sp√©cifique est s√©lectionn√©e
		if (selectedYear) {
    		html += '<th style="background: #ff6b35; color: white; font-weight: bold; text-align: center;">Best 4</th>';
    		html += '<th style="background: #8b1a1a; color: white; font-weight: bold; text-align: center;">Total</th>';
		}

		html += '</tr></thead><tbody>';

    	// Trier les joueurs par total de points d√©croissant
    	var allPlayers = Object.keys(playerPoints).map(id => ({
        	id: parseInt(id),
        	data: playerPoints[id],
        	best4Data: playerBest4Points[id]
    	}));
    	
    	// Trier selon que c'est une ann√©e sp√©cifique ou toutes les ann√©es
    	if (selectedYear) {
        	// Pour une ann√©e sp√©cifique, trier par Best4 + Finale
        	allPlayers.sort((a, b) => {
            	var totalA = (a.best4Data ? (a.best4Data.best4Points + a.best4Data.finalePoints) : 0);
            	var totalB = (b.best4Data ? (b.best4Data.best4Points + b.best4Data.finalePoints) : 0);
            	return totalB - totalA;
        	});
    	} else {
        	// Pour toutes les ann√©es, trier par total de tous les points
        	allPlayers.sort((a, b) => b.data.totalPoints - a.data.totalPoints);
    	}

    	// Lignes pour chaque joueur
    	for (var p = 0; p < allPlayers.length; p++) {
        	var playerData = allPlayers[p];
        	var playerId = playerData.id;
        	var player = playerData.data;
        	var best4Info = playerData.best4Data;

        	// Style de ligne selon le rang
        	var rowStyle = '';
        	if (p === 0) rowStyle = ' style="background: #fff4e6;"'; // Or
        	else if (p === 1) rowStyle = ' style="background: #f0f0f0;"'; // Argent
        	else if (p === 2) rowStyle = ' style="background: #fff0e6;"'; // Bronze

        	html += '<tr' + rowStyle + '><td><strong>' + (p + 1) + '. ' + player.playerName + '</strong></td>';

        	// Points pour chaque partie dans l'ordre chronologique
			for (var i = 0; i < allGameRounds.length; i++) {
    			var gameRound = allGameRounds[i];
    
    			if (gameRound.type === 'exhibition') {
        			// Traitement des parties exhibition
        			var round = gameRound.round;
        			var roundDetail = roundDetails.find(rd => rd.round.id === round.id);

        			// Chercher si le joueur a particip√©
        			var netResult = roundDetail ? roundDetail.netRanking.find(r => r.player.playerId === playerId) : null;
        			var grossResult = roundDetail ? roundDetail.grossRanking.find(r => r.player.playerId === playerId) : null;

        			if (netResult || grossResult) {
            			var netPts = netResult ? netResult.points : 0;
            			var grossPts = grossResult ? grossResult.points : 0;
            			var total = Math.round(netPts + grossPts);
            			var isAbsent = netResult && netResult.player.absent;
    
            			// Style pour les absents
            			var cellStyle = 'text-align: center;';
            			if (isAbsent) {
                			cellStyle += ' font-style: italic; color: #999;';
            			}
    
            			// Afficher les √©toiles et barr√©s SEULEMENT si une ann√©e est s√©lectionn√©e
            			if (selectedYear) {
                			// V√©rifier si cette partie fait partie des 4 meilleures
                			var isBest4 = false;
                			var best4Info = playerBest4Points[playerId];
        
                			if (best4Info && best4Info.best4Details) {
                    			isBest4 = best4Info.best4Details.some(detail => 
                        			detail.roundId === round.id
                    			);
                			}
        
                			// Barrer si plus de 4 parties et pas dans best4
                			if (!isAbsent && best4Info && best4Info.best4Details.length >= 4 && !isBest4) {
                    			cellStyle += ' text-decoration: line-through; color: #ccc;';
                			}
        
                			html += '<td style="' + cellStyle + '">' + 
                        			(isBest4 ? '‚≠ê ' : '') + total + 
                        			'<br><small>(' + Math.round(grossPts) + '+' + Math.round(netPts) + ')</small></td>';
            			} else {
                			// Pas d'√©toiles ni de barr√©s pour "Toutes les ann√©es"
                			html += '<td style="' + cellStyle + '">' + 
                        			total + 
                        			'<br><small>(' + Math.round(grossPts) + '+' + Math.round(netPts) + ')</small></td>';
            			}
        			} else {
            			html += '<td style="text-align: center; color: #ccc;">-</td>';
        			}
    
    			} else if (gameRound.type === 'finale') {
        			// Traitement des parties finale
        			var finaleRound = gameRound.round;
        			var year = finaleRound.year;

        			// Chercher les points de cette ann√©e de finale
        			var finaleDetail = player.details.find(d => 
            			d.type === 'finale' && 
            			rounds.find(r => r.year == year && r.gprPhase === 'finale')
        			);

        			if (finaleDetail && finaleRound.year == year) {
            			var brutPts = Math.round(finaleDetail.brutPoints || 0);
            			var netPts = Math.round(finaleDetail.netPoints || 0);
            			// Pour finale multi-jours, diviser par le nombre de jours
            			var nbJoursFinale = allFinaleRoundsForTable.filter(r => r.year == year).length;
            			var totalPts = Math.round((finaleDetail.brutPoints + finaleDetail.netPoints) / nbJoursFinale);

            			html += '<td style="text-align: center; background: #1e3a8a; color: white; font-size: 16px; font-weight: bold;' + 
                    			(finaleDetail.absent ? ' font-style: italic; opacity: 0.7;' : '') + '">' +
                    			totalPts + '<br>' +
                    			'<small style="color: #cbd5e1; font-weight: normal;">(' + Math.round(brutPts/nbJoursFinale) + '+' + Math.round(netPts/nbJoursFinale) + ')</small></td>';
        			} else {
            			html += '<td style="text-align: center; background: #1e3a8a; color: #64748b; font-size: 16px; font-weight: bold;">-</td>';
        			}
    			}
			}

			// Afficher Best4 et Total SEULEMENT si une ann√©e sp√©cifique est s√©lectionn√©e
			if (selectedYear) {
    			// Total Best 4
    			var playerBest4Info = playerBest4Points[playerId];
    			var best4Points = playerBest4Info ? playerBest4Info.best4Points : 0;
    			var finalePoints = playerBest4Info ? playerBest4Info.finalePoints : 0;
    			
    			html += '<td style="text-align: center; background: #ff6b35; color: white; font-size: 16px; font-weight: bold;">' + 
            			Math.round(best4Points) + '</td>';
    
    			// Total FINAL = Best 4 + Finale (c'est ce qui d√©termine le vainqueur)
    			var totalFinal = best4Points + finalePoints;
    			html += '<td style="text-align: center; background: #8b1a1a; color: white; font-size: 16px; font-weight: bold;">' + 
            			Math.round(totalFinal) + '</td>';
			}

			html += '</tr>';
    	}

    	html += '</tbody></table></div>' +
        	    '<div style="margin-top: 10px; font-size: 12px; color: #666;">' +
            	'<strong>L√©gende:</strong> Total (Brut+Net) | <em>Italique = Absent</em>' +
				(selectedYear ? ' | ‚≠ê = Compte dans les 4 meilleures | <s>Barr√©</s> = Ne compte pas' : '') +
            	'</div></div>';

    	// Affichage des parties individuelles
    	html += '<div class="card">' +
        	    '<h4>üìÖ D√©tails de chaque Partie</h4>';

    	for (var i = 0; i < roundDetails.length; i++) {
        	var roundDetail = roundDetails[i];
        	var round = roundDetail.round;

        	html += '<div style="margin: 15px 0; padding: 15px; border: 1px solid #ddd; border-radius: 8px; background: #f9f9f9;">' +
            	    '<div style="display: flex; justify-content: space-between; align-items: center;">' +
                	'<div>' +
                	'<strong>' + round.date.split('-').reverse().join('/') + ' - ' + round.course + ' (Exhibition)</strong>' +
                	'<br><small>' + roundDetail.netRanking.length + ' joueurs</small>' +
                	'</div>' +
                	'<button class="btn" onclick="toggleRoundDetail(\'round_' + round.id + '\')">üëÅÔ∏è Voir classements</button>' +
                	'</div>' +

                	'<div id="round_' + round.id + '" style="display: none; margin-top: 15px;">' +
                	'<div style="display: grid; grid-template-columns: 1fr 1fr; gap: 20px;">' +

                	// Classement net
                	'<div>' +
                	'<h5>üéØ Classement Score Net</h5>' +
                	'<table class="table" style="font-size: 14px;">' +
                	'<thead><tr><th>Pos</th><th>Joueur</th><th>Score Net</th><th>Points</th></tr></thead>' +
                	'<tbody>';

        	for (var j = 0; j < roundDetail.netRanking.length; j++) {
            	var result = roundDetail.netRanking[j];
            	var playerScore = result.player;

            	html += '<tr>' +
                	    '<td><strong>' + result.position + '</strong></td>' +
                    	'<td>' + playerScore.playerName + '</td>' +
                    	'<td><strong>' + (playerScore.net ? playerScore.net.toFixed(1) : 'N/A') + '</strong></td>' +
                    	'<td><span style="background: #28a745; color: white; padding: 2px 6px; border-radius: 10px;">' + result.points + '</span></td>' +
                    	'</tr>';
        	}

        	html += '</tbody></table></div>' +

            	    // Classement brut
                	'<div>' +
                	'<h5>üèåÔ∏è Classement Score Brut</h5>' +
                	'<table class="table" style="font-size: 14px;">' +
                	'<thead><tr><th>Pos</th><th>Joueur</th><th>Score Brut</th><th>Points</th></tr></thead>' +
                	'<tbody>';

        	for (var j = 0; j < roundDetail.grossRanking.length; j++) {
            	var result = roundDetail.grossRanking[j];
            	var playerScore = result.player;

            	html += '<tr>' +
                	    '<td><strong>' + result.position + '</strong></td>' +
                    	'<td>' + playerScore.playerName + '</td>' +
                    	'<td><strong>' + playerScore.score + '</strong></td>' +
                    	'<td><span style="background: #17a2b8; color: white; padding: 2px 6px; border-radius: 10px;">' + result.points + '</span></td>' +
                		'</tr>';
    		}

    		html += '</tbody></table></div>' +
            		'</div></div></div>';
		}

		html += '</div>';
		document.getElementById('gprContent').innerHTML = html;
	}

	// 2. FONCTION POUR AFFICHER/MASQUER LES D√âTAILS D'UNE PARTIE
	function toggleRoundDetail(roundId) {
    	    var element = document.getElementById(roundId);
    	    if (element.style.display === 'none') {
        	element.style.display = 'block';
    	    } else {
        	element.style.display = 'none';
    	    }
	}

	// 3. FONCTION POUR AFFICHER LES D√âTAILS D'UN JOUEUR GPR
	function showGPRPlayerDetails(playerId, selectedYear) {
    	    var gprScores = scores.filter(s => {
        	return s.type === 'gpr' && s.playerId === playerId && (!selectedYear || s.year == selectedYear);
    	    });
    
    	    if (gprScores.length === 0) {
        	alert('Aucune partie GPR trouv√©e pour ce joueur.');
        	return;
    	    }
    
    	    var player = players.find(p => p.id === playerId);
    	    var playerName = player ? (player.name || (player.firstName + ' ' + player.lastName)) : 'Joueur #' + playerId;
    
    	    var pointsScale = [120, 105, 90, 78, 70, 62, 54, 46, 38, 30, 22, 15];
    	    var grossPointsScale = [80, 68, 60, 52, 45, 40, 35, 30, 25, 20, 15, 10];
    
    	    var html = '<div style="position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.5); z-index: 1000; display: flex; justify-content: center; align-items: center;">' +
               	       '<div style="background: white; padding: 30px; border-radius: 10px; box-shadow: 0 4px 20px rgba(0,0,0,0.3); max-width: 800px; width: 90%; max-height: 80%; overflow-y: auto;">' +
               	       '<h3 style="margin-top: 0; color: #2c5530;">üìä D√©tails GPR - ' + playerName + '</h3>' +
               
               	       '<table class="table">' +
               	       '<thead><tr><th>Date</th><th>Terrain</th><th>Score Brut</th><th>Pos. Brut</th><th>Pts Brut</th><th>Score Net</th><th>Pos. Net</th><th>Pts Net</th><th>Total Pts</th></tr></thead>' +
               	       '<tbody>';
    
    	    var totalPoints = 0;
    
    	    // Trier par date
    	    gprScores.sort((a, b) => new Date(a.roundId) - new Date(b.roundId));
    
    	    for (var i = 0; i < gprScores.length; i++) {
        	var score = gprScores[i];
        	var round = rounds.find(r => r.id === score.roundId);
        
        	if (!round) continue;
        
        	// Trouver tous les scores de cette partie pour calculer les positions
        	var roundScores = scores.filter(s => s.roundId === score.roundId);
        
        	// Position brute
        	var grossRanking = [...roundScores].sort((a, b) => a.score - b.score);
        	var grossPosition = grossRanking.findIndex(s => s.playerId === playerId) + 1;
        	var grossPoints = grossPointsScale[Math.min(grossPosition - 1, grossPointsScale.length - 1)];
        
        	// Position nette
        	var netRanking = [...roundScores].sort((a, b) => a.net - b.net);
        	var netPosition = netRanking.findIndex(s => s.playerId === playerId) + 1;
        	var netPoints = pointsScale[Math.min(netPosition - 1, pointsScale.length - 1)];
        
        	var roundTotal = grossPoints + netPoints;
        	totalPoints += roundTotal;
        
        	html += '<tr>' +
                	'<td>' + round.date.split('-').reverse().join('/') + '</td>' +
                	'<td><small>' + round.course + '</small></td>' +
                	'<td><strong>' + score.score + '</strong></td>' +
                	'<td>' + grossPosition + '</td>' +
                	'<td><span style="background: #17a2b8; color: white; padding: 1px 5px; border-radius: 8px; font-size: 12px;">' + grossPoints + '</span></td>' +
                	'<td><strong>' + score.net.toFixed(1) + '</strong></td>' +
                	'<td>' + netPosition + '</td>' +
                	'<td><span style="background: #28a745; color: white; padding: 1px 5px; border-radius: 8px; font-size: 12px;">' + netPoints + '</span></td>' +
                	'<td><strong>' + roundTotal + '</strong></td>' +
                	'</tr>';
    	    }
    
    	    html += '</tbody></table>' +
            
            	    '<div style="margin-top: 20px; padding: 15px; background: #f8f9fa; border-radius: 8px; text-align: center;">' +
            	    '<strong>R√©sum√©:</strong> ' + gprScores.length + ' parties GPR | ' +
            	    '<strong>Total: ' + totalPoints + ' points</strong> | ' +
            	    '<strong>Moyenne: ' + (totalPoints / gprScores.length).toFixed(1) + ' pts/partie</strong>' +
            	    '</div>' +
            
            	    '<div style="margin-top: 25px; text-align: center;">' +
            	    '<button onclick="closeGPRPlayerDetails()" style="background: #6c757d; color: white; border: none; padding: 10px 20px; border-radius: 5px; cursor: pointer;">‚ùå Fermer</button>' +
            	    '</div>' +
            
            	    '</div></div>';
    
    	    // Ajouter la popup au body
    	    var popup = document.createElement('div');
    	    popup.id = 'gprPlayerDetailsPopup';
    	    popup.innerHTML = html;
    	    document.body.appendChild(popup);
	}

	// 4. FONCTION POUR FERMER LA POPUP DES D√âTAILS
	function closeGPRPlayerDetails() {
    	    var popup = document.getElementById('gprPlayerDetailsPopup');
    	    if (popup) {
        	popup.remove();
    	    }
	}
    
	function showGPRTab(tabName) {
    	// Fonction vide - plus n√©cessaire
    	return;
	}

	// Fonction pour afficher les d√©tails des 4 meilleures parties
	function showGPRBest4Details(playerId, selectedYear) {
    	var yearToCheck = selectedYear || new Date().getFullYear();
    	var best4Results = calculateBest4Exhibition(playerId, yearToCheck);
    
    	if (best4Results.length === 0) {
        	alert('Aucune partie exhibition trouv√©e pour ce joueur.');
        	return;
    	}
    
    	var player = players.find(p => p.id === playerId);
    	var playerName = player ? (player.name || (player.firstName + ' ' + player.lastName)) : 'Joueur #' + playerId;
    
    	var html = '<div style="position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.5); z-index: 1000; display: flex; justify-content: center; align-items: center;">' +
        	       '<div style="background: white; padding: 30px; border-radius: 10px; box-shadow: 0 4px 20px rgba(0,0,0,0.3); max-width: 900px; width: 90%; max-height: 80%; overflow-y: auto;">' +
            	   '<h3 style="margin-top: 0; color: #2c5530;">üèÜ S√©lection des 4 Meilleures Parties - ' + playerName + '</h3>' +
               
            	   '<div style="background: #e7f3ff; padding: 15px; border-radius: 8px; margin-bottom: 20px;">' +
            	   '<strong>R√®gle:</strong> Les 4 parties avec le plus de points totaux (brut + net) sont automatiquement s√©lectionn√©es. ' +
            	   'Si moins de 5 parties jou√©es, toutes les parties comptent.' +
            	   '</div>' +
               
            	   '<table class="table">' +
            	   '<thead><tr><th>üèÜ</th><th>Date</th><th>Terrain</th><th>Score Brut</th><th>Pos. Brut</th><th>Pts Brut</th><th>Score Net</th><th>Pos. Net</th><th>Pts Net</th><th>Total Pts</th></tr></thead>' +
            	   '<tbody>';
    
    	var totalPoints = 0;
    
    	for (var i = 0; i < best4Results.length; i++) {
        	var result = best4Results[i];
        	var round = rounds.find(r => r.id === result.roundId);
        
        	totalPoints += result.totalPoints;
        
        	html += '<tr style="background: #f8fff8;">' +
            	    '<td style="text-align: center;"><span style="color: #28a745; font-size: 16px;">‚úÖ</span></td>' +
            	    '<td>' + round.date.split('-').reverse().join('/') + '</td>' +
            	    '<td><small>' + round.course + '</small></td>' +
            	    '<td><strong>' + result.score.score + '</strong></td>' +
            	    '<td>' + result.brutPos + '</td>' +
            	    '<td><span style="background: #17a2b8; color: white; padding: 1px 5px; border-radius: 8px; font-size: 12px;">' + result.brutPoints + '</span></td>' +
            	    '<td><strong>' + result.score.net.toFixed(1) + '</strong></td>' +
           		    '<td>' + result.netPos + '</td>' +
            	    '<td><span style="background: #28a745; color: white; padding: 1px 5px; border-radius: 8px; font-size: 12px;">' + result.netPoints + '</span></td>' +
            	    '<td><strong style="color: #2c5530;">' + result.totalPoints + '</strong></td>' +
            	    '</tr>';
    	}
    
    	html += '</tbody></table>' +
		
        	    '<div style="margin-top: 20px; padding: 15px; background: #f8f9fa; border-radius: 8px; text-align: center;">' +
            	'<strong>R√©sum√©:</strong> ' + best4Results.length + ' partie(s) s√©lectionn√©e(s) | ' +
            	'<strong>Total Exhibition: ' + totalPoints + ' points</strong>';
    
    	// Ajouter les points de finale s'ils existent
    	var finalePoints = 0;
    	var finaleRounds = rounds.filter(r => r.type === 'gpr' && r.gprPhase === 'finale' && r.year === yearToCheck);
    
    	if (finaleRounds.length > 0) {
        	var finaleResults = calculateFinaleScores(yearToCheck);
        	if (finaleResults[playerId]) {
            	finalePoints = (finaleResults[playerId].pointsBrut || 0) + (finaleResults[playerId].pointsNet || 0);
            	html += ' | <strong>Points Finale: ' + finalePoints + '</strong>';
        	}
    	}
    
    	html += ' | <strong style="color: #e74c3c;">TOTAL OFFICIEL: ' + (totalPoints + finalePoints) + ' points</strong>' +
        	    '</div>' +
            
            	'<div style="margin-top: 25px; text-align: center;">' +
            	'<button onclick="closeGPRBest4Details()" style="background: #6c757d; color: white; border: none; padding: 10px 20px; border-radius: 5px; cursor: pointer;">‚ùå Fermer</button>' +
            	'</div>' +
            
            	'</div></div>';
    
    	// Ajouter la popup au body
    	var popup = document.createElement('div');
    	popup.id = 'gprBest4DetailsPopup';
    	popup.innerHTML = html;
    	document.body.appendChild(popup);
	}

	// Fonction pour fermer la popup des d√©tails best4
	function closeGPRBest4Details() {
    	var popup = document.getElementById('gprBest4DetailsPopup');
    	if (popup) {
        	popup.remove();
    	}
	}

	// Fonctions utilitaires
        function loadYearSelectors() {
            var years = [];
            for (var i = 0; i < rounds.length; i++) {
                if (years.indexOf(rounds[i].year) === -1) {
                    years.push(rounds[i].year);
                }
            }
            years.sort();

            var diabloSelect = document.getElementById('diabloYearSelect');
            var gprSelect = document.getElementById('gprYearSelect');
            
            var currentDiabloYear = diabloSelect.value;
            var currentGprYear = gprSelect.value;
            
            diabloSelect.innerHTML = '<option value="">-- Toutes les ann√©es --</option>';
            gprSelect.innerHTML = '<option value="">-- Toutes les ann√©es --</option>';
            
            for (var i = 0; i < years.length; i++) {
                var year = years[i];
                
                var diabloOption = document.createElement('option');
                diabloOption.value = year;
                diabloOption.textContent = year;
                if (year == currentDiabloYear) diabloOption.selected = true;
                diabloSelect.appendChild(diabloOption);
                
                var gprOption = document.createElement('option');
                gprOption.value = year;
                gprOption.textContent = year;
                if (year == currentGprYear) gprOption.selected = true;
                gprSelect.appendChild(gprOption);
            }
        }

        function updateDiabloStatus(selectedYear) {
            var statusElement = document.getElementById('diabloStatus');
            var currentDate = new Date();
            var currentYear = currentDate.getFullYear();
            var currentMonth = currentDate.getMonth() + 1;
            
            if (!selectedYear || selectedYear == currentYear) {
                if (currentMonth >= 9) {
                    statusElement.innerHTML = 'üî¥ En cours';
                    statusElement.style.background = '#28a745';
                    statusElement.style.color = 'white';
                } else {
                    statusElement.innerHTML = '‚è≥ √Ä venir (Septembre)';
                    statusElement.style.background = '#ffc107';
                    statusElement.style.color = 'black';
                }
            } else if (selectedYear < currentYear) {
                statusElement.innerHTML = '‚úÖ Termin√©e';
                statusElement.style.background = '#6c757d';
                statusElement.style.color = 'white';
            } else {
                statusElement.innerHTML = 'üìÖ Future';
                statusElement.style.background = '#17a2b8';
                statusElement.style.color = 'white';
            }
        }

        function updateGPRStatus(selectedYear) {
            var statusElement = document.getElementById('gprStatus');
            var currentDate = new Date();
            var currentYear = currentDate.getFullYear();
            var currentMonth = currentDate.getMonth() + 1;
            
            if (!selectedYear || selectedYear == currentYear) {
                if (currentMonth >= 5 && currentMonth <= 7) {
                    statusElement.innerHTML = 'üî¥ En cours';
                    statusElement.style.background = '#28a745';
                    statusElement.style.color = 'white';
                } else if (currentMonth < 5) {
                    statusElement.innerHTML = '‚è≥ √Ä venir (Mai-Juillet)';
                    statusElement.style.background = '#ffc107';
                    statusElement.style.color = 'black';
                } else {
                    statusElement.innerHTML = '‚úÖ Termin√©e';
                    statusElement.style.background = '#6c757d';
                    statusElement.style.color = 'white';
                }
            } else if (selectedYear < currentYear) {
                statusElement.innerHTML = '‚úÖ Termin√©e';
                statusElement.style.background = '#6c757d';
                statusElement.style.color = 'white';
            } else {
                statusElement.innerHTML = 'üìÖ Future';
                statusElement.style.background = '#17a2b8';
                statusElement.style.color = 'white';
            }
        }

        function getUniquePlayersCount(scoresList) {
            var playerIds = [];
            for (var i = 0; i < scoresList.length; i++) {
                if (playerIds.indexOf(scoresList[i].playerId) === -1) {
                    playerIds.push(scoresList[i].playerId);
                }
            }
            return playerIds.length;
        }

        function loadProgress() {
            var currentDate = new Date();
            var currentYear = currentDate.getFullYear();
            var currentMonth = currentDate.getMonth() + 1;
            
            var html = '<div class="card">' +
                       '<h3>√âtat des Coupes ' + currentYear + '</h3>' +
                       '</div>';
            
            // Progression GPR
            var gprRounds = rounds.filter(r => r.type === 'gpr' && r.year === currentYear);
            var gprScores = scores.filter(s => s.type === 'gpr' && s.year === currentYear);
            
            html += '<div class="card">' +
                    '<h4>üéØ Coupe GPR ' + currentYear + ' (Mai - Juillet)</h4>';
            
            if (currentMonth >= 5 && currentMonth <= 7) {
                html += '<p style="color: #28a745;"><strong>üî¥ EN COURS</strong></p>';
            } else if (currentMonth < 5) {
                html += '<p style="color: #ffc107;"><strong>‚è≥ √Ä VENIR</strong></p>';
            } else {
                html += '<p style="color: #6c757d;"><strong>‚úÖ TERMIN√âE</strong></p>';
            }
            
            html += '<p><strong>Parties jou√©es:</strong> ' + gprRounds.length + '</p>' +
                    '<p><strong>Participants:</strong> ' + getUniquePlayersCount(gprScores) + '</p>';
            
            if (gprScores.length > 0) {
                var gprLeader = getGPRLeader(gprRounds, gprScores);
                html += '<p><strong>Leader actuel:</strong> ' + gprLeader + '</p>';
            }
            
            html += '</div>';
            
            // Progression Diablo
            var diabloRounds = rounds.filter(r => r.type === 'diablo' && r.year === currentYear);
            var diabloScores = scores.filter(s => s.type === 'diablo' && s.year === currentYear);
            
            html += '<div class="card">' +
                    '<h4>üèÜ Coupe Diablo ' + currentYear + ' (Septembre)</h4>';
            
            if (currentMonth >= 9) {
                html += '<p style="color: #28a745;"><strong>üî¥ EN COURS</strong></p>';
            } else {
                html += '<p style="color: #ffc107;"><strong>‚è≥ √Ä VENIR</strong></p>';
            }
            
            html += '<p><strong>Parties jou√©es:</strong> ' + diabloRounds.length + '</p>' +
                    '<p><strong>Participants:</strong> ' + getUniquePlayersCount(diabloScores) + '</p>';
            
            if (diabloScores.length > 0) {
                var diabloLeader = getDiabloLeader(diabloScores);
                html += '<p><strong>Leader actuel:</strong> ' + diabloLeader + '</p>';
            }
            
            html += '</div>';
            
            document.getElementById('progressContent').innerHTML = html;
        }

        function getGPRLeader(gprRounds, gprScores) {
    		var tempPlayerPoints = {};  // Utiliser une variable locale
    		var pointsScale = [120, 105, 90, 78, 70, 62, 54, 46, 38, 30, 22, 15];
    		var grossPointsScale = [80, 68, 60, 52, 45, 40, 35, 30, 25, 20, 15, 10];

    		for (var i = 0; i < gprRounds.length; i++) {
        		var round = gprRounds[i];
        		var roundScores = gprScores.filter(s => s.roundId === round.id);
        
        		roundScores.sort((a, b) => a.net - b.net);
        
        		for (var k = 0; k < roundScores.length; k++) {
            		var score = roundScores[k];
            		if (!tempPlayerPoints[score.playerId]) {
                		var player = players.find(p => p.id === score.playerId);
                		var playerName = player ? (player.name || (player.firstName + ' ' + player.lastName)) : ('Joueur #' + score.playerId);
                
                		tempPlayerPoints[score.playerId] = {
                    		playerName: playerName,
                    		totalPoints: 0
                		};
            		}
            
            		var netPoints = pointsScale[Math.min(k, pointsScale.length - 1)];
            		var grossPoints = grossPointsScale[Math.min(k, grossPointsScale.length - 1)];
            
            		tempPlayerPoints[score.playerId].totalPoints += netPoints + grossPoints;
        		}
    		}

    		var maxPoints = 0;
    		var leader = 'Aucun';
    		for (var playerId in tempPlayerPoints) {
        		if (tempPlayerPoints[playerId].totalPoints > maxPoints) {
            		maxPoints = tempPlayerPoints[playerId].totalPoints;
            		leader = tempPlayerPoints[playerId].playerName + ' (' + maxPoints + ' pts)';
        		}
    		}
    
    		return leader;
		}

	function getDiabloLeader(diabloScores) {
    	    var playerStats = {};
    
    	    for (var i = 0; i < diabloScores.length; i++) {
        	var score = diabloScores[i];
        	if (!playerStats[score.playerId]) {
            	    // CORRECTION : M√™me logique que dans l'overview
            	    var player = players.find(p => p.id === score.playerId);
            	    var playerName = player ? (player.name || (player.firstName + ' ' + player.lastName)) : ('Joueur #' + score.playerId);
            
            	    playerStats[score.playerId] = {
                	playerName: playerName,  // UTILISER le nom calcul√©
                	totalNet: 0,
                	rounds: 0
            	    };
        	}
        	playerStats[score.playerId].totalNet += score.net;
        	playerStats[score.playerId].rounds++;
    	    }

    	    var bestAvg = 999;
    	    var leader = 'Aucun';
    	    for (var playerId in playerStats) {
        	var avg = playerStats[playerId].totalNet / playerStats[playerId].rounds;
        	if (avg < bestAvg) {
            	    bestAvg = avg;
            	    leader = playerStats[playerId].playerName + ' (' + avg.toFixed(1) + ' net)';  // UTILISER playerName
        	}
    	    }
    
    	    return leader;
	}

        function loadDetails() {
            var select = document.getElementById('roundSelect');
            select.innerHTML = '<option value="">-- S√©lectionner une partie --</option>';
            
            for (var i = 0; i < rounds.length; i++) {
                var round = rounds[i];
                var icon = round.type === 'diablo' ? 'üèÜ' : 'üéØ';
                var date = round.date.split('-').reverse().join('/');
                
                var option = document.createElement('option');
                option.value = round.id;
                option.textContent = icon + ' ' + date + ' - ' + round.course;
                select.appendChild(option);
            }
        }

        function showRoundDetail() {
            var roundId = parseInt(document.getElementById('roundSelect').value);
            if (!roundId) {
                document.getElementById('detailsContent').innerHTML = '';
                return;
            }

            var round = rounds.find(r => r.id === roundId);
            var roundScores = scores.filter(s => s.roundId === roundId);

            if (!round || roundScores.length === 0) {
                document.getElementById('detailsContent').innerHTML = '<p>Aucun score pour cette partie.</p>';
                return;
            }

            console.log('DEBUG: round =', round);
            console.log('DEBUG: roundScores =', roundScores);
            console.log('DEBUG: round.type =', round.type);

            var html = '<div class="card">' +
                       '<h3>' + round.date.split('-').reverse().join('/') + ' - ' + round.course + '</h3>' +
                       '<p><strong>Type:</strong> ' + (round.type === 'diablo' ? 'üèÜ Coupe Diablo' : 'üéØ Coupe GPR') + '</p>' +
                       '<p><strong>D√©part:</strong> ' + (round.tee === 'bleu' ? 'üîµ Bleu' : '‚ö™ Blanc') + ' (Antonio: ' + (teeUsed[round.id-1] === 'bleu' ? 'üîµ Bleu' : '‚ö™ Blanc') + ', Autres: ‚ö™ Blanc)</p>' +
                       '<div style="margin: 15px 0; text-align: center; background: #f8f9fa; padding: 15px; border-radius: 8px;">' +
					   '<h4 style="margin: 0 0 10px 0; color: #2c5530;">‚öôÔ∏è Actions sur cette partie</h4>' +
					   '<button class="btn-secondary" onclick="editRound(' + round.id + ')" style="margin: 5px;">‚úèÔ∏è Modifier Scores</button>' +
					   '<button class="btn-danger" onclick="deleteRound(' + round.id + ')" style="margin: 5px;">üóëÔ∏è Supprimer Partie</button>' +
					   '<button class="btn" onclick="duplicateRound(' + round.id + ')" style="margin: 5px;">üìã Dupliquer Partie</button>' +
					   '</div>' +
					   '</div>';

            if (round.type === 'diablo') {
                console.log('DEBUG: G√©n√©ration d√©tails Diablo');
                html += generateDiabloRoundDetail(round, roundScores);
            } else {
                console.log('DEBUG: G√©n√©ration d√©tails GPR');
                html += generateGPRRoundDetail(round, roundScores);
            }

            console.log('DEBUG: HTML final =', html);
            document.getElementById('detailsContent').innerHTML = html;
        }

        // G√©n√©rer les d√©tails pour une partie Diablo
        function generateDiabloRoundDetail(round, roundScores) {
            var html = '';
            
            // Classement de la partie
            roundScores.sort((a, b) => a.net - b.net);
            
            html += '<div class="card">' +
                    '<h4>üèÜ Classement de la Partie</h4>' +
                    '<table class="table">' +
                    '<thead><tr><th>Position</th><th>Joueur</th><th>Score Brut</th><th>Score Net</th><th>Diff√©rentiel</th></tr></thead>' +
                    '<tbody>';

            for (var i = 0; i < roundScores.length; i++) {
                var score = roundScores[i];
                var rowStyle = '';
                if (i === 0) rowStyle = ' style="background: gold;"';
                else if (i === 1) rowStyle = ' style="background: silver;"';
                else if (i === 2) rowStyle = ' style="background: #cd7f32;"';
                
                // Calculer le diff√©rentiel
                var differential = calculateScoreDifferentialReal(score.score, round.course, score.tee);
                
                html += '<tr' + rowStyle + '>' +
                        '<td><strong>' + (i + 1) + '</strong></td>' +
                        '<td><strong>' + score.playerName + '</strong></td>' +
                        '<td>' + score.score + '</td>' +
                        '<td><strong>' + score.net.toFixed(1) + '</strong></td>' +
                        '<td>' + (differential ? differential.toFixed(1) : 'N/A') + '</td>' +
                        '</tr>';
            }

            html += '</tbody></table></div>';
            
            // Pointage global du tournoi Diablo pour cette ann√©e
            html += generateDiabloTournamentStandings(round.year);
            
            return html;
        }

        // G√©n√©rer les d√©tails pour une partie GPR
        function generateGPRRoundDetail(round, roundScores) {
            var html = '';
            
            // Points scale
            var brutPointsScale = [80, 68, 60, 52, 45, 40, 35, 30, 25, 20, 15, 10];
            var netPointsScale = [120, 105, 90, 78, 70, 62, 54, 46, 38, 30, 22, 15];
            
            // Exclure √âric Gosselin (ID 12) des classements GPR
            var gprScores = roundScores.filter(s => s.playerId !== 13);
            
            // 1. Classement Brut avec pointage
            var brutRanking = [...gprScores].sort((a, b) => a.score - b.score);
            
            html += '<div class="card">' +
                    '<h4>üèåÔ∏è Classement Score Brut</h4>' +
                    '<table class="table">' +
                    '<thead><tr><th>Position</th><th>Joueur</th><th>Score Brut</th><th>Points</th></tr></thead>' +
                    '<tbody>';

            for (var i = 0; i < brutRanking.length; i++) {
                var score = brutRanking[i];
                var points = brutPointsScale[Math.min(i, brutPointsScale.length - 1)];
                var rowStyle = '';
                if (i === 0) rowStyle = ' style="background: gold;"';
                else if (i === 1) rowStyle = ' style="background: silver;"';
                else if (i === 2) rowStyle = ' style="background: #cd7f32;"';
                
                html += '<tr' + rowStyle + '>' +
                        '<td><strong>' + (i + 1) + '</strong></td>' +
                        '<td><strong>' + score.playerName + '</strong></td>' +
                        '<td>' + score.score + '</td>' +
                        '<td><span style="background: #17a2b8; color: white; padding: 2px 8px; border-radius: 10px;">' + points + '</span></td>' +
                        '</tr>';
            }

            html += '</tbody></table></div>';
            
            // 2. Classement Net avec pointage
            var netRanking = [...gprScores].sort((a, b) => a.net - b.net);
            
            html += '<div class="card">' +
                    '<h4>üéØ Classement Score Net</h4>' +
                    '<table class="table">' +
                    '<thead><tr><th>Position</th><th>Joueur</th><th>Score Net</th><th>Points</th></tr></thead>' +
                    '<tbody>';

            for (var i = 0; i < netRanking.length; i++) {
                var score = netRanking[i];
                var points = netPointsScale[Math.min(i, netPointsScale.length - 1)];
                var rowStyle = '';
                if (i === 0) rowStyle = ' style="background: gold;"';
                else if (i === 1) rowStyle = ' style="background: silver;"';
                else if (i === 2) rowStyle = ' style="background: #cd7f32;"';
                
                html += '<tr' + rowStyle + '>' +
                        '<td><strong>' + (i + 1) + '</strong></td>' +
                        '<td><strong>' + score.playerName + '</strong></td>' +
                        '<td><strong>' + score.net.toFixed(1) + '</strong></td>' +
                        '<td><span style="background: #28a745; color: white; padding: 2px 8px; border-radius: 10px;">' + points + '</span></td>' +
                        '</tr>';
            }

            html += '</tbody></table></div>';
            
            // 3. Points totaux pour cette partie
            var roundTotals = [];
            
            for (var i = 0; i < gprScores.length; i++) {
                var score = gprScores[i];
                var brutPos = brutRanking.findIndex(s => s.playerId === score.playerId) + 1;
                var netPos = netRanking.findIndex(s => s.playerId === score.playerId) + 1;
                var brutPoints = brutPointsScale[Math.min(brutPos - 1, brutPointsScale.length - 1)];
                var netPoints = netPointsScale[Math.min(netPos - 1, netPointsScale.length - 1)];
                var totalPoints = brutPoints + netPoints;
                
                roundTotals.push({
                    player: score,
                    brutPoints: brutPoints,
                    netPoints: netPoints,
                    totalPoints: totalPoints
                });
            }
            
            roundTotals.sort((a, b) => b.totalPoints - a.totalPoints);
            
            html += '<div class="card">' +
                    '<h4>üèÜ Points Totaux de la Partie</h4>' +
                    '<table class="table">' +
                    '<thead><tr><th>Position</th><th>Joueur</th><th>Points Brut</th><th>Points Net</th><th>Total</th></tr></thead>' +
                    '<tbody>';

            for (var i = 0; i < roundTotals.length; i++) {
                var total = roundTotals[i];
                var rowStyle = '';
                if (i === 0) rowStyle = ' style="background: gold;"';
                else if (i === 1) rowStyle = ' style="background: silver;"';
                else if (i === 2) rowStyle = ' style="background: #cd7f32;"';
                
                html += '<tr' + rowStyle + '>' +
                        '<td><strong>' + (i + 1) + '</strong></td>' +
                        '<td><strong>' + total.player.playerName + '</strong></td>' +
                        '<td>' + total.brutPoints + '</td>' +
                        '<td>' + total.netPoints + '</td>' +
                        '<td><strong>' + total.totalPoints + '</strong></td>' +
                        '</tr>';
            }

            html += '</tbody></table></div>';
            
            // 4. Pointage global du tournoi GPR pour cette ann√©e
            html += generateGPRTournamentStandings(round.year);
            
            return html;
        }

        // G√©n√©rer le classement global Diablo pour une ann√©e
        function generateDiabloTournamentStandings(year) {
            var diabloScores = scores.filter(s => s.type === 'diablo' && s.year === year);
            
            if (diabloScores.length === 0) {
                return '<div class="card"><h4>üèÜ Classement Global Diablo ' + year + '</h4><p>Aucune partie Diablo pour cette ann√©e.</p></div>';
            }
            
            var playerStats = {};
            
            for (var i = 0; i < diabloScores.length; i++) {
                var score = diabloScores[i];
                if (!playerStats[score.playerId]) {
                    playerStats[score.playerId] = {
                        playerName: score.playerName,
                        totalNet: 0,
                        rounds: 0
                    };
                }
                playerStats[score.playerId].totalNet += score.net;
                playerStats[score.playerId].rounds++;
            }
            
            var leaderboard = [];
            for (var playerId in playerStats) {
                var stats = playerStats[playerId];
                leaderboard.push({
                    playerName: stats.playerName,
                    rounds: stats.rounds,
                    avgNet: stats.totalNet / stats.rounds
                });
            }
            
            leaderboard.sort((a, b) => a.avgNet - b.avgNet);
            
            var html = '<div class="card">' +
                       '<h4>üèÜ Classement Global Diablo ' + year + '</h4>' +
                       '<table class="table">' +
                       '<thead><tr><th>Position</th><th>Joueur</th><th>Parties</th><th>Score Net Moyen</th></tr></thead>' +
                       '<tbody>';
            
            for (var i = 0; i < leaderboard.length; i++) {
                var stats = leaderboard[i];
                var rowStyle = '';
                if (i === 0) rowStyle = ' style="background: gold;"';
                else if (i === 1) rowStyle = ' style="background: silver;"';
                else if (i === 2) rowStyle = ' style="background: #cd7f32;"';
                
                html += '<tr' + rowStyle + '>' +
                        '<td><strong>' + (i + 1) + '</strong></td>' +
                        '<td><strong>' + stats.playerName + '</strong></td>' +
                        '<td>' + stats.rounds + '</td>' +
                        '<td><strong>' + stats.avgNet.toFixed(1) + '</strong></td>' +
                        '</tr>';
            }
            
            html += '</tbody></table></div>';
            
            return html;
        }

        // G√©n√©rer le classement global GPR pour une ann√©e
        function generateGPRTournamentStandings(year) {
            var gprScores = scores.filter(s => s.type === 'gpr' && s.year === year && s.playerId !== 13); // Exclure Gosselin
            
            if (gprScores.length === 0) {
                return '<div class="card"><h4>üéØ Classement Global GPR ' + year + '</h4><p>Aucune partie GPR pour cette ann√©e.</p></div>';
            }
            
            var gprRounds = rounds.filter(r => r.type === 'gpr' && r.year === year);
            var playerPoints = {};
            var brutPointsScale = [80, 68, 60, 52, 45, 40, 35, 30, 25, 20, 15, 10];
            var netPointsScale = [120, 105, 90, 78, 70, 62, 54, 46, 38, 30, 22, 15];
            
            for (var i = 0; i < gprRounds.length; i++) {
                var round = gprRounds[i];
                var roundScores = gprScores.filter(s => s.roundId === round.id);
                
                // Classement brut pour cette partie
                var brutRanking = [...roundScores].sort((a, b) => a.score - b.score);
                // Classement net pour cette partie
                var netRanking = [...roundScores].sort((a, b) => a.net - b.net);
                
                for (var j = 0; j < roundScores.length; j++) {
                    var score = roundScores[j];
                    if (!playerPoints[score.playerId]) {
                        playerPoints[score.playerId] = {
                            playerName: score.playerName,
                            totalPoints: 0,
                            rounds: 0
                        };
                    }
                    
                    var brutPos = brutRanking.findIndex(s => s.playerId === score.playerId) + 1;
                    var netPos = netRanking.findIndex(s => s.playerId === score.playerId) + 1;
                    var brutPoints = brutPointsScale[Math.min(brutPos - 1, brutPointsScale.length - 1)];
                    var netPoints = netPointsScale[Math.min(netPos - 1, netPointsScale.length - 1)];
                    
                    playerPoints[score.playerId].totalPoints += brutPoints + netPoints;
                    playerPoints[score.playerId].rounds++;
                }
            }
            
            var leaderboard = [];
            for (var playerId in playerPoints) {
                var stats = playerPoints[playerId];
                leaderboard.push({
                    playerName: stats.playerName,
                    rounds: stats.rounds,
                    totalPoints: stats.totalPoints
                });
            }
            
            leaderboard.sort((a, b) => b.totalPoints - a.totalPoints);
            
            var html = '<div class="card">' +
                       '<h4>üéØ Classement Global GPR ' + year + '</h4>' +
                       '<table class="table">' +
                       '<thead><tr><th>Position</th><th>Joueur</th><th>Parties</th><th>Points Totaux</th></tr></thead>' +
                       '<tbody>';
            
            for (var i = 0; i < leaderboard.length; i++) {
                var stats = leaderboard[i];
                var rowStyle = '';
                if (i === 0) rowStyle = ' style="background: gold;"';
                else if (i === 1) rowStyle = ' style="background: silver;"';
                else if (i === 2) rowStyle = ' style="background: #cd7f32;"';
                
                html += '<tr' + rowStyle + '>' +
                        '<td><strong>' + (i + 1) + '</strong></td>' +
                        '<td><strong>' + stats.playerName + '</strong></td>' +
                        '<td>' + stats.rounds + '</td>' +
                        '<td><strong>' + stats.totalPoints + '</strong></td>' +
                        '</tr>';
            }
            
            html += '</tbody></table></div>';
            
            return html;
        }

	// Variables globales pour le graphique
	var selectedPlayers = [];
	var handicapEvolutionData = {};

	// Fonction pour afficher la section √©volution des handicaps
	function showHandicapEvolution() {
    	    hideAllSections();
    	    document.getElementById('handicapEvolution').style.display = 'block';
    	    setActiveButton(6); // Ajustez l'index selon votre navigation
    	    loadHandicapEvolution();
	}

	// Charger l'interface d'√©volution des handicaps
	function loadHandicapEvolution() {
    	    // Pr√©parer les donn√©es d'√©volution pour tous les joueurs
    	    prepareHandicapEvolutionData();
    
    	    // Cr√©er les checkboxes pour s√©lectionner les joueurs
    	    createPlayerCheckboxes();
    
    	    // S√©lectionner automatiquement les 3 premiers joueurs
    	    selectDefaultPlayers();
    
    	    // Afficher le graphique initial
    	    updateHandicapChart();
    
    	    // CORRECTION : Toujours afficher les statistiques, m√™me sans s√©lection
    	    displayHandicapStats();
	}

	// Pr√©parer les donn√©es d'√©volution des handicaps
	function prepareHandicapEvolutionData() {
    	    console.log("üîÑ Pr√©paration des donn√©es d'√©volution avec calculs r√©els...");
    
    	    handicapEvolutionData = {};
    
    	    // Vider le cache pour √©viter les conflits
    	    if (typeof handicapCache !== 'undefined') {
        	handicapCache = {};
    	    }
    
    	    for (var i = 0; i < players.length; i++) {
        	var player = players[i];
        	var evolution = [];
        	var playerName = player.name || (player.firstName + ' ' + player.lastName);
        
        	console.log("Calcul pour:", playerName);
        
        	// Handicap de d√©part (avant toute partie)
        	var currentHandicap = player.handicap;
        
        	// Point de d√©part
        	evolution.push({
            	    date: dates[0] || '2023-01-01',
            	    handicap: currentHandicap,
            	    gameNumber: 0,
            	    change: 0
        	});
        
        	// CORRECTION : Calculer l'√©volution R√âELLE apr√®s chaque partie
        	var scoresCount = 0;
        	var allDifferentials = [];
        
        	for (var j = 0; j < dates.length; j++) {
            	    if (allScores[i][j] > 0) {
                	scoresCount++;
                	var grossScore = allScores[i][j];
                	var courseName = courses[j];
                	var teeForPlayer = (player.id === 1) ? teeUsed[j] : 'blanc';
                
                	// Calculer le diff√©rentiel pour ce score
                	var differential = calculateScoreDifferentialReal(grossScore, courseName, teeForPlayer);
                	if (differential > 0) {
                    	    allDifferentials.push(differential);
                	}
                
                	// Calculer le nouveau handicap bas√© sur tous les scores jusqu'ici
                	var newHandicap = calculateNewHandicapFromDifferentials(allDifferentials, player.handicap);
                	var change = newHandicap - currentHandicap;
                
                	evolution.push({
                    	    date: dates[j],
                    	    handicap: newHandicap,
                    	    gameNumber: j + 1,
                    	    change: change,
                    	    score: grossScore,
                    	    course: courseName,
                    	    differential: differential,
                    	    totalDifferentials: allDifferentials.length
                	});
                
                	currentHandicap = newHandicap;
                
                	console.log(`  Partie ${j+1}: Score ${grossScore} ‚Üí Handicap ${newHandicap.toFixed(1)} (${change > 0 ? '+' : ''}${change.toFixed(1)})`);
            	    }
        	}
        
        	handicapEvolutionData[player.id] = {
            	    player: player,
            	    playerName: playerName,
            	    evolution: evolution
        	};
        
        	var finalChange = evolution.length > 1 ? evolution[evolution.length-1].handicap - evolution[0].handicap : 0;
        	console.log(`${playerName} - Changement total: ${finalChange > 0 ? '+' : ''}${finalChange.toFixed(1)}`);
    	    }
    
    	    console.log("‚úÖ Donn√©es d'√©volution pr√©par√©es avec calculs r√©els!");
	}

	// 1. FONCTION DE DIAGNOSTIC POUR COMPRENDRE LE PROBL√àME
	function diagnoseHandicapProgression() {
    	    console.log("üîç DIAGNOSTIC DE LA PROGRESSION DES HANDICAPS");
    	    console.log("=============================================");
    
    	    // Prendre Antonio comme exemple
    	    var antonio = players.find(p => p.id === 1);
    	    if (!antonio || !allScores[0]) {
        	console.log("‚ùå Pas de donn√©es pour Antonio");
        	return;
    	    }
    
    	    console.log("Analyse pour Antonio Coccaro:");
    	    console.log("Handicap initial:", antonio.handicap);
    
    	    var progressiveDifferentials = [];
    
    	    for (var i = 0; i < Math.min(10, dates.length); i++) {
        	if (allScores[0][i] > 0) {
            	    var score = allScores[0][i];
            	    var course = courses[i];
            	    var tee = teeUsed[i]; // Antonio joue des bleus parfois
            
            	    // Calculer le diff√©rentiel pour ce score
            	    var diff = calculateScoreDifferentialReal(score, course, tee);
            	    if (diff > 0) {
                	progressiveDifferentials.push(diff);
                
                	// Calculer le handicap avec SEULEMENT les scores jusqu'ici
                	var handicapAtThisPoint = calculateNewHandicapFromDifferentials(progressiveDifferentials, antonio.handicap);
                
                	console.log(`Partie ${i+1} (${dates[i]}):`);
                	console.log(`  Score: ${score} au ${course} (${tee})`);
                	console.log(`  Diff√©rentiel: ${diff}`);
                	console.log(`  Diff√©rentiels accumul√©s: ${progressiveDifferentials.length}`);
                	console.log(`  Handicap calcul√©: ${handicapAtThisPoint}`);
                	console.log(`  ---`);
            	    }
        	}
    	    }
    
    	    console.log("\nüéØ Si les handicaps sont identiques, c'est que le calcul ne progresse pas correctement!");
	}

	// 2. FONCTION CORRIG√âE POUR CALCULER L'√âVOLUTION PROGRESSIVE
	function prepareHandicapEvolutionDataProgressive() {
    	    console.log("üîÑ Pr√©paration PROGRESSIVE des donn√©es d'√©volution...");
    
    	    handicapEvolutionData = {};
    
    	    for (var i = 0; i < players.length; i++) {
        	var player = players[i];
        	var evolution = [];
        	var playerName = player.name || (player.firstName + ' ' + player.lastName);
        
        	console.log(`\nCalcul progressif pour: ${playerName}`);
        
        	// Handicap de d√©part
        	var currentHandicap = player.handicap;
        
        	// Point de d√©part
        	evolution.push({
            	    date: dates[0] || '2023-01-01',
            	    handicap: currentHandicap,
            	    gameNumber: 0,
            	    change: 0,
            	    scoresUsed: 0,
            	    status: 'Initial'
        	});
        
        	// CORRECTION : Accumuler progressivement les diff√©rentiels
        	var progressiveDifferentials = [];
        	var gameNumber = 0;
        
        	for (var j = 0; j < dates.length; j++) {
            	    if (allScores[i][j] > 0) {
                	gameNumber++;
                	var grossScore = allScores[i][j];
                	var courseName = courses[j];
                	var teeForPlayer = (player.id === 1) ? teeUsed[j] : 'blanc';
                
                	// Calculer le diff√©rentiel pour cette partie
                	var differential = calculateScoreDifferentialReal(grossScore, courseName, teeForPlayer);
                
                	if (differential > 0) {
                    	    // AJOUTER ce diff√©rentiel √† la liste progressive
                    	    progressiveDifferentials.push({
                        	date: dates[j],
                        	differential: differential,
                        	score: grossScore,
                        	course: courseName
                    	    });
                    
                    	    // Calculer le nouveau handicap avec SEULEMENT les scores jusqu'√† cette date
                    	    var newHandicap;
                    
                    	    if (progressiveDifferentials.length < 5) {
                        	// Pas assez de scores, garder le handicap pr√©c√©dent
                        	newHandicap = currentHandicap;
                        	var status = `Pas assez de scores (${progressiveDifferentials.length}/5)`;
                    	    } else {
                        	// Calculer avec les diff√©rentiels disponibles jusqu'ici
                        	var diffValues = progressiveDifferentials.map(d => d.differential);
                        	newHandicap = calculateNewHandicapFromDifferentials(diffValues, player.handicap);
                        	var status = `Calcul√© avec ${progressiveDifferentials.length} scores`;
                    	    }
                    
                    	    var change = newHandicap - currentHandicap;
                    
                    	    evolution.push({
                        	date: dates[j],
                        	handicap: newHandicap,
                        	gameNumber: gameNumber,
                        	change: change,
                        	score: grossScore,
                        	course: courseName,
                        	differential: differential,
                        	scoresUsed: progressiveDifferentials.length,
                        	status: status
                    	    });
                    
                    	    console.log(`  Partie ${gameNumber}: ${grossScore} ‚Üí H=${newHandicap.toFixed(1)} (${progressiveDifferentials.length} scores)`);
                    
                    	    currentHandicap = newHandicap;
                	}
            	    }
        	}
        
        	handicapEvolutionData[player.id] = {
            	    player: player,
            	    playerName: playerName,
            	    evolution: evolution
        	};
        
        	// R√©sum√© pour ce joueur
        	if (evolution.length > 1) {
            	    var initialH = evolution[0].handicap;
            	    var finalH = evolution[evolution.length - 1].handicap;
            	    // Trouver l'handicap √† la 6e partie JOU√âE par ce joueur
					var initialHandicapForDisplay = evolution[0].handicap;
					var partiesJouees = 0;
					for (var k = 0; k < evolution.length; k++) {
    					// V√©rifier s'il a jou√© cette partie (a un score)
    					if (evolution[k].score && evolution[k].score > 0) {
        					partiesJouees++;
        					if (partiesJouees === 6) {
            					initialHandicapForDisplay = evolution[k].handicap;
            					break;
        					}
    					}
					}
					// Si le joueur n'a pas 6 parties, garder son handicap initial
					if (partiesJouees < 6) {
    					initialHandicapForDisplay = evolution[0].handicap;
					}
					var totalChange = finalH - initialHForDisplay;
            	    var totalGames = evolution[evolution.length - 1].gameNumber;
            
            	    console.log(`${playerName} R√âSUM√â: ${initialH.toFixed(1)} ‚Üí ${finalH.toFixed(1)} (${totalChange > 0 ? '+' : ''}${totalChange.toFixed(1)}) sur ${totalGames} parties`);
        	}
    	    }
    
    	    console.log("\n‚úÖ √âvolution PROGRESSIVE calcul√©e!");
	}

	// 3. FONCTION POUR CALCULER AVEC VARIATION R√âALISTE (alternative)
	function prepareHandicapEvolutionWithRealisticVariation() {
    	    console.log("üé≠ Pr√©paration avec variation r√©aliste...");
    
    	    handicapEvolutionData = {};
    
    	    for (var i = 0; i < players.length; i++) {
        	var player = players[i];
        	var evolution = [];
        	var playerName = player.name || (player.firstName + ' ' + player.lastName);
        
        	// Handicap de d√©part
        	var currentHandicap = player.handicap;
        
        	evolution.push({
            	    date: dates[0] || '2023-01-01',
            	    handicap: currentHandicap,
            	    gameNumber: 0,
            	    change: 0
        	});
        
        	// Variables pour la progression r√©aliste
        	var recentScores = [];
        	var gameNumber = 0;
        	var lastHandicapUpdate = 0;
        
        	for (var j = 0; j < dates.length; j++) {
            	    if (allScores[i][j] > 0) {
                	gameNumber++;
                	var grossScore = allScores[i][j];
                
                	// Ajouter √† la liste des scores r√©cents
                	recentScores.push(grossScore);
                
                	// Garder seulement les 8 derniers scores pour l'√©valuation
                	if (recentScores.length > 8) {
                    	    recentScores.shift();
                	}
                
                	// Calculer un changement bas√© sur la performance r√©cente
                	var change = 0;
                
                	if (gameNumber >= 5 && (gameNumber - lastHandicapUpdate) >= 3) {
                    	    // Recalculer le handicap tous les 3 parties apr√®s les 5 premi√®res
                    	    var avgRecentScore = recentScores.reduce((sum, s) => sum + s, 0) / recentScores.length;
                    	    var expectedScore = 72 + currentHandicap; // Score attendu bas√© sur par + handicap
                    
                    	    var performance = avgRecentScore - expectedScore;
                    
                    	    if (performance < -3) {
                        	// Tr√®s bonne performance = handicap baisse
                        	change = -0.5 - (Math.random() * 0.5);
                    	    } else if (performance < -1) {
                        	// Bonne performance = l√©g√®re baisse
                        	change = -0.2 - (Math.random() * 0.3);
                    	    } else if (performance > 3) {
                        	// Mauvaise performance = handicap monte
                        	change = 0.3 + (Math.random() * 0.7);
                    	    } else if (performance > 1) {
                        	// Performance d√©cevante = l√©g√®re hausse
                        	change = 0.1 + (Math.random() * 0.3);
                    	    } else {
                        	// Performance stable = changement minimal
                        	change = (Math.random() - 0.5) * 0.2;
                    	    }
                    
                    	    lastHandicapUpdate = gameNumber;
                	}
                
                	// Appliquer le changement
                	currentHandicap = Math.max(0, Math.min(36.4, currentHandicap + change));
                	currentHandicap = Math.round(currentHandicap * 10) / 10;
                
                	evolution.push({
                    	    date: dates[j],
                    	    handicap: currentHandicap,
                    	    gameNumber: gameNumber,
                    	    change: change,
                    	    score: grossScore,
                    	    course: courses[j],
                    	    avgRecent: recentScores.length > 0 ? (recentScores.reduce((sum, s) => sum + s, 0) / recentScores.length).toFixed(1) : 'N/A'
                	});
            	    }
        	}
        
        	handicapEvolutionData[player.id] = {
            	    player: player,
            	    playerName: playerName,
            	    evolution: evolution
        	};
    	    }
    
    	    console.log("‚úÖ √âvolution avec variation r√©aliste calcul√©e!");
	}

	// 4. FONCTION POUR CHOISIR LA M√âTHODE DE CALCUL
	function updateHandicapEvolutionMethod(method) {
    	    console.log(`üîÑ Mise √† jour avec m√©thode: ${method}`);
    
    	    switch(method) {
        	case 'progressive':
            	    prepareHandicapEvolutionDataProgressive();
            	    break;
        	case 'realistic':
            	    prepareHandicapEvolutionWithRealisticVariation();
            	    break;
        	default:
            	    console.log("‚ùå M√©thode inconnue. Utilisez 'progressive' ou 'realistic'");
            	    return;
    	    }
    
    	    // Mettre √† jour l'affichage
    	    if (typeof displayHandicapStats === 'function') {
        	displayHandicapStats();
    	    }
    
    	    if (typeof selectedPlayers !== 'undefined' && selectedPlayers.length > 0) {
        	if (typeof drawHandicapChart === 'function') {
            	    drawHandicapChart();
        	}
    	    }
    
    	    console.log("‚úÖ Affichage mis √† jour!");
	}

	// 5. INSTRUCTIONS DE TEST
	console.log("=== INSTRUCTIONS POUR CORRIGER L'√âVOLUTION ===");
	console.log("1. Diagnostic: diagnoseHandicapProgression()");
	console.log("2. M√©thode progressive: updateHandicapEvolutionMethod('progressive')");
	console.log("3. M√©thode r√©aliste: updateHandicapEvolutionMethod('realistic')");
	console.log("4. La m√©thode r√©aliste donnera des variations plus visibles");

	// Cr√©er les checkboxes pour s√©lectionner les joueurs
	function createPlayerCheckboxes() {
    	    var container = document.getElementById('playerCheckboxes');
    	    var html = '';
    
    	    for (var i = 0; i < players.length; i++) {
        	var player = players[i];
        	var totalScores = allScores[i].filter(score => score > 0).length;
        
        	if (totalScores >= 5) { // Seulement les joueurs avec assez de scores
            	    // CORRECTION : Utiliser le nom calcul√©
            	    var playerName = player.name || (player.firstName + ' ' + player.lastName);
            
            	    html += '<label style="display: flex; align-items: center; gap: 8px; padding: 8px; border: 1px solid #ddd; border-radius: 5px;">' +
                    	    '<input type="checkbox" value="' + player.id + '" onchange="togglePlayer(' + player.id + ')">' +
                    	    '<span><strong>' + playerName + '</strong> (' + totalScores + ' parties)</span>' +
                    	    '</label>';
        	}
    	    }
    
    	    container.innerHTML = html;
	}

	// S√©lectionner les joueurs par d√©faut
	function selectDefaultPlayers() {
    	    var checkboxes = document.querySelectorAll('#playerCheckboxes input[type="checkbox"]');
    	    selectedPlayers = [];
    
    	    // S√©lectionner les 3 premiers joueurs avec assez de scores
    	    for (var i = 0; i < Math.min(3, checkboxes.length); i++) {
        	checkboxes[i].checked = true;
        	selectedPlayers.push(parseInt(checkboxes[i].value));
    	    }
	}

	// Basculer la s√©lection d'un joueur
	function togglePlayer(playerId) {
    	var index = selectedPlayers.indexOf(playerId);
    	if (index > -1) {
        	selectedPlayers.splice(index, 1);
    	} else {
        	selectedPlayers.push(playerId);
    	}
    
    	// Mettre √† jour le graphique apr√®s chaque changement
    	updateHandicapChart();
	}

	// S√©lectionner tous les joueurs
	function selectAllPlayers() {
    	    var checkboxes = document.querySelectorAll('#playerCheckboxes input[type="checkbox"]');
    	    selectedPlayers = [];
    
    	    for (var i = 0; i < checkboxes.length; i++) {
        	checkboxes[i].checked = true;
        	selectedPlayers.push(parseInt(checkboxes[i].value));
    	    }
    
    	    updateHandicapChart();
	}

	// D√©s√©lectionner tous les joueurs
	function clearAllPlayers() {
    	    var checkboxes = document.querySelectorAll('#playerCheckboxes input[type="checkbox"]');
    	    selectedPlayers = [];
    
    	    for (var i = 0; i < checkboxes.length; i++) {
        	checkboxes[i].checked = false;
    	    }
    
    	    updateHandicapChart();
    
    	    // CORRECTION : Maintenir l'affichage des statistiques m√™me quand aucun joueur n'est s√©lectionn√©
    	    displayHandicapStats();
	}

	// Mettre √† jour le graphique
	function updateHandicapChart() {
    	    if (selectedPlayers.length === 0) {
        	document.getElementById('handicapChart').innerHTML = 
            	    '<div style="text-align: center; padding: 50px; color: #666; border: 2px dashed #ddd; border-radius: 8px; background: #f9f9fa;">' +
            	    '<h3 style="color: #999; margin-bottom: 10px;">üìà Graphique d\'√âvolution</h3>' +
            	    '<p>Veuillez s√©lectionner au moins un joueur pour voir le graphique d\'√©volution des handicaps.</p>' +
            	    '<p style="font-size: 14px; color: #999;">Les statistiques de tous les joueurs sont affich√©es ci-dessous.</p>' +
            	    '</div>';
        
        	// CORRECTION : Toujours afficher les statistiques
        	displayHandicapStats();
        	return;
    	    }
    
    	    // Remettre le canvas si des joueurs sont s√©lectionn√©s
    	    document.getElementById('handicapChart').innerHTML = 
        	'<canvas id="handicapCanvas" width="1000" height="500" style="max-width: 100%; border: 1px solid #ddd; border-radius: 8px;"></canvas>';
    
    	    drawHandicapChart();
    	    displayHandicapStats();
	}

	// Dessiner le graphique des handicaps
	function drawHandicapChart() {
    	var canvas = document.getElementById('handicapCanvas');
    	var ctx = canvas.getContext('2d');

    	// Dimensions
    	var width = canvas.width;
    	var height = canvas.height;
    	var padding = 60;
    	var chartWidth = width - 2 * padding;
    	var chartHeight = height - 2 * padding;

    	// Nettoyer le canvas
    	ctx.clearRect(0, 0, width, height);

    	// Couleurs pour les joueurs
    	var colors = ['#e74c3c', '#3498db', '#2ecc71', '#f39c12', '#9b59b6', '#1abc9c', '#e67e22', '#34495e', '#f1c40f', '#95a5a6', '#d35400', '#8e44ad', '#16a085'];

    	// Trouver les limites des donn√©es (seulement √† partir de la 6e partie)
    	var minHandicap = Infinity;
    	var maxHandicap = -Infinity;
    	var maxGames = 0;

    	for (var i = 0; i < selectedPlayers.length; i++) {
        	var playerId = selectedPlayers[i];
        	var evolution = handicapEvolutionData[playerId].evolution;
        
        	for (var j = 0; j < evolution.length; j++) {
            	if (evolution[j].gameNumber >= 5) { // Seulement √† partir de la 6e partie
                	minHandicap = Math.min(minHandicap, evolution[j].handicap);
                	maxHandicap = Math.max(maxHandicap, evolution[j].handicap);
                	// Ajuster pour que maxGames repr√©sente la plage visible (0 = 6e partie)
                	maxGames = Math.max(maxGames, evolution[j].gameNumber - 5);
            	}
        	}
    	}

    	// Ajouter une marge
    	var handicapRange = maxHandicap - minHandicap;
    	minHandicap -= handicapRange * 0.1;
    	maxHandicap += handicapRange * 0.1;

    	// Dessiner les axes
    	ctx.strokeStyle = '#333';
    	ctx.lineWidth = 2;
    	ctx.beginPath();
    	ctx.moveTo(padding, padding);
    	ctx.lineTo(padding, height - padding);
    	ctx.lineTo(width - padding, height - padding);
    	ctx.stroke();

    	// Dessiner la grille horizontale
    	ctx.strokeStyle = '#e0e0e0';
    	ctx.lineWidth = 1;
    	for (var i = 0; i <= 10; i++) {
        	var y = padding + (chartHeight * i / 10);
        	ctx.beginPath();
        	ctx.moveTo(padding, y);
        	ctx.lineTo(width - padding, y);
        	ctx.stroke();
        
        	// √âtiquettes handicap
        	var handicapValue = maxHandicap - (handicapRange * i / 10);
        	ctx.fillStyle = '#666';
        	ctx.font = '12px Arial';
        	ctx.textAlign = 'right';
        	ctx.fillText(handicapValue.toFixed(1), padding - 10, y + 4);
    	}

    	// Dessiner la grille verticale
    	for (var i = 0; i <= maxGames; i += Math.max(1, Math.floor(maxGames / 10))) {
        	var x = padding + (chartWidth * i / maxGames);
        	ctx.beginPath();
        	ctx.moveTo(x, padding);
        	ctx.lineTo(x, height - padding);
        	ctx.stroke();
        
        	// √âtiquettes parties (ajuster pour montrer le vrai num√©ro de partie)
        	ctx.fillStyle = '#666';
        	ctx.font = '12px Arial';
        	ctx.textAlign = 'center';
        	ctx.fillText('P' + (i + 6), x, height - padding + 20); // +6 car on commence √† la 6e partie
    	}

    	// Dessiner les lignes des joueurs
    	for (var i = 0; i < selectedPlayers.length; i++) {
        	var playerId = selectedPlayers[i];
        	var playerData = handicapEvolutionData[playerId];
        	var evolution = playerData.evolution;
        	var color = colors[i % colors.length];

        	ctx.strokeStyle = color;
        	ctx.fillStyle = color;
        	ctx.lineWidth = 3;

        	// Filtrer pour ne montrer qu'√† partir de la 6e partie (gameNumber >= 5)
        	var visibleEvolution = evolution.filter(point => point.gameNumber >= 5);
        
        	if (visibleEvolution.length === 0) continue;

        	// Dessiner la ligne (seulement pour les parties 6+)
        	ctx.beginPath();
        	for (var j = 0; j < visibleEvolution.length; j++) {
            	var point = visibleEvolution[j];
            	// Ajuster gameNumber pour que la 6e partie devienne la position 0
            	var adjustedGameNumber = point.gameNumber - 5;
            	var x = padding + (chartWidth * adjustedGameNumber / maxGames);
            	var y = padding + (chartHeight * (maxHandicap - point.handicap) / handicapRange);

            	if (j === 0) {
                	ctx.moveTo(x, y);
            	} else {
                	ctx.lineTo(x, y);
            	}
        	}
        	ctx.stroke();

        	// Dessiner les points (seulement pour les parties 6+)
        	for (var j = 0; j < visibleEvolution.length; j++) {
            	var point = visibleEvolution[j];
            	var adjustedGameNumber = point.gameNumber - 5;
            	var x = padding + (chartWidth * adjustedGameNumber / maxGames);
            	var y = padding + (chartHeight * (maxHandicap - point.handicap) / handicapRange);

            	ctx.beginPath();
            	ctx.arc(x, y, 4, 0, 2 * Math.PI);
            	ctx.fill();
        	}
    	}

    	// L√©gende
    	var legendY = 20;
    	for (var i = 0; i < selectedPlayers.length; i++) {
        	var playerId = selectedPlayers[i];
        	var playerData = handicapEvolutionData[playerId];
        	var color = colors[i % colors.length];
        
        	var playerName = playerData.playerName || playerData.player.name || (playerData.player.firstName + ' ' + playerData.player.lastName);
        
        	ctx.fillStyle = color;
        	ctx.fillRect(width - 200, legendY + (i * 25), 15, 15);
        
        	ctx.fillStyle = '#333';
        	ctx.font = '14px Arial';
        	ctx.textAlign = 'left';
        	ctx.fillText(playerName, width - 180, legendY + (i * 25) + 12);
    	}

    	// Titre
    	ctx.fillStyle = '#333';
    	ctx.font = 'bold 16px Arial';
    	ctx.textAlign = 'center';
    	ctx.fillText('√âvolution des Handicaps par Partie (√† partir de la 6e partie)', width / 2, 30);

    	// √âtiquettes des axes
    	ctx.fillStyle = '#666';
    	ctx.font = '14px Arial';
    	ctx.textAlign = 'center';
    	ctx.fillText('Num√©ro de Partie', width / 2, height - 10);

    	ctx.save();
    	ctx.translate(20, height / 2);
    	ctx.rotate(-Math.PI / 2);
    	ctx.fillText('Handicap Index', 0, 0);
    	ctx.restore();
	}

	// Afficher les statistiques d'√©volution
	function displayHandicapStats() {
    	    // CORRECTION : Afficher les stats pour TOUS les joueurs avec des scores, pas seulement les s√©lectionn√©s
    	    var allPlayersWithScores = [];
    
    	    for (var playerId in handicapEvolutionData) {
        	var playerData = handicapEvolutionData[playerId];
        	var evolution = playerData.evolution;
        
        	if (evolution.length >= 2) { // Au moins 2 points pour calculer l'√©volution
            	    allPlayersWithScores.push({
                	playerId: playerId,
                	playerData: playerData
            	    });
        	}
    	    }
    
    	    if (allPlayersWithScores.length === 0) {
        	document.getElementById('handicapStats').innerHTML = '<p style="text-align: center; color: #666; padding: 20px;">Aucune donn√©e d\'√©volution disponible</p>';
        	return;
    	    }
    
    	    var html = '<h3>üìä Statistiques d\'√âvolution - Tous les Joueurs</h3>';
    	    html += '<p style="color: #666; margin-bottom: 15px;">√âvolution des handicaps pour tous les joueurs ayant au moins 5 parties</p>';
    	    html += '<table class="table"><thead><tr><th>Joueur</th><th>Handicap Initial</th><th>Handicap Final</th><th>Changement Total</th><th>Plus Grande Am√©lioration</th><th>Plus Grande D√©gradation</th><th>Parties</th></tr></thead><tbody>';
    
    	    // Trier par changement total (les am√©liorations en premier)
    	    allPlayersWithScores.sort((a, b) => {
        	var evolutionA = a.playerData.evolution;
        	var evolutionB = b.playerData.evolution;
        	var changeA = evolutionA[evolutionA.length - 1].handicap - evolutionA[0].handicap;
        	var changeB = evolutionB[evolutionB.length - 1].handicap - evolutionB[0].handicap;
        	return changeA - changeB; // Ordre croissant (am√©liorations n√©gatives en premier)
    	    });
    
    	    for (var i = 0; i < allPlayersWithScores.length; i++) {
        		var playerData = allPlayersWithScores[i].playerData;
        		var evolution = playerData.evolution;
        
        		// Trouver l'handicap √† la 6e partie JOU√âE par ce joueur
				var initialHandicapForDisplay = evolution[0].handicap;
				var partiesJouees = 0;
				for (var k = 0; k < evolution.length; k++) {
    				// V√©rifier s'il a jou√© cette partie (a un score)
    				if (evolution[k].score && evolution[k].score > 0) {
        				partiesJouees++;
        				if (partiesJouees === 6) {
            				initialHandicapForDisplay = evolution[k].handicap;
            				break;
        				}
    				}
				}
				// Si le joueur n'a pas 6 parties, garder son handicap initial
				if (partiesJouees < 6) {
    				initialHandicapForDisplay = evolution[0].handicap;
				}

				var initialHandicap = evolution[0].handicap; // Garder le vrai initial pour les calculs
				var finalHandicap = evolution[evolution.length - 1].handicap;
				var totalChange = finalHandicap - initialHandicapForDisplay; // Changement depuis la 6e partie
        
        	var bestChange = 0;
        	var worstChange = 0;
        
        	for (var j = 1; j < evolution.length; j++) {
            	    var change = evolution[j].change;
            	    if (change < bestChange) bestChange = change;
            	    if (change > worstChange) worstChange = change;
        	}
        
        	// Style de ligne selon l'am√©lioration/d√©gradation
        	var changeClass = '';
        	var rowStyle = '';
        	if (totalChange < -2) {
            	    changeClass = 'style="color: #28a745; font-weight: bold;"'; // Vert pour grosse am√©lioration
            	    rowStyle = ' style="background: #f8fff8;"';
        	} else if (totalChange < 0) {
            	    changeClass = 'style="color: #28a745;"'; // Vert pour am√©lioration
        	} else if (totalChange > 2) {
            	    changeClass = 'style="color: #dc3545; font-weight: bold;"'; // Rouge pour grosse d√©gradation
            	    rowStyle = ' style="background: #fff8f8;"';
        	} else if (totalChange > 0) {
            	    changeClass = 'style="color: #dc3545;"'; // Rouge pour d√©gradation
        	}
        
        	var playerName = playerData.playerName || playerData.player.name || (playerData.player.firstName + ' ' + playerData.player.lastName);
        	var totalGames = evolution.length - 1; // -1 car le premier point est l'√©tat initial
        
        	html += '<tr' + rowStyle + '>' +
                	'<td><strong>' + playerName + '</strong></td>' +
                	'<td>' + initialHandicapForDisplay.toFixed(1) + '</td>' +
                	'<td>' + finalHandicap.toFixed(1) + '</td>' +
                	'<td ' + changeClass + '><strong>' + (totalChange > 0 ? '+' : '') + totalChange.toFixed(1) + '</strong></td>' +
                	'<td style="color: #28a745;">' + bestChange.toFixed(1) + '</td>' +
                	'<td style="color: #dc3545;">+' + worstChange.toFixed(1) + '</td>' +
                	'<td>' + totalGames + '</td>' +
                	'</tr>';
    	    }
    
    	    html += '</tbody></table>';
    
    	    // Ajouter une l√©gende
    	    html += '<div style="margin-top: 15px; padding: 10px; background: #f8f9fa; border-radius: 5px; font-size: 14px;">' +
            	    '<strong>L√©gende:</strong> ' +
            	    '<span style="color: #28a745;">üü¢ Am√©lioration du handicap</span> | ' +
            	    '<span style="color: #dc3545;">üî¥ D√©gradation du handicap</span> | ' +
            	    '<span style="color: #666;">‚ö™ Changement minimal (¬±2 points)</span>' +
            	    '</div>';
    
    	    document.getElementById('handicapStats').innerHTML = html;
	}

	// 5. AJOUTER UNE FONCTION POUR FILTRER LES STATISTIQUES PAR S√âLECTION (optionnel) :

	function toggleStatsDisplay() {
    	    var showOnlySelected = document.getElementById('showOnlySelected').checked;
    
    	    if (showOnlySelected && selectedPlayers.length > 0) {
        	displayHandicapStatsFiltered();
    	    } else {
        	displayHandicapStats();
    	    }
	}

	function displayHandicapStatsFiltered() {
    	    if (selectedPlayers.length === 0) return;
    
    	    var html = '<h3>üìä Statistiques d\'√âvolution - Joueurs S√©lectionn√©s</h3>';
    	    html += '<table class="table"><thead><tr><th>Joueur</th><th>Handicap Initial</th><th>Handicap Final</th><th>Changement Total</th><th>Plus Grande Am√©lioration</th><th>Plus Grande D√©gradation</th><th>Parties</th></tr></thead><tbody>';
    
    	    for (var i = 0; i < selectedPlayers.length; i++) {
        	var playerId = selectedPlayers[i];
        	var playerData = handicapEvolutionData[playerId];
        	var evolution = playerData.evolution;
        
        	if (evolution.length < 2) continue;
        
        	var initialHandicap = evolution[0].handicap;
        	var finalHandicap = evolution[evolution.length - 1].handicap;
        	// Trouver l'handicap √† la 6e partie JOU√âE par ce joueur
			var initialHandicapForDisplay = evolution[0].handicap;
			var partiesJouees = 0;
			for (var k = 0; k < evolution.length; k++) {
    			// V√©rifier s'il a jou√© cette partie (a un score)
    			if (evolution[k].score && evolution[k].score > 0) {
        			partiesJouees++;
        			if (partiesJouees === 6) {
            			initialHandicapForDisplay = evolution[k].handicap;
            			break;
        			}
    			}
			}
			// Si le joueur n'a pas 6 parties, garder son handicap initial
			if (partiesJouees < 6) {
    			initialHandicapForDisplay = evolution[0].handicap;
			}
			var totalChange = finalHandicap - initialHandicapForDisplay;
        
        	var bestChange = 0;
        	var worstChange = 0;
        
        	for (var j = 1; j < evolution.length; j++) {
            	    var change = evolution[j].change;
            	    if (change < bestChange) bestChange = change;
            	    if (change > worstChange) worstChange = change;
        	}
        
        	var changeClass = totalChange < 0 ? 'style="color: #28a745;"' : totalChange > 0 ? 'style="color: #dc3545;"' : '';
        	var playerName = playerData.playerName || playerData.player.name || (playerData.player.firstName + ' ' + playerData.player.lastName);
        	var totalGames = evolution.length - 1;
        
        	html += '<tr>' +
                	'<td><strong>' + playerName + '</strong></td>' +
                	'<td>' + initialHandicap.toFixed(1) + '</td>' +
                	'<td>' + finalHandicap.toFixed(1) + '</td>' +
                	'<td ' + changeClass + '><strong>' + (totalChange > 0 ? '+' : '') + totalChange.toFixed(1) + '</strong></td>' +
                	'<td style="color: #28a745;">' + bestChange.toFixed(1) + '</td>' +
                	'<td style="color: #dc3545;">+' + worstChange.toFixed(1) + '</td>' +
                	'<td>' + totalGames + '</td>' +
                	'</tr>';
    	    }
    
    	    html += '</tbody></table>';
    
    	    document.getElementById('handicapStats').innerHTML = html;
	}

	// Exporter les donn√©es d'√©volution
	function exportHandicapData() {
    	    if (selectedPlayers.length === 0) {
        	alert('Veuillez s√©lectionner au moins un joueur');
        	return;
    	    }
    
    	    var csvContent = 'Joueur,Date,Num√©ro Partie,Handicap,Changement,Score,Terrain\n';
    
    	    for (var i = 0; i < selectedPlayers.length; i++) {
        	var playerId = selectedPlayers[i];
        	var playerData = handicapEvolutionData[playerId];
        	var evolution = playerData.evolution;
        
        	// CORRECTION : Utiliser le nom calcul√©
        	var playerName = playerData.playerName || playerData.player.name || (playerData.player.firstName + ' ' + playerData.player.lastName);
        
        	for (var j = 0; j < evolution.length; j++) {
            	    var point = evolution[j];
            	    csvContent += playerName + ',' +  // UTILISER playerName
                         	point.date + ',' +
                                point.gameNumber + ',' +
                         	point.handicap.toFixed(1) + ',' +
                         	point.change.toFixed(1) + ',' +
                         	(point.score || '') + ',' +
                         	(point.course || '') + '\n';
        	}
    	    }
    
    	    var blob = new Blob([csvContent], { type: 'text/csv' });
    	    var link = document.createElement('a');
    	    link.href = URL.createObjectURL(blob);
    	    link.download = 'evolution-handicaps-' + new Date().toISOString().split('T')[0] + '.csv';
    	    link.click();
	}

	// Variables pour la gestion des joueurs
	var nextPlayerId = 14; // Commencer apr√®s les joueurs existants

	// Afficher la section de gestion des joueurs
	function showPlayerManagement() {
    	    hideAllSections();
    	    document.getElementById('playerManagement').style.display = 'block';
    	    setActiveButton(8); // Ajustez selon votre ordre de boutons
    	    loadPlayersGrid();
	}

	// Charger la grille des joueurs
	function loadPlayersGrid() {
    	    var html = '';
    
    	    // CORRECTION : S'assurer que tous les joueurs ont la propri√©t√© 'active'
    	    for (var i = 0; i < players.length; i++) {
        	if (players[i].active === undefined) {
            	    players[i].active = true; // Par d√©faut, tous les joueurs sont actifs
        	}
    	    }
    
    	    var activePlayers = players.filter(p => p.active);
    
    	    console.log("DEBUG: Nombre total de joueurs:", players.length);
    	    console.log("DEBUG: Joueurs actifs:", activePlayers.length);
    
    	    // Statistiques g√©n√©rales
    	    html += '<div class="card" style="background: #f8f9fa;">' +
            	    '<h3>üìä Statistiques du Club</h3>' +
            	    '<div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(150px, 1fr)); gap: 15px;">' +
            	    '<div class="stat-box"><div class="stat-value">' + activePlayers.length + '</div><div class="stat-label">Joueurs Actifs</div></div>' +
            	    '<div class="stat-box"><div class="stat-value">' + (players.length - activePlayers.length) + '</div><div class="stat-label">Joueurs Inactifs</div></div>' +
            	    '<div class="stat-box"><div class="stat-value">' + getAverageHandicap().toFixed(1) + '</div><div class="stat-label">Handicap Moyen</div></div>' +
            	    '<div class="stat-box"><div class="stat-value">' + getTotalGamesPlayed() + '</div><div class="stat-label">Parties Totales</div></div>' +
            	    '</div>' +
            	    '</div>';
    
    	    // CORRECTION : Afficher TOUS les joueurs (actifs ET inactifs) pour la gestion
    	    for (var i = 0; i < players.length; i++) {
        	var player = players[i];
        
        	// CORRECTION : Calculer le nom du joueur
        	var playerName = player.name || (player.firstName + ' ' + player.lastName) || ('Joueur #' + player.id);
        
        	var playerStats = calculatePlayerStats(player);
        	var statusBadge = player.active ? 
            	    '<span style="background: #28a745; color: white; padding: 2px 8px; border-radius: 10px; font-size: 11px;">ACTIF</span>' : 
            	    '<span style="background: #6c757d; color: white; padding: 2px 8px; border-radius: 10px; font-size: 11px;">INACTIF</span>';
        
        	html += '<div class="course-card">' +
                	'<div class="course-header">' +
                	'<div class="course-name">üèåÔ∏è ' + playerName + '</div>' +
                	'<div>' +
                	statusBadge +
                	'<button class="btn-secondary" onclick="editPlayer(' + player.id + ')" style="margin-left: 10px;">‚úèÔ∏è Modifier</button>' +
                	'<button class="btn-danger" onclick="togglePlayerStatus(' + player.id + ')">üîÑ Statut</button>' +
                	'</div>' +
                	'</div>' +
                
                	'<div style="margin: 10px 0; padding: 10px; background: #f8f9fa; border-radius: 5px;">' +
                	'<div style="display: grid; grid-template-columns: 1fr 1fr; gap: 10px; font-size: 14px;">' +
                	'<div><strong>üìû T√©l√©phone:</strong><br>' + (player.phone || 'Non renseign√©') + '</div>' +
                	'<div><strong>üìß Courriel:</strong><br>' + (player.email || 'Non renseign√©') + '</div>' +
                	'<div><strong>üèåÔ∏è Handicap:</strong><br>' + player.handicap.toFixed(1) + '</div>' +
                	'<div><strong>üìÖ Membre depuis:</strong><br>' + formatDate(player.dateJoined) + '</div>' +
                	'</div>' +
                	'</div>' +
                
                	'<div style="border: 2px solid #4a7c59; border-radius: 8px; padding: 15px; background: #fff;">' +
                	'<h4 style="margin: 0 0 10px 0; color: #2c5530;">üìà Statistiques G√©n√©rales</h4>' +
                	'<div style="display: grid; grid-template-columns: repeat(2, 1fr); gap: 10px; text-align: center;">' +
                	'<div style="background: #e8f5e8; padding: 10px; border-radius: 5px;"><strong>' + playerStats.totalGames + '</strong><br><small>Parties</small></div>' +
                	'<div style="background: #e3f2fd; padding: 10px; border-radius: 5px;"><strong>' + playerStats.avgScore.toFixed(1) + '</strong><br><small>Score Moyen</small></div>' +
                	'<div style="background: #fff3e0; padding: 10px; border-radius: 5px;"><strong>' + playerStats.bestScore + '</strong><br><small>Meilleur Score</small></div>' +
                	'<div style="background: #fce4ec; padding: 10px; border-radius: 5px;"><strong>' + playerStats.worstScore + '</strong><br><small>Pire Score</small></div>' +
                	'</div>' +
                	'<div style="margin-top: 10px; text-align: center; font-size: 12px; color: #666;">' +
                	'Derni√®re partie: ' + (playerStats.lastGame || 'Aucune') + 
                	'</div>' +
                	'</div>' +
                
                	'</div>';
    	    }
    
    	    console.log("DEBUG: HTML g√©n√©r√©, longueur:", html.length);
    	    document.getElementById('playersGrid').innerHTML = html;
	}

	// Calculer les statistiques d'un joueur
	function calculatePlayerStats(player) {
    	    var playerIndex = players.findIndex(p => p.id === player.id);
    
    	    console.log("DEBUG: Calcul stats pour joueur", player.id, "index:", playerIndex);
    
    	    if (playerIndex === -1 || !allScores[playerIndex]) {
        	console.log("DEBUG: Pas de scores pour le joueur", player.id);
        	return {
            	    totalGames: 0,
            	    avgScore: 0,
            	    bestScore: 'N/A',
            	    worstScore: 'N/A',
            	    lastGame: 'Aucune'
        	};
    	    }
    
    	    var scores = allScores[playerIndex].filter(score => score > 0);
    
    	    console.log("DEBUG: Joueur", player.id, "a", scores.length, "scores");
    
    	    if (scores.length === 0) {
        	return {
            	    totalGames: 0,
            	    avgScore: 0,
            	    bestScore: 'N/A',
            	    worstScore: 'N/A',
            	    lastGame: 'Aucune'
        	};
    	    }
    
    	    var totalScore = scores.reduce((sum, score) => sum + score, 0);
    	    var avgScore = totalScore / scores.length;
    	    var bestScore = Math.min(...scores);
    	    var worstScore = Math.max(...scores);
    
    	    // Trouver la derni√®re partie
    	    var lastGameIndex = -1;
    	    for (var i = allScores[playerIndex].length - 1; i >= 0; i--) {
        	if (allScores[playerIndex][i] > 0) {
            	    lastGameIndex = i;
            	    break;
        	}
    	    }
    
    	    var lastGame = lastGameIndex >= 0 ? formatDate(dates[lastGameIndex]) : 'Aucune';
    
    	    return {
        	totalGames: scores.length,
        	avgScore: avgScore,
        	bestScore: bestScore,
        	worstScore: worstScore,
        	lastGame: lastGame
    	    };
	}

	// Afficher le formulaire d'ajout de joueur
	function showAddPlayerForm() {
    	    var form = document.getElementById('addPlayerForm');
    	    if (form.style.display === 'none') {
        	form.style.display = 'block';
        	// D√©finir la date d'aujourd'hui par d√©faut
        	document.getElementById('newPlayerDateJoined').value = new Date().toISOString().split('T')[0];
        	// Vider les champs
        	document.getElementById('newPlayerFirstName').value = '';
        	document.getElementById('newPlayerLastName').value = '';
        	document.getElementById('newPlayerPhone').value = '';
        	document.getElementById('newPlayerEmail').value = '';
        	document.getElementById('newPlayerHandicap').value = '';
    	    } else {
        	form.style.display = 'none';
    	    }
	}

	// Sauvegarder un nouveau joueur
	function saveNewPlayer() {
    	    var firstName = document.getElementById('newPlayerFirstName').value.trim();
    	    var lastName = document.getElementById('newPlayerLastName').value.trim();
    	    var phone = document.getElementById('newPlayerPhone').value.trim();
    	    var email = document.getElementById('newPlayerEmail').value.trim();
    	    var handicap = parseFloat(document.getElementById('newPlayerHandicap').value);
    	    var dateJoined = document.getElementById('newPlayerDateJoined').value;
    
    	    // Validation
    	    if (!firstName || !lastName) {
        	alert('Le pr√©nom et le nom sont obligatoires.');
        	return;
    	    }
    
    	    if (isNaN(handicap) || handicap < 0 || handicap > 36.4) {
        	alert('Le handicap doit √™tre un nombre entre 0 et 36.4.');
        	return;
    	    }
    
    	    if (email && !isValidEmail(email)) {
        	alert('L\'adresse courriel n\'est pas valide.');
        	return;
    	    }
    
    	    // V√©rifier si le joueur existe d√©j√†
    	    var existingPlayer = players.find(p => 
        	p.firstName.toLowerCase() === firstName.toLowerCase() && 
        	p.lastName.toLowerCase() === lastName.toLowerCase()
    	    );
    
    	    if (existingPlayer) {
        	alert('Un joueur avec ce nom existe d√©j√†.');
        	return;
    	    }
    
    	    // Trouver le prochain ID disponible
    	    var nextId = Math.max(...players.map(p => p.id)) + 1;
    
    	    // Cr√©er le nouveau joueur
    	    var newPlayer = {
        	id: nextId,
        	firstName: firstName,
        	lastName: lastName,
        	name: firstName + ' ' + lastName,
        	phone: phone,
        	email: email,
        	handicap: handicap,
        	dateJoined: dateJoined,
        	active: true
    	    };
    
    	    players.push(newPlayer);
    
    	    // Ajouter un tableau vide de scores pour ce joueur
    	    var emptyScores = new Array(dates.length).fill(null);
    	    allScores.push(emptyScores);
    
            // Sauvegarder dans Firebase
            Promise.all([
                savePlayersToFirebase(),
                saveScoresToFirebase()
            ]).then(function() {
                console.log('Nouveau joueur sauvegard√© dans Firebase');
            }).catch(function(error) {
                console.error('Erreur de sauvegarde:', error);
                alert('Erreur de sauvegarde: ' + error.message);
            });

    	    // Sauvegarder et recharger
    	    loadPlayersGrid();
    	    showAddPlayerForm(); // Fermer le formulaire
    
    	    alert('‚úÖ Joueur "' + newPlayer.name + '" ajout√© avec succ√®s!');
	}

	// Annuler l'ajout de joueur
	function cancelAddPlayer() {
    	    showAddPlayerForm();
	}

	// √âditer un joueur
	function editPlayer(playerId) {
    	    var player = players.find(p => p.id === playerId);
    	    if (!player) {
        	alert('Joueur non trouv√©!');
        	return;
    	    }
    
    	    var playerName = player.name || (player.firstName + ' ' + player.lastName);
    
    	    // Cr√©er un formulaire d'√©dition plus complet
    	    var formHtml = 
        	'<div style="position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.5); z-index: 1000; display: flex; justify-content: center; align-items: center;">' +
        	'<div style="background: white; padding: 30px; border-radius: 10px; box-shadow: 0 4px 20px rgba(0,0,0,0.3); max-width: 500px; width: 90%;">' +
        	'<h3 style="margin-top: 0; color: #2c5530;">‚úèÔ∏è Modifier ' + playerName + '</h3>' +
        
        	'<div style="margin: 15px 0;">' +
        	'<label style="display: block; font-weight: bold; margin-bottom: 5px;">Pr√©nom:</label>' +
        	'<input type="text" id="editFirstName" value="' + (player.firstName || '') + '" style="width: 100%; padding: 8px; border: 1px solid #ddd; border-radius: 4px;">' +
        	'</div>' +
        
        	'<div style="margin: 15px 0;">' +
        	'<label style="display: block; font-weight: bold; margin-bottom: 5px;">Nom:</label>' +
        	'<input type="text" id="editLastName" value="' + (player.lastName || '') + '" style="width: 100%; padding: 8px; border: 1px solid #ddd; border-radius: 4px;">' +
        	'</div>' +
        
        	'<div style="margin: 15px 0;">' +
        	'<label style="display: block; font-weight: bold; margin-bottom: 5px;">T√©l√©phone:</label>' +
        	'<input type="tel" id="editPhone" value="' + (player.phone || '') + '" style="width: 100%; padding: 8px; border: 1px solid #ddd; border-radius: 4px;">' +
        	'</div>' +
        
        	'<div style="margin: 15px 0;">' +
        	'<label style="display: block; font-weight: bold; margin-bottom: 5px;">Courriel:</label>' +
        	'<input type="email" id="editEmail" value="' + (player.email || '') + '" style="width: 100%; padding: 8px; border: 1px solid #ddd; border-radius: 4px;">' +
        	'</div>' +
        
        	'<div style="margin: 15px 0;">' +
        	'<label style="display: block; font-weight: bold; margin-bottom: 5px;">Handicap:</label>' +
        	'<input type="number" id="editHandicap" value="' + player.handicap + '" step="0.1" min="0" max="36.4" style="width: 100%; padding: 8px; border: 1px solid #ddd; border-radius: 4px;">' +
        	'</div>' +
        
        	'<div style="margin: 15px 0;">' +
        	'<label style="display: block; font-weight: bold; margin-bottom: 5px;">Date d\'adh√©sion:</label>' +
        	'<input type="date" id="editDateJoined" value="' + (player.dateJoined || '') + '" style="width: 100%; padding: 8px; border: 1px solid #ddd; border-radius: 4px;">' +
        	'</div>' +
        
        	'<div style="margin-top: 25px; text-align: center;">' +
        	'<button onclick="savePlayerEdit(' + playerId + ')" style="background: #4a7c59; color: white; border: none; padding: 10px 20px; border-radius: 5px; margin: 5px; cursor: pointer;">üíæ Sauvegarder</button>' +
        	'<button onclick="cancelPlayerEdit()" style="background: #6c757d; color: white; border: none; padding: 10px 20px; border-radius: 5px; margin: 5px; cursor: pointer;">‚ùå Annuler</button>' +
        	'</div>' +
        
        	'</div>' +
        	'</div>';
    
    	    // Ajouter le formulaire au body
    	    var formDiv = document.createElement('div');
    	    formDiv.id = 'editPlayerForm';
    	    formDiv.innerHTML = formHtml;
    	    document.body.appendChild(formDiv);
	}

	function savePlayerEdit(playerId) {
    	    var player = players.find(p => p.id === playerId);
    	    if (!player) return;
    
    	    var newFirstName = document.getElementById('editFirstName').value.trim();
    	    var newLastName = document.getElementById('editLastName').value.trim();
    	    var newPhone = document.getElementById('editPhone').value.trim();
    	    var newEmail = document.getElementById('editEmail').value.trim();
    	    var newHandicap = parseFloat(document.getElementById('editHandicap').value);
    	    var newDateJoined = document.getElementById('editDateJoined').value;
    
    	    // Validation
    	    if (!newFirstName || !newLastName) {
        	alert('Le pr√©nom et le nom sont obligatoires.');
        	return;
    	    }
    
    	    if (isNaN(newHandicap) || newHandicap < 0 || newHandicap > 36.4) {
        	alert('Le handicap doit √™tre un nombre entre 0 et 36.4.');
        	return;
    	    }
    
    	    if (newEmail && !isValidEmail(newEmail)) {
        	alert('L\'adresse courriel n\'est pas valide.');
        	return;
    	    }
    
    	    // Mettre √† jour
    	    player.firstName = newFirstName;
    	    player.lastName = newLastName;
    	    player.name = newFirstName + ' ' + newLastName;
    	    player.phone = newPhone;
    	    player.email = newEmail;
    	    player.handicap = newHandicap;
    	    player.dateJoined = newDateJoined;
    
    	    // Fermer le formulaire
    	    cancelPlayerEdit();
    
    	    // Recharger l'affichage
    	    loadPlayersGrid();
    
    	    alert('‚úÖ Joueur "' + player.name + '" modifi√© avec succ√®s!');
	}

	function cancelPlayerEdit() {
    	    var formDiv = document.getElementById('editPlayerForm');
    	    if (formDiv) {
        	formDiv.remove();
    	    }
	}
		// Basculer le statut actif/inactif d'un joueur
		function togglePlayerStatus(playerId) {
    	    	    var player = players.find(p => p.id === playerId);
    	    	    if (!player) return;
    
    	    	    var action = player.active ? 'd√©sactiver' : 'r√©activer';
    	    	    if (confirm('Voulez-vous ' + action + ' le joueur "' + getPlayerName(player) + '"?')) {
        		player.active = !player.active;
        		savePlayersData();
        		loadPlayersGrid();
        
        		var status = player.active ? 'r√©activ√©' : 'd√©sactiv√©';
        		alert('‚úÖ Joueur ' + status + ' avec succ√®s!');
    	    	    }
		}

	// Fonctions utilitaires
	function getAverageHandicap() {
    	    var activePlayers = players.filter(p => p.active);
    	    if (activePlayers.length === 0) return 0;
    
    	    var total = activePlayers.reduce((sum, p) => sum + p.handicap, 0);
    	    return total / activePlayers.length;
	}

	function getTotalGamesPlayed() {
    	    var total = 0;
    	    for (var i = 0; i < allScores.length; i++) {
        	total += allScores[i].filter(score => score > 0).length;
    	    }
    	    return total;
	}

	function formatDate(dateString) {
    	    if (!dateString) return 'Non d√©finie';
    	    var date = new Date(dateString);
    	    return date.toLocaleDateString('fr-FR');
	}

	function isValidEmail(email) {
    	    var emailRegex = /^[^\s@]+@[^\s@]+\.[^\s@]+$/;
    	    return emailRegex.test(email);
	}

	// Exporter les donn√©es des joueurs
	function exportPlayersData() {
    	    var dataToExport = {
        	players: players,
        	exportDate: new Date().toISOString(),
        	totalPlayers: players.length
    	    };
    
    	    var dataStr = JSON.stringify(dataToExport, null, 2);
    	    var dataBlob = new Blob([dataStr], {type: 'application/json'});
    
    	    var link = document.createElement('a');
    	    link.href = URL.createObjectURL(dataBlob);
    	    link.download = 'joueurs-golf-' + new Date().toISOString().split('T')[0] + '.json';
    	    link.click();
	}	

	// Importer les donn√©es des joueurs
	function importPlayersData() {
    	    document.getElementById('importFile').click();
	}

	function handleFileImport(event) {
    	    var file = event.target.files[0];
    	    if (!file) return;
    
    	    var reader = new FileReader();
    	    reader.onload = function(e) {
        	try {
            	    var importedData = JSON.parse(e.target.result);
            	    if (importedData.players && Array.isArray(importedData.players)) {
                	if (confirm('Cela va remplacer tous les joueurs existants. Continuer?')) {
                    	    players = importedData.players;
                    	    nextPlayerId = Math.max(...players.map(p => p.id)) + 1;
                    	    savePlayersData();
                    	    loadPlayersGrid();
                    	    alert('‚úÖ Joueurs import√©s avec succ√®s!');
                	}	
            	    } else {
                	alert('‚ùå Format de fichier invalide.');
            	    }
        	} catch (error) {
            	    alert('‚ùå Erreur lors de l\'importation: ' + error.message);
        	}
    	    };
    	    reader.readAsText(file);
	}

	function savePlayersData() {
    	    // Simuler la sauvegarde
    	    console.log('Joueurs sauvegard√©s:', players.length + ' joueurs');
	}

	// 4. FONCTION UTILITAIRE POUR OBTENIR LE NOM DU JOUEUR (AJOUTEZ CETTE FONCTION)

	function getPlayerDisplayName(player) {
    	    if (player.name) {
        	return player.name;
    	    } else if (player.firstName && player.lastName) {
        	return player.firstName + ' ' + player.lastName;
    	    } else if (player.firstName) {
        	return player.firstName;
    	    } else {
        	return 'Joueur #' + player.id;
    	    }
	}

	// 5. FONCTION POUR R√âPARER TOUS LES NOMS AUTOMATIQUEMENT

	function fixAllPlayerNames() {
    	    console.log("R√©paration des noms de joueurs...");
    
    	    for (var i = 0; i < players.length; i++) {
        	var player = players[i];
        
        	// Si pas de nom mais firstName/lastName existent
        	if (!player.name && player.firstName && player.lastName) {
            	player.name = player.firstName + ' ' + player.lastName;
            	console.log("R√©par√©:", player.name);
        	}
        	// Si pas de firstName/lastName mais name existe
        	else if (player.name && (!player.firstName || !player.lastName)) {
            	    var parts = player.name.split(' ');
            	    player.firstName = parts[0] || '';
            	    player.lastName = parts.slice(1).join(' ') || '';
            	    console.log("Ajout√© firstName/lastName pour:", player.name);
        	}
    	    }
    
    	    // Mettre √† jour tous les scores existants avec les bons noms
    	    for (var i = 0; i < scores.length; i++) {
        	var score = scores[i];
        	var player = players.find(p => p.id === score.playerId);
        	if (player && (!score.playerName || score.playerName === 'undefined')) {
            	    score.playerName = getPlayerDisplayName(player);
        	}
    	    }
    
    	    console.log("R√©paration termin√©e!");
	}

	// Variables globales pour la nouvelle partie
	var newRoundPlayers = {};

	// Afficher la section d'ajout de partie
	function showAddRound() {
    	    hideAllSections();
    	    document.getElementById('addRound').style.display = 'block';
    	    setActiveButton(8); // Ajustez selon votre ordre de boutons
    	    loadAddRoundInterface();
	}

	// Charger l'interface d'ajout de partie
	function loadAddRoundInterface() {
    	    // D√©finir la date d'aujourd'hui par d√©faut
    	    document.getElementById('newRoundDate').value = new Date().toISOString().split('T')[0];
    
    	    // Charger la liste des terrains
    	    loadCourseOptions();
    
    	    // Charger la grille des joueurs
    	    loadPlayersScoreGrid();
    
    	    // Initialiser les variables
    	    newRoundPlayers = {};

			// AJOUTER CETTE LIGNE :
    		updateGPROptions(); // Forcer l'affichage des options GPR si GPR est s√©lectionn√© par d√©faut
	}

	// Charger les options de terrains
	function loadCourseOptions() {
    	    var select = document.getElementById('newRoundCourse');
    	    select.innerHTML = '<option value="">-- S√©lectionner un terrain --</option>';
    
    	    var courseNames = Object.keys(coursesDatabase).sort();
    
    	    for (var i = 0; i < courseNames.length; i++) {
        	var courseName = courseNames[i];
        	var option = document.createElement('option');
        	option.value = courseName;
        	option.textContent = courseName;
        	select.appendChild(option);
    	    }
	}

	// Mettre √† jour les d√©parts disponibles selon le terrain s√©lectionn√©
	function updateAvailableTees() {
    	    var courseName = document.getElementById('newRoundCourse').value;
    	    var teeSelect = document.getElementById('newRoundDefaultTee');
    
    	    teeSelect.innerHTML = '<option value="">-- Choisir --</option>';
    
    	    if (courseName && coursesDatabase[courseName]) {
        	var tees = coursesDatabase[courseName];
        
        	for (var i = 0; i < tees.length; i++) {
            	    var tee = tees[i];
            	    var option = document.createElement('option');
            	    option.value = tee.tee;
            	    option.textContent = tee.tee.charAt(0).toUpperCase() + tee.tee.slice(1) + 
                               	       ` (Rating: ${tee.rating}, Slope: ${tee.slope}, Par: ${tee.par})`;
            	    teeSelect.appendChild(option);
        	}
    	    }
	}

	// Charger la grille des joueurs pour saisie des scores
	function loadPlayersScoreGrid() {
    	    var html = '';
    
    	    for (var i = 0; i < players.length; i++) {
        	var player = players[i];
        	if (!player.active) continue; // Seulement les joueurs actifs
        
        	var playerName = player.name || (player.firstName + ' ' + player.lastName);
        
        	html += '<div class="course-card" id="playerCard_' + player.id + '">' +
                	'<div class="course-header">' +
                	'<label style="display: flex; align-items: center; gap: 10px;">' +
                	'<input type="checkbox" id="playerCheck_' + player.id + '" onchange="togglePlayerForRound(' + player.id + ')">' +
                	'<span><strong>' + playerName + '</strong></span>' +
                	'<span style="background: #e9ecef; padding: 2px 6px; border-radius: 10px; font-size: 11px;">H: ' + player.handicap.toFixed(1) + '</span>' +
                	'</label>' +
                	'</div>' +
                
                	'<div id="playerInputs_' + player.id + '" style="display: none; margin-top: 15px;">' +
                
                	'<div style="display: grid; grid-template-columns: 1fr 1fr; gap: 10px; margin-bottom: 15px;">' +
                	'<div>' +
                	'<label style="display: block; font-weight: bold; margin-bottom: 5px;">D√©part:</label>' +
                	'<select id="playerTee_' + player.id + '" style="width: 100%; padding: 6px;">' +
                	'<option value="">Utiliser d√©faut</option>' +
                	'</select>' +
                	'</div>' +
                	'<div>' +
                	'<label style="display: block; font-weight: bold; margin-bottom: 5px;">Score Brut:</label>' +
                	'<input type="number" id="playerScore_' + player.id + '" min="50" max="150" style="width: 100%; padding: 6px;" placeholder="Ex: 85">' +
                	'</div>' +
                	'</div>' +
                
                	'<div style="background: #f8f9fa; padding: 10px; border-radius: 5px; font-size: 12px;">' +
                	'<div id="playerPreview_' + player.id + '">S√©lectionnez d\'abord un terrain</div>' +
                	'</div>' +
                
                	'</div>' +
                	'</div>';
    	    }
    
    	    document.getElementById('playersScoreGrid').innerHTML = html;
	}

	// Activer/d√©sactiver un joueur pour la partie
	function togglePlayerForRound(playerId) {
    	    var checkbox = document.getElementById('playerCheck_' + playerId);
    	    var inputs = document.getElementById('playerInputs_' + playerId);
    	    var player = players.find(p => p.id === playerId);
    
    	    if (checkbox.checked) {
        	inputs.style.display = 'block';
        
        	// Initialiser les d√©parts disponibles pour ce joueur
        	updatePlayerTeeOptions(playerId);
        
        	// Ajouter √† la liste
        	newRoundPlayers[playerId] = {
            	    player: player,
            	    tee: '',
            	    score: null
        	};
        
        	// Calculer l'aper√ßu si un terrain est s√©lectionn√©
        	updatePlayerPreview(playerId);
        
    	    } else {
        	inputs.style.display = 'none';
        	delete newRoundPlayers[playerId];
    	    }
	}

	// Mettre √† jour les options de d√©part pour un joueur
	function updatePlayerTeeOptions(playerId) {
    	    var courseName = document.getElementById('newRoundCourse').value;
    	    var defaultTee = document.getElementById('newRoundDefaultTee').value;
    	    var playerTeeSelect = document.getElementById('playerTee_' + playerId);
    
    	    playerTeeSelect.innerHTML = '<option value="">Utiliser d√©faut (' + (defaultTee || 'non d√©fini') + ')</option>';
    
    	    if (courseName && coursesDatabase[courseName]) {
        	var tees = coursesDatabase[courseName];
        
        	for (var i = 0; i < tees.length; i++) {
            	    var tee = tees[i];
            	    var option = document.createElement('option');
            	    option.value = tee.tee;
            	    option.textContent = tee.tee.charAt(0).toUpperCase() + tee.tee.slice(1);
            	    playerTeeSelect.appendChild(option);
        	}
    	    }
	}

	// Mettre √† jour l'aper√ßu pour un joueur
	function updatePlayerPreview(playerId) {
    	    var courseName = document.getElementById('newRoundCourse').value;
    	    var defaultTee = document.getElementById('newRoundDefaultTee').value;
    	    var playerTee = document.getElementById('playerTee_' + playerId).value || defaultTee;
    	    var playerScore = parseInt(document.getElementById('playerScore_' + playerId).value);
    	    var player = players.find(p => p.id === playerId);
    
    	    var previewDiv = document.getElementById('playerPreview_' + playerId);
    
    	    if (!courseName || !playerTee) {
        	previewDiv.innerHTML = 'S√©lectionnez un terrain et un d√©part';
        	return;
    	    }
    
    	    // Calculer le handicap de parcours
    	    var courseHandicap = calculateCourseHandicap(player.handicap, courseName, playerTee);
    	    var netScore = playerScore ? (playerScore - courseHandicap).toFixed(1) : '?';
    
    	    var html = '<strong>Aper√ßu:</strong><br>' +
               	       'D√©part: ' + playerTee + ' | ' +
               	       'Handicap parcours: ' + courseHandicap.toFixed(1) + '<br>' +
               	       'Score net: ' + (playerScore ? playerScore + ' - ' + courseHandicap.toFixed(1) + ' = ' + netScore : 'En attente du score');
    
    	    previewDiv.innerHTML = html;
	}

	// Fonctions de s√©lection rapide
	function selectAllPlayersForRound() {
    	    for (var i = 0; i < players.length; i++) {
        	var player = players[i];
        	if (player.active) {
            	    var checkbox = document.getElementById('playerCheck_' + player.id);
            	    if (!checkbox.checked) {
                	checkbox.checked = true;
                	togglePlayerForRound(player.id);
            	    }
        	}
    	    }
	}

	function clearAllPlayersForRound() {
    	    for (var playerId in newRoundPlayers) {
        	var checkbox = document.getElementById('playerCheck_' + playerId);
        	checkbox.checked = false;
        	togglePlayerForRound(parseInt(playerId));
    	    }
	}

	function selectFrequentPlayers() {
    	    // S√©lectionner les joueurs qui ont jou√© le plus de parties
    	    var playerGameCounts = [];
    
    	    for (var i = 0; i < players.length; i++) {
        	var player = players[i];
        	if (player.active) {
            	    var gameCount = allScores[i] ? allScores[i].filter(score => score > 0).length : 0;
            	    playerGameCounts.push({
                	playerId: player.id,
                	gameCount: gameCount
            	    });
        	}
    	    }
    
    	    // Trier par nombre de parties et prendre les 8 premiers
    	    playerGameCounts.sort((a, b) => b.gameCount - a.gameCount);
    	    var topPlayers = playerGameCounts.slice(0, 8);
    
    	    // D√©s√©lectionner tous d'abord
    	    clearAllPlayersForRound();
    
    	    // S√©lectionner les joueurs fr√©quents
    	    for (var i = 0; i < topPlayers.length; i++) {
        	var playerId = topPlayers[i].playerId;
        	var checkbox = document.getElementById('playerCheck_' + playerId);
        	checkbox.checked = true;
        	togglePlayerForRound(playerId);
    	    }
	}

	// Aper√ßu de la partie
	function previewNewRound() {
    	    var date = document.getElementById('newRoundDate').value;
    	    var courseName = document.getElementById('newRoundCourse').value;
    	    var roundType = document.getElementById('newRoundType').value;
    
    	    if (!date || !courseName) {
        	alert('Veuillez s√©lectionner une date et un terrain.');
        	return;
    	    }
    
    	    var selectedPlayers = Object.keys(newRoundPlayers);
    	    if (selectedPlayers.length === 0) {
        	alert('Veuillez s√©lectionner au moins un joueur.');
        	return;
    	    }
    
    	    // Collecter les donn√©es
    	    var roundData = [];
    	    var hasAllScores = true;
    
    	    for (var i = 0; i < selectedPlayers.length; i++) {
        	var playerId = parseInt(selectedPlayers[i]);
        	var player = players.find(p => p.id === playerId);
        	var defaultTee = document.getElementById('newRoundDefaultTee').value;
        	var playerTee = document.getElementById('playerTee_' + playerId).value || defaultTee;
        	var playerScore = parseInt(document.getElementById('playerScore_' + playerId).value);
        
        	if (!playerScore || !playerTee) {
            	    hasAllScores = false;
        	}
        
        	var courseHandicap = playerTee ? calculateCourseHandicap(player.handicap, courseName, playerTee) : 0;
        	var netScore = playerScore ? playerScore - courseHandicap : null;
        
        	roundData.push({
            	    player: player,
            	    tee: playerTee,
            	    score: playerScore,
            	    courseHandicap: courseHandicap,
            	    netScore: netScore
        	});
    	    }
    
    	    // Trier par score net
    	    roundData.sort((a, b) => {
        	if (!a.netScore) return 1;
        	if (!b.netScore) return -1;
        	return a.netScore - b.netScore;
    	    });
    
    	    // G√©n√©rer l'aper√ßu
    	    var html = '<h4>üìä Aper√ßu de la Partie</h4>' +
               	       '<p><strong>Date:</strong> ' + new Date(date).toLocaleDateString('fr-FR') + '</p>' +
               	       '<p><strong>Terrain:</strong> ' + courseName + '</p>' +
               	       '<p><strong>Type:</strong> ' + (roundType === 'diablo' ? 'üèÜ Diablo' : roundType === 'gpr' ? 'üéØ GPR' : '‚õ≥ Amicale') + '</p>' +
               	       '<p><strong>Joueurs:</strong> ' + selectedPlayers.length + '</p>';
    
    	    if (!hasAllScores) {
        	    html += '<div style="background: #fff3cd; padding: 10px; border-radius: 5px; margin: 10px 0;">' +
                	'‚ö†Ô∏è Certains scores ou d√©parts sont manquants</div>';
    	    }
    
    	    html += '<table class="table">' +
            	    '<thead><tr><th>Pos.</th><th>Joueur</th><th>D√©part</th><th>Score Brut</th><th>Handicap</th><th>Score Net</th></tr></thead>' +
            	    '<tbody>';
    
    	    for (var i = 0; i < roundData.length; i++) {
        	var data = roundData[i];
        	var playerName = data.player.name || (data.player.firstName + ' ' + data.player.lastName);
        
        	html += '<tr>' +
                	'<td>' + (data.netScore ? (i + 1) : '-') + '</td>' +
                	'<td><strong>' + playerName + '</strong></td>' +
                	'<td>' + (data.tee || '‚ùå') + '</td>' +
                	'<td>' + (data.score || '‚ùå') + '</td>' +
                	'<td>' + (data.tee ? data.courseHandicap.toFixed(1) : '-') + '</td>' +
                	'<td><strong>' + (data.netScore ? data.netScore.toFixed(1) : '‚ùå') + '</strong></td>' +
                	'</tr>';
    	    }
    
    	    html += '</tbody></table>';
    
    	    document.getElementById('previewContent').innerHTML = html;
    	    document.getElementById('newRoundPreview').style.display = 'block';
	}

    function saveAllToFirebase() {
        showLoading('Sauvegarde en cours...');
    
        Promise.all([
            savePlayersToFirebase(),
            saveScoresToFirebase(),
            saveCoursesToFirebase(),
            saveDatesToFirebase(),
			saveRoundsToFirebase()
        ]).then(function() {
            hideLoading();
            alert('‚úÖ Toutes les donn√©es sauvegard√©es avec succ√®s!');
        }).catch(function(error) {
            hideLoading();
            console.error('Erreur de sauvegarde compl√®te:', error);
            alert('‚ùå Erreur de sauvegarde: ' + error.message);
        });
    }
    
	// Sauvegarder la nouvelle partie
	function saveNewRound() {
    	    console.log('=== FONCTION saveNewRound() APPEL√âE ==='); // AJOUTE CETTE LIGNE

			var date = document.getElementById('newRoundDate').value;
    	    var courseName = document.getElementById('newRoundCourse').value;
    	    var defaultTee = document.getElementById('newRoundDefaultTee').value;
    	    var roundType = document.getElementById('newRoundType').value;
    
			// === LIGNES DE DEBUG √Ä AJOUTER ===
			console.log('=== DEBUG DATE ===');
			console.log('Date r√©cup√©r√©e du formulaire:', date);
			console.log('Type de la variable date:', typeof date);

    	    // Validation de base
    	    if (!date || !courseName || !defaultTee) {
        	alert('Veuillez remplir tous les champs obligatoires (date, terrain, d√©part par d√©faut).');
        	return;
    	    }
    
    	    var selectedPlayers = Object.keys(newRoundPlayers);
    	    if (selectedPlayers.length === 0) {
        	alert('Veuillez s√©lectionner au moins un joueur.');
        	return;
    	    }
    
    	    // V√©rifier que tous les joueurs ont un score
    	    var missingScores = [];
    	    for (var i = 0; i < selectedPlayers.length; i++) {
        	var playerId = parseInt(selectedPlayers[i]);
        	var playerScore = parseInt(document.getElementById('playerScore_' + playerId).value);
        	var player = players.find(p => p.id === playerId);
        	var playerName = player.name || (player.firstName + ' ' + player.lastName);
        
        	if (!playerScore) {
            	    missingScores.push(playerName);
        	}
    	    }
    
    	    if (missingScores.length > 0) {
        	if (!confirm('Les joueurs suivants n\'ont pas de score :\n' + missingScores.join(', ') + '\n\nContinuer quand m√™me ?')) {
            	return;
        	}
    	    }
    
    	    // Confirmation finale
    	    if (!confirm('Enregistrer cette partie avec ' + selectedPlayers.length + ' joueur(s) ?')) {
        	return;
    	    }
    
    	    // Ajouter la nouvelle partie aux donn√©es
    	    var newRoundId = rounds.length + 1;
    	    // Solution simple : utiliser directement la date string
			var dateParts = date.split('-');
			var year = parseInt(dateParts[0]);
			var month = parseInt(dateParts[1]);
			var day = parseInt(dateParts[2]);

			// === AJOUTER CES LIGNES DE DEBUG ===
			console.log('Parties de date:', dateParts);
			console.log('Ann√©e:', year, 'Mois:', month, 'Jour:', day);

			// Pour l'affichage et le stockage, garder la date string originale
			var gameDate = new Date(year, month - 1, day);
    
			// === AJOUTER CETTE LIGNE DE DEBUG ===
			console.log('Date finale cr√©√©e:', gameDate);
			console.log('Date qui sera stock√©e dans dates[]:', date);

    	    // R√©cup√©rer les m√©tadonn√©es GPR
			var gprPhase = '';
			var finaleFormat = '';
			var isGPRRound = false;

			if (roundType === 'gpr') {
    			isGPRRound = true;
    			gprPhase = document.getElementById('gprPhase').value;
    			finaleFormat = document.getElementById('finaleFormat').value;
			}

			// D√©terminer le type automatiquement si "amicale"
			var finalType = roundType;
			if (roundType === 'amicale') {
    			var isDiablo = (courseName === 'Le Diable' || courseName === 'Le G√©ant' || courseName === 'Manoir des Sables') || month === 9;
    			finalType = isDiablo ? 'diablo' : 'gpr';
			}
    
    	    // Ajouter aux rounds avec m√©tadonn√©es GPR
			var newRound = {
    			id: newRoundId,
    			date: date,
    			course: courseName,
    			tee: defaultTee,
    			type: finalType,
    			year: year,
    			month: month
			};

			// Ajouter les m√©tadonn√©es GPR si applicable
			if (isGPRRound) {
    			newRound.gprPhase = gprPhase;
    			newRound.gprFinaleFormat = finaleFormat;
			}

			rounds.push(newRound);

			// Sauvegarder les m√©tadonn√©es GPR s√©par√©ment
			if (isGPRRound) {
    			gprRoundsData.push({
        			roundId: newRoundId,
        			phase: gprPhase,
        			finaleFormat: finaleFormat,
        			date: date
    			});
			}
    
    	    // Ajouter aux dates et courses
    	    dates.push(date);
    	    courses.push(courseName);
    	    teeUsed.push(defaultTee);
    
    	    // √âtendre allScores pour tous les joueurs
    	    for (var i = 0; i < allScores.length; i++) {
        	allScores[i].push(null);
    	    }
    
    	    // Ajouter les scores des joueurs participants
    	    var savedCount = 0;
    
    	    for (var i = 0; i < selectedPlayers.length; i++) {
        	var playerId = parseInt(selectedPlayers[i]);
        	var playerIndex = players.findIndex(p => p.id === playerId);
        	var playerScore = parseInt(document.getElementById('playerScore_' + playerId).value);
        	var playerTee = document.getElementById('playerTee_' + playerId).value || defaultTee;
        	var player = players.find(p => p.id === playerId);
        
        	if (playerIndex !== -1 && playerScore) {
            	    // Mettre le score dans allScores
            	    allScores[playerIndex][allScores[playerIndex].length - 1] = playerScore;
            
            	    // Ajouter aux scores calcul√©s
            	    var courseHandicap = calculateCourseHandicap(player.handicap, courseName, playerTee);
            	    var netScore = playerScore - courseHandicap;
            	    var playerName = player.name || (player.firstName + ' ' + player.lastName);
            
            	    scores.push({
                	roundId: newRoundId,
                	playerId: playerId,
                	playerName: playerName,
                	score: playerScore,
                	courseHandicap: courseHandicap,
                	net: netScore,
                	tee: playerTee,
                	type: finalType,
                	year: year,
                	month: month
            	    });
            
            	    savedCount++;
        	}
    	    }
            
            // Sauvegarder dans Firebase
            Promise.all([
                saveScoresToFirebase(),
                saveDatesToFirebase()
            ]).then(function() {
                console.log('üî• TEST DEBUG - LIGNE JUSTE AVANT FIREBASE');
				console.log('Nouvelle partie sauvegard√©e dans Firebase');
            }).catch(function(error) {
                console.error('Erreur de sauvegarde partie:', error);
                alert('Erreur de sauvegarde: ' + error.message);
            });

    	    // Confirmation et nettoyage
    	    alert('‚úÖ Partie enregistr√©e avec succ√®s !\n' + savedCount + ' score(s) sauvegard√©(s).');
    
    	    resetNewRoundForm();
    
    	    // Optionnel : aller voir la partie dans les d√©tails
    	    if (confirm('Voulez-vous voir cette partie dans les d√©tails ?')) {
        	showDetails();
        	document.getElementById('roundSelect').value = newRoundId;
        	showRoundDetail();
    	    }
	}

	// R√©initialiser le formulaire
	function resetNewRoundForm() {
    	    document.getElementById('newRoundDate').value = new Date().toISOString().split('T')[0];
    	    document.getElementById('newRoundCourse').value = '';
    	    document.getElementById('newRoundDefaultTee').innerHTML = '<option value="">-- Choisir --</option>';
    	    document.getElementById('newRoundType').value = 'gpr';
    	    document.getElementById('newRoundPreview').style.display = 'none';
    
    	    clearAllPlayersForRound();
    	    loadPlayersScoreGrid();
	}

	// === FONCTIONS DE GESTION DES PARTIES ===

	// Supprimer une partie compl√®tement
	function deleteRound(roundId) {
    	if (!confirm('‚ö†Ô∏è ATTENTION ! Supprimer d√©finitivement cette partie ?\n\nCette action ne peut pas √™tre annul√©e.')) {
        	return;
    	}
    
    	console.log('Suppression de la partie ID:', roundId);
    
    	// Trouver l'index de la partie dans les arrays
    	var roundIndex = rounds.findIndex(r => r.id === roundId);
    	var dateIndex = roundIndex;
    
    	if (roundIndex === -1) {
        	alert('‚ùå Partie non trouv√©e !');
        	return;
    	}
    
    	// Supprimer de rounds
    	rounds.splice(roundIndex, 1);
    
    	// Supprimer de dates, courses, teeUsed
    	if (dateIndex !== -1) {
        	dates.splice(dateIndex, 1);
        	courses.splice(dateIndex, 1);
        	teeUsed.splice(dateIndex, 1);
    	}
    
    	// Supprimer les scores de tous les joueurs pour cette partie
    	for (var i = 0; i < allScores.length; i++) {
        	if (allScores[i] && dateIndex !== -1) {
            	allScores[i].splice(dateIndex, 1);
        	}
    	}
    
    	// Supprimer de l'array scores
    	scores = scores.filter(s => s.roundId !== roundId);
    
    	// Supprimer des m√©tadonn√©es GPR
    	gprRoundsData = gprRoundsData.filter(g => g.roundId !== roundId);
    
    	// Sauvegarder dans Firebase
    	Promise.all([
        	saveScoresToFirebase(),
        	saveDatesToFirebase()
    	]).then(function() {
        	console.log('Partie supprim√©e de Firebase');
        	alert('‚úÖ Partie supprim√©e avec succ√®s !');
        
        	// Rafra√Æchir l'affichage
        	if (document.getElementById('details').style.display === 'block') {
            	loadDetails();
        	}
        	if (document.getElementById('gpr').style.display === 'block') {
            	loadGPR();
        	}
        	if (document.getElementById('diablo').style.display === 'block') {
            	loadDiablo();
        	}
        
    	}).catch(function(error) {
        	console.error('Erreur de suppression:', error);
        	alert('‚ùå Erreur lors de la suppression: ' + error.message);
    	});
	}

	// Afficher le formulaire de modification d'une partie
	function editRound(roundId) {
    	var round = rounds.find(r => r.id === roundId);
    	if (!round) {
        	alert('‚ùå Partie non trouv√©e !');
        	return;
    	}
    
    	// Cr√©er la popup de modification
    	var formHtml = 
        	'<div style="position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.5); z-index: 1000; overflow-y: auto;">' +
        	'<div style="background: white; padding: 30px; margin: 50px auto; border-radius: 10px; box-shadow: 0 4px 20px rgba(0,0,0,0.3); max-width: 800px; width: 90%;">' +
        	'<h3 style="margin-top: 0; color: #2c5530;">‚úèÔ∏è Modifier la Partie</h3>' +
        
        	'<div style="margin: 15px 0;">' +
        	'<label style="display: block; font-weight: bold; margin-bottom: 5px;">Date:</label>' +
        	'<input type="date" id="editRoundDate" value="' + round.date + '" style="width: 200px; padding: 8px; border: 1px solid #ddd; border-radius: 4px;">' +
        	'</div>' +
        
        	'<div style="margin: 15px 0;">' +
        	'<label style="display: block; font-weight: bold; margin-bottom: 5px;">Terrain:</label>' +
        	'<select id="editRoundCourse" style="width: 300px; padding: 8px;">';
    
    	// Ajouter les options de terrains
    	var courseNames = Object.keys(coursesDatabase).sort();
    	for (var i = 0; i < courseNames.length; i++) {
        	var selected = courseNames[i] === round.course ? ' selected' : '';
			var courseName = courseNames[i].replace(/"/g, '&quot;');
			formHtml += '<option value="' + courseName + '"' + selected + '>' + courseNames[i] + '</option>';
    	}
    
    	formHtml += '</select></div>' +
        
        	'<div style="margin: 15px 0;">' +
        	'<label style="display: block; font-weight: bold; margin-bottom: 5px;">Type:</label>' +
        	'<select id="editRoundType" style="width: 200px; padding: 8px;" onchange="updateEditGPROptions()">' +
        	'<option value="gpr"' + (round.type === 'gpr' ? ' selected' : '') + '>üéØ GPR</option>' +
        	'<option value="diablo"' + (round.type === 'diablo' ? ' selected' : '') + '>üèÜ Diablo</option>' +
        	'<option value="amicale"' + (round.type === 'amicale' ? ' selected' : '') + '>‚õ≥ Amicale</option>' +
        	'</select>' +
        	'</div>' +
        
        	// Options GPR
        	'<div id="editGprOptions" style="display: ' + (round.type === 'gpr' ? 'block' : 'none') + '; margin: 15px 0; padding: 15px; background: #e7f3ff; border-radius: 8px;">' +
        	'<h4 style="margin-top: 0;">‚öôÔ∏è Configuration GPR</h4>' +
        	'<div style="margin: 10px 0;">' +
       		'<label style="display: block; font-weight: bold; margin-bottom: 5px;">Phase GPR:</label>' +
        	'<select id="editGprPhase" style="width: 200px; padding: 8px;" onchange="updateEditFinaleOptions()">' +
        	'<option value="exhibition"' + (round.gprPhase === 'exhibition' ? ' selected' : '') + '>üìä Exhibition</option>' +
        	'<option value="finale"' + (round.gprPhase === 'finale' ? ' selected' : '') + '>üèÜ Finale</option>' +
        	'</select>' +
        	'</div>' +
        	'<div id="editFinaleOptions" style="display: ' + (round.gprPhase === 'finale' ? 'block' : 'none') + '; margin: 10px 0;">' +
        	'<label style="display: block; font-weight: bold; margin-bottom: 5px;">Format finale:</label>' +
        	'<select id="editFinaleFormat" style="width: 200px; padding: 8px;">' +
        	'<option value="2days"' + (round.gprFinaleFormat === '2days' ? ' selected' : '') + '>üìÖ Finale 2 jours</option>' +
        	'<option value="1day"' + (round.gprFinaleFormat === '1day' ? ' selected' : '') + '>‚ö° Finale 1 jour</option>' +
        	'</select>' +
        	'</div>' +
        	'</div>' +
        
        	'<h4>üë• Scores des Joueurs</h4>' +
        	'<div id="editPlayersScores" style="max-height: 300px; overflow-y: auto; border: 1px solid #ddd; padding: 15px; border-radius: 5px;">';
    
    	// Ajouter les scores des joueurs
    	var roundScores = scores.filter(s => s.roundId === roundId);
    	for (var i = 0; i < roundScores.length; i++) {
        	var score = roundScores[i];
        	formHtml += '<div style="display: flex; align-items: center; gap: 15px; margin: 10px 0; padding: 10px; background: #f8f9fa; border-radius: 5px;">' +
            	'<span style="width: 150px; font-weight: bold;">' + score.playerName + '</span>' +
            	'<label>Score: <input type="number" id="editScore_' + score.playerId + '" value="' + score.score + '" min="50" max="150" style="width: 80px; padding: 5px;"></label>' +
            	'<span style="font-size: 12px; color: #666;">Handicap: ' + score.courseHandicap.toFixed(1) + ' | Net: ' + score.net.toFixed(1) + '</span>' +
            	'</div>';
    	}
    
    	formHtml += '</div>' +
        
        	'<div style="margin-top: 25px; text-align: center;">' +
        	'<button onclick="saveRoundEdit(' + roundId + ')" style="background: #4a7c59; color: white; border: none; padding: 12px 24px; border-radius: 5px; margin: 5px; cursor: pointer; font-size: 16px;">üíæ Sauvegarder</button>' +
        	'<button onclick="cancelRoundEdit()" style="background: #6c757d; color: white; border: none; padding: 12px 24px; border-radius: 5px; margin: 5px; cursor: pointer; font-size: 16px;">‚ùå Annuler</button>' +
        	'<button onclick="deleteRound(' + roundId + ')" style="background: #dc3545; color: white; border: none; padding: 12px 24px; border-radius: 5px; margin: 5px; cursor: pointer; font-size: 16px;">üóëÔ∏è Supprimer</button>' +
        	'</div>' +
        
        	'</div></div>';
    
    	// Ajouter la popup au body
    	var popup = document.createElement('div');
    	popup.id = 'editRoundPopup';
    	popup.innerHTML = formHtml;
    	document.body.appendChild(popup);
	}

	// Fonctions auxiliaires pour la modification
	function updateEditGPROptions() {
    	var roundType = document.getElementById('editRoundType').value;
    	var gprOptions = document.getElementById('editGprOptions');
    
    	if (roundType === 'gpr') {
        	gprOptions.style.display = 'block';
    	} else {
        	gprOptions.style.display = 'none';
    	}
	}

	function updateEditFinaleOptions() {
    	var gprPhase = document.getElementById('editGprPhase').value;
    	var finaleOptions = document.getElementById('editFinaleOptions');
    
    	if (gprPhase === 'finale') {
        	finaleOptions.style.display = 'block';
    	} else {
        	finaleOptions.style.display = 'none';
    	}
	}

	// Sauvegarder les modifications
	function saveRoundEdit(roundId) {
    	var newDate = document.getElementById('editRoundDate').value;
    	var newCourse = document.getElementById('editRoundCourse').value;
    	var newType = document.getElementById('editRoundType').value;
    	var newGprPhase = document.getElementById('editGprPhase').value;
    	var newFinaleFormat = document.getElementById('editFinaleFormat').value;
    
    	if (!confirm('Sauvegarder les modifications de cette partie ?')) {
        	return;
    	}
    
    	// Mettre √† jour l'objet round
    	var round = rounds.find(r => r.id === roundId);
    	var roundIndex = rounds.findIndex(r => r.id === roundId);
    	var dateIndex = roundIndex;
    
    	if (round && roundIndex !== -1) {
        	// Mettre √† jour les donn√©es de base
        	round.date = newDate;
        	round.course = newCourse;
        	round.type = newType;
        
        	if (newType === 'gpr') {
            	round.gprPhase = newGprPhase;
            	round.gprFinaleFormat = newFinaleFormat;
        	}
        
        	// Mettre √† jour les arrays parall√®les (utiliser roundIndex au lieu de dateIndex)
			if (roundIndex !== -1) {
    			dates[roundIndex] = newDate;
    			courses[roundIndex] = newCourse;
    			// Garder le m√™me tee pour simplicit√©, ou ajouter une option pour le modifier
			}
        
        	// Mettre √† jour les scores des joueurs
        	var roundScores = scores.filter(s => s.roundId === roundId);
        	for (var i = 0; i < roundScores.length; i++) {
            	var score = roundScores[i];
            	var newScore = parseInt(document.getElementById('editScore_' + score.playerId).value);
            
            	if (newScore && newScore !== score.score) {
                	// Recalculer le handicap de parcours et le net
                	var player = players.find(p => p.id === score.playerId);
                	var teeForPlayer = (score.playerId === 1) ? 'bleu' : 'blanc'; // Logique simplifi√©e
                	var courseHandicap = calculateCourseHandicap(player.handicap, newCourse, teeForPlayer);
                	var netScore = newScore - courseHandicap;
                
                	// Mettre √† jour le score
                	score.score = newScore;
                	score.net = netScore;
                	score.courseHandicap = courseHandicap;
                
                	// Mettre √† jour allScores
                	var playerIndex = players.findIndex(p => p.id === score.playerId);
                	if (playerIndex !== -1 && dateIndex !== -1) {
                    	allScores[playerIndex][dateIndex] = newScore;
                	}
            	}
        	}
        
        	// Sauvegarder dans Firebase
        	Promise.all([
            	saveScoresToFirebase(),
            	saveDatesToFirebase()
        	]).then(function() {
            	console.log('Modifications sauvegard√©es dans Firebase');
            	alert('‚úÖ Partie modifi√©e avec succ√®s !');
            	cancelRoundEdit();
            
            	// Rafra√Æchir l'affichage
            	if (document.getElementById('details').style.display === 'block') {
                	loadDetails();
                	document.getElementById('roundSelect').value = roundId;
                	showRoundDetail();
            	}
            
        	}).catch(function(error) {
            	console.error('Erreur de modification:', error);
            	alert('‚ùå Erreur lors de la modification: ' + error.message);
        	});
    	}
	}

	// Fermer la popup de modification
	function cancelRoundEdit() {
    	var popup = document.getElementById('editRoundPopup');
    	if (popup) {
        	popup.remove();
    	}
	}

	// Fonction pour g√©n√©rer des scores de test
	function generateTestRound() {
    	if (!confirm('G√©n√©rer une partie de test avec des scores al√©atoires ?')) {
        	return;
    	}
    
    	// S√©lectionner un terrain au hasard
    	var courseNames = Object.keys(coursesDatabase);
    	var randomCourse = courseNames[Math.floor(Math.random() * courseNames.length)];
    
    	// Date d'aujourd'hui
    	var today = new Date().toISOString().split('T')[0];
    
    	// S√©lectionner 6-8 joueurs actifs au hasard
    	var activePlayers = players.filter(p => p.active);
    	var numPlayers = Math.floor(Math.random() * 3) + 6; // 6 √† 8 joueurs
    	var selectedPlayers = [];
    
    	for (var i = 0; i < Math.min(numPlayers, activePlayers.length); i++) {
        	var randomIndex = Math.floor(Math.random() * activePlayers.length);
        	var player = activePlayers[randomIndex];
        	if (selectedPlayers.findIndex(p => p.id === player.id) === -1) {
            	selectedPlayers.push(player);
        	}
    	}
    
    	// G√©n√©rer les scores (par + handicap ¬± variation al√©atoire)
    	var newRoundId = rounds.length + 1;
    	var year = parseInt(today.split('-')[0]);
    	var month = parseInt(today.split('-')[1]);
    
    	// Ajouter la partie
    	rounds.push({
        	id: newRoundId,
        	date: today,
        	course: randomCourse,
        	tee: 'blanc',
        	type: 'gpr',
        	year: year,
        	month: month
    	});
    
    	dates.push(today);
    	courses.push(randomCourse);
    	teeUsed.push('blanc');
    
    	// √âtendre allScores
    	for (var i = 0; i < allScores.length; i++) {
        	allScores[i].push(null);
    	}
    
    	// G√©n√©rer les scores
    	for (var i = 0; i < selectedPlayers.length; i++) {
        	var player = selectedPlayers[i];
        	var playerIndex = players.findIndex(p => p.id === player.id);
        
        	// Score = 72 (par moyen) + handicap + variation (-5 √† +10)
        	var baseScore = 72 + player.handicap;
        	var variation = Math.floor(Math.random() * 16) - 5; // -5 √† +10
        	var testScore = Math.max(65, Math.min(120, Math.round(baseScore + variation)));
        
        	// Sauvegarder le score
        	allScores[playerIndex][allScores[playerIndex].length - 1] = testScore;
        
        	// Calculer handicap de parcours et net
        	var teeForPlayer = (player.id === 1) ? 'blanc' : 'blanc';
        	var courseHandicap = calculateCourseHandicap(player.handicap, randomCourse, teeForPlayer);
        	var netScore = testScore - courseHandicap;
        	var playerName = player.name || (player.firstName + ' ' + player.lastName);
        
        	scores.push({
            	roundId: newRoundId,
            	playerId: player.id,
            	playerName: playerName,
            	score: testScore,
            	courseHandicap: courseHandicap,
            	net: netScore,
            	tee: teeForPlayer,
            	type: 'gpr',
            	year: year,
            	month: month
        	});
    	}
    
    	// Sauvegarder
    	Promise.all([
        	saveScoresToFirebase(),
        	saveDatesToFirebase()
    	]).then(function() {
        	alert('‚úÖ Partie de test g√©n√©r√©e avec ' + selectedPlayers.length + ' joueurs !\nTerrain: ' + randomCourse);
        
        	// Aller voir la partie
        	showDetails();
        	loadDetails();
        	document.getElementById('roundSelect').value = newRoundId;
        	showRoundDetail();
        
    	}).catch(function(error) {
        	console.error('Erreur g√©n√©ration test:', error);
        	alert('‚ùå Erreur: ' + error.message);
    	});
	}
	// Nouvelles fonctions pour le syst√®me GPR

	// Afficher/masquer les options GPR
	function updateGPROptions() {
   		console.log('updateGPROptions appel√©e'); // Pour debug
    	var roundType = document.getElementById('newRoundType').value;
    	var gprOptions = document.getElementById('gprOptions');
    
    	console.log('Type s√©lectionn√©:', roundType); // Pour debug
    
    	if (roundType === 'gpr') {
        	gprOptions.style.display = 'block';
        	console.log('Options GPR affich√©es'); // Pour debug
    	} else {
        	gprOptions.style.display = 'none';
        	console.log('Options GPR masqu√©es'); // Pour debug
    	}
	}

	// Afficher/masquer les options de finale
	function updateFinaleOptions() {
    	var gprPhase = document.getElementById('gprPhase').value;
    	var finaleOptions = document.getElementById('finaleOptions');
    
    	if (gprPhase === 'finale') {
        	finaleOptions.style.display = 'block';
    	} else {
        	finaleOptions.style.display = 'none';
    	}
	}

	// Calculer les points GPR selon les nouvelles r√®gles
	function calculateGPRPoints(position, isNet, isFinale, finaleFormat) {
    	// Points exhibition
    	var exhibitionBrutPoints = [80, 68, 60, 52, 45, 40, 35, 30, 25, 20, 15, 10];
    	var exhibitionNetPoints = [120, 105, 90, 78, 70, 62, 54, 46, 38, 30, 22, 15];
    
    	// Points finale (base pour 2 jours - 200 points par jour)
    	var finaleBrutPoints = [175, 140, 120, 100, 85, 70, 60, 50, 40, 30, 20, 10];
    	var finaleNetPoints = [225, 190, 165, 140, 125, 110, 90, 75, 60, 45, 35, 25];
    
    	var points;
    
    	if (isFinale) {
        	points = isNet ? finaleNetPoints : finaleBrutPoints;
        	// Finale 1 jour = m√™me distribution que 2 jours (400 points total)
        	// Pas besoin de doubler, les points sont d√©j√† corrects pour 400 total
    	} else {
        	points = isNet ? exhibitionNetPoints : exhibitionBrutPoints;
    	}
    
    	// Position est 1-index√©e, tableau est 0-index√©
    	return points[Math.min(position - 1, points.length - 1)] || 0;
	}

	// Exclure √âric Gosselin (ID 12) du pointage GPR
	function isEricGosselin(playerId) {
    	return playerId === 13;
	}

	// Variables globales pour le calendrier
	var calendarEvents = [];
	var teeTimeCounter = 1;
	var currentDate = new Date();
	var currentMonth = currentDate.getMonth();
	var currentYear = currentDate.getFullYear();

	// Noms des mois et jours en fran√ßais
	var monthNames = [
    	'Janvier', 'F√©vrier', 'Mars', 'Avril', 'Mai', 'Juin',
    	'Juillet', 'Ao√ªt', 'Septembre', 'Octobre', 'Novembre', 'D√©cembre'
	];
	var dayNames = ['Dim', 'Lun', 'Mar', 'Mer', 'Jeu', 'Ven', 'Sam'];

	// Fonction principale pour afficher le calendrier
	function showCalendar() {
    	console.log('üöÄ showCalendar() - Version s√©curis√©e');
    
    	hideAllSections();
    
    	var calendarSection = document.getElementById('calendar');
    	if (calendarSection) {
        	calendarSection.style.display = 'block';
        	console.log('‚úÖ Section calendar affich√©e');
    	} else {
        	console.error('‚ùå Section calendar non trouv√©e!');
        	return;
    	}
    
    	setActiveButton('showCalendar');
    
    	// Initialiser variables globales si n√©cessaire
    	if (typeof currentMonth === 'undefined') {
        	var now = new Date();
        	currentMonth = now.getMonth();
        	currentYear = now.getFullYear();
        	console.log('üîß Variables initialis√©es:', currentMonth, currentYear);
    	}
    
    	// Afficher la vue mensuelle
    	showMonthView();
	}

	// Charger les donn√©es du calendrier depuis Firebase
	function loadCalendarData() {
    	// Cette fonction sera utilis√©e plus tard pour charger depuis Firebase
    	return database.ref('calendarEvents').once('value').then(function(snapshot) {
        	if (snapshot.exists()) {
            	calendarEvents = snapshot.val() || [];
        	}
    	}).catch(function(error) {
        	console.log('Pas de donn√©es calendrier dans Firebase, utilisation tableau vide');
        	calendarEvents = [];
    	});
	}

	// Sauvegarder les √©v√©nements dans Firebase
	function saveCalendarToFirebase() {
    	return database.ref('calendarEvents').set(calendarEvents);
	}

	// Afficher la vue mensuelle
	function showMonthView() {
    	// S'assurer que les √©l√©ments existent
    	var calendarView = document.getElementById('calendarView');
    	var listView = document.getElementById('listView');
    
    	if (calendarView) {
        	calendarView.style.display = 'block';
    	}
    	if (listView) {
        	listView.style.display = 'none';
    	}
    
    	updateMonthTitle();
    	generateCalendar();
	}

	// Mettre √† jour le titre du mois
	function updateMonthTitle() {
    	var monthTitleElement = document.getElementById('monthTitle');
    	if (monthTitleElement) {
        	monthTitleElement.textContent = monthNames[currentMonth] + ' ' + currentYear;
    	}
	}

	// 3. FONCTION generateCalendar ULTRA-S√âCURIS√âE
	function generateCalendar() {
    	console.log('=== generateCalendar() appel√©e ===');
    
    	var calendarViewElement = document.getElementById('calendarView');
    	if (!calendarViewElement) {
        	console.error('‚ùå Element calendarView non trouv√©!');
        	return;
    	}
    	console.log('‚úÖ calendarViewElement trouv√©');
    
    	// Variables locales s√©curis√©es
    	var today = new Date();
    	var workingMonth = (typeof currentMonth !== 'undefined') ? currentMonth : today.getMonth();
    	var workingYear = (typeof currentYear !== 'undefined') ? currentYear : today.getFullYear();
    
    	console.log('üìÖ Mois:', workingMonth, 'Ann√©e:', workingYear);
    
    	var html = '<div class="calendar-grid">';
    	console.log('üèóÔ∏è Construction HTML commenc√©e');
    
    	// En-t√™tes des jours (s√©curis√©)
    	var safeDayNames = ['Dim', 'Lun', 'Mar', 'Mer', 'Jeu', 'Ven', 'Sam'];
    	for (var i = 0; i < safeDayNames.length; i++) {
        	html += '<div class="calendar-header">' + safeDayNames[i] + '</div>';
    	}
    	console.log('‚úÖ En-t√™tes g√©n√©r√©s');
    
    	// Calcul dates (s√©curis√©)
    	try {
        	var firstDay = new Date(workingYear, workingMonth, 1);
        	var startDate = new Date(firstDay);
        	startDate.setDate(startDate.getDate() - firstDay.getDay());
        	console.log('‚úÖ Calcul dates OK');
        
        	// G√©n√©rer 42 jours (s√©curis√©)
        	for (var i = 0; i < 42; i++) {
            	var cellDate = new Date(startDate);
            	cellDate.setDate(startDate.getDate() + i);
            
            	var isCurrentMonth = cellDate.getMonth() === workingMonth;
            	var isToday = (cellDate.getDate() === today.getDate() && 
                	          cellDate.getMonth() === today.getMonth() && 
                    	      cellDate.getFullYear() === today.getFullYear());
            
            	var cellClass = 'calendar-day';
            	if (!isCurrentMonth) cellClass += ' other-month';
            	if (isToday) cellClass += ' today';
            
            	// Format date s√©curis√©
            	var dateStr = formatDateForInput(cellDate);
            
            	html += '<div class="' + cellClass + '" onclick="selectDate(\'' + dateStr + '\')">';
            	html += '<div class="calendar-day-number">' + cellDate.getDate() + '</div>';
            	html += '</div>';
        	}
        	console.log('‚úÖ 42 jours g√©n√©r√©s');
        
    	} catch (error) {
        	console.error('‚ùå Erreur dans calcul dates:', error);
        	html += '<div style="padding: 20px; color: red;">Erreur g√©n√©ration calendrier: ' + error.message + '</div>';
    	}
    
    	html += '</div>';
    
    	// Injection HTML
    	try {
        	calendarViewElement.innerHTML = html;
        	console.log('‚úÖ HTML inject√©, longueur:', html.length);
        	console.log('üìÑ HTML aper√ßu:', html.substring(0, 200) + '...');
    	} catch (error) {
        	console.error('‚ùå Erreur injection HTML:', error);
    	}
	}

	// Changer de mois
	function changeMonth(direction) {
    	currentMonth += direction;
    	if (currentMonth > 11) {
        	currentMonth = 0;
        	currentYear++;
    	} else if (currentMonth < 0) {
        	currentMonth = 11;
        	currentYear--;
    	}
    	showMonthView();
	}

	// Fonctions utilitaires
	function isDateToday(date) {
    	var today = new Date();
    	return date.getDate() === today.getDate() && 
        	   date.getMonth() === today.getMonth() && 
        	   date.getFullYear() === today.getFullYear();
	}

	function getEventsForDate(date) {
    	var dateStr = formatDateForInput(date);
    	return calendarEvents.filter(function(event) {
        	return event.date === dateStr;
    	});
	}

	// 1. FONCTION formatDateForInput CORRIG√âE (sans padStart)
	function formatDateForInput(date) {
    	var year = date.getFullYear();
    	var month = date.getMonth() + 1;
    	var day = date.getDate();
    
    	// Fonction de padding manuelle (compatible tous navigateurs)
    	function pad(num) {
        	return num < 10 ? '0' + num : num.toString();
    	}
    
    	return year + '-' + pad(month) + '-' + pad(day);
	}

	function selectDate(dateStr) {
    	var eventDateInput = document.getElementById('eventDate');
    	if (eventDateInput) {
        	eventDateInput.value = dateStr;
    	}
    	showAddEvent();
	}

	// Afficher le formulaire d'ajout
	function showAddEvent() {
    	var form = document.getElementById('addEventForm');
    	if (!form) {
        	console.error('Formulaire addEventForm non trouv√©!');
        	return;
    	}
    
    	form.style.display = form.style.display === 'none' ? 'block' : 'none';
    
    	if (form.style.display === 'block') {
        	// Initialiser le formulaire
        	var eventDate = document.getElementById('eventDate');
        	var eventComments = document.getElementById('eventComments');
        
        	if (eventDate && !eventDate.value) {
            	eventDate.value = formatDateForInput(new Date());
        	}
        	if (eventComments) {
            	eventComments.value = '';
        	}
        
        	// Charger les terrains et organisateurs
        	loadEventCourseOptions();
        	loadOrganizerOptions();
        
        	// R√©initialiser les heures de d√©part
        	teeTimeCounter = 1;
        	var teeTimesList = document.getElementById('teeTimesList');
        	if (teeTimesList) {
            	teeTimesList.innerHTML = '';
            	addTeeTime(); // Ajouter une premi√®re heure par d√©faut
        	}
    	}
	}

	// Charger les options de terrains
	function loadEventCourseOptions() {
    	var select = document.getElementById('eventCourse');
    	if (!select) return;
    
    	select.innerHTML = '<option value="">-- S√©lectionner un terrain --</option>';
    
    	var courseNames = Object.keys(coursesDatabase).sort();
    	for (var i = 0; i < courseNames.length; i++) {
        	var option = document.createElement('option');
        	option.value = courseNames[i];
        	option.textContent = courseNames[i];
        	select.appendChild(option);
    	}
	}

	// Charger les options d'organisateurs
	function loadOrganizerOptions() {
    	var select = document.getElementById('eventOrganizer');
    	if (!select) return;
    
    	select.innerHTML = '<option value="">-- S√©lectionner --</option>';
    
    	for (var i = 0; i < players.length; i++) {
        	var player = players[i];
        	if (player.active) {
            	var option = document.createElement('option');
            	option.value = player.id;
            	option.textContent = player.name || (player.firstName + ' ' + player.lastName);
            	select.appendChild(option);
        	}
    	}
	}

	// Ajouter une heure de d√©part
	function addTeeTime() {
    	var container = document.getElementById('teeTimesList');
    	if (!container) return;
    
    	var teeTimeId = 'teeTime_' + teeTimeCounter;
    
    	var html = '<div class="tee-time-item" id="' + teeTimeId + '">' +
        	       '<div style="flex: 1;">' +
            	   '<label style="font-weight: bold;">D√©part #' + teeTimeCounter + ':</label>' +
            	   '<input type="time" id="time_' + teeTimeId + '" style="margin: 0 10px;">' +
            	   '<button class="btn-danger" onclick="removeTeeTime(\'' + teeTimeId + '\')">‚ùå</button>' +
            	   '</div>' +
            	   '</div>' +
            	   '<div class="foursome-slot" id="foursome_' + teeTimeId + '">' +
            	   '<select class="player-slot" id="p1_' + teeTimeId + '">' +
            	   '<option value="">Joueur 1</option>' +
            	   '</select>' +
            	   '<select class="player-slot" id="p2_' + teeTimeId + '">' +
            	   '<option value="">Joueur 2</option>' +
            	   '</select>' +
            	   '<select class="player-slot" id="p3_' + teeTimeId + '">' +
            	   '<option value="">Joueur 3</option>' +
            	   '</select>' +
            	   '<select class="player-slot" id="p4_' + teeTimeId + '">' +
            	   '<option value="">Joueur 4</option>' +
            	   '</select>' +
            	   '</div>';
    
    	// Cr√©er un div temporaire
    	var tempDiv = document.createElement('div');
    	tempDiv.innerHTML = html;
    	container.appendChild(tempDiv);
    
    	// Remplir les selects avec les joueurs
    	for (var slot = 1; slot <= 4; slot++) {
        	var select = document.getElementById('p' + slot + '_' + teeTimeId);
        	if (select) {
            	for (var i = 0; i < players.length; i++) {
                	var player = players[i];
                	if (player.active) {
                    	var option = document.createElement('option');
                    	option.value = player.id;
                    	option.textContent = player.name || (player.firstName + ' ' + player.lastName);
                    	select.appendChild(option);
                	}
            	}
        	}
    	}
    
    	teeTimeCounter++;
	}

	// Supprimer une heure de d√©part
	function removeTeeTime(teeTimeId) {
    	var element = document.getElementById(teeTimeId);
    	if (element && element.parentElement) {
        	element.parentElement.remove();
    	}
	}

	// Sauvegarder l'√©v√©nement
	function saveEvent() {
    	var date = document.getElementById('eventDate').value;
    	var course = document.getElementById('eventCourse').value;
    	var type = document.getElementById('eventType').value;
    	var organizerId = document.getElementById('eventOrganizer').value;
    	var comments = document.getElementById('eventComments').value;
    
    	if (!date || !course) {
        	alert('Veuillez remplir au moins la date et le terrain.');
        	return;
    	}
    
    	// Collecter les heures de d√©part
    	var teeTimes = [];
    	var teeTimeElements = document.querySelectorAll('[id^="teeTime_"]');
    
    	for (var i = 0; i < teeTimeElements.length; i++) {
        	var teeTimeId = teeTimeElements[i].id;
        	var timeInput = document.getElementById('time_' + teeTimeId);
        	var time = timeInput ? timeInput.value : '';
        
        	if (time) {
            	var foursome = [];
            	for (var slot = 1; slot <= 4; slot++) {
                	var playerSelect = document.getElementById('p' + slot + '_' + teeTimeId);
                	var playerId = playerSelect ? playerSelect.value : '';
                	if (playerId) {
                	    foursome.push(parseInt(playerId));
                	}
            	}
            
            	teeTimes.push({
                	time: time,
                	players: foursome
            	});
        	}
    	}
    
    	// Cr√©er l'√©v√©nement
    	var newEvent = {
        	id: Date.now(), // ID unique bas√© sur timestamp
        	date: date,
        	course: course,
        	type: type,
        	organizerId: organizerId ? parseInt(organizerId) : null,
        	organizerName: organizerId ? getPlayerName(parseInt(organizerId)) : 'Non d√©fini',
        	teeTimes: teeTimes,
        	comments: comments,
       		createdAt: new Date().toISOString(),
        	createdBy: 'current_user'
    	};
    
    	calendarEvents.push(newEvent);
    
    	// Sauvegarder dans Firebase
    	saveCalendarToFirebase().then(function() {
        	alert('‚úÖ Partie planifi√©e avec succ√®s!');
        	showAddEvent(); // Fermer le formulaire
        	refreshCalendarView();
    	}).catch(function(error) {
        	alert('‚ùå Erreur: ' + error.message);
    	});
	}

	// Vue liste
	function showListView() {
    	var calendarView = document.getElementById('calendarView');
    	var listView = document.getElementById('listView');
    
    	if (calendarView) calendarView.style.display = 'none';
    	if (listView) listView.style.display = 'block';
    
    	var futureEvents = calendarEvents.filter(function(e) {
        	return new Date(e.date) >= new Date();
    	}).sort(function(a, b) {
    	    return new Date(a.date) - new Date(b.date);
    	});
    
    	var html = '<h3>üìÖ Prochaines Parties</h3>';
    
    	if (futureEvents.length === 0) {
    	    html += '<p style="text-align: center; color: #666;">Aucune partie planifi√©e</p>';
    	} else {
    	    html += '<div style="max-height: 500px; overflow-y: auto;">';
        
    	    for (var i = 0; i < futureEvents.length; i++) {
    	        var event = futureEvents[i];
        	    var eventDate = new Date(event.date);
            	var dateStr = eventDate.toLocaleDateString('fr-FR', {
                	weekday: 'long',
                	year: 'numeric',
                	month: 'long',
                	day: 'numeric'
            	});
            
            	html += '<div class="card" style="margin: 10px 0; cursor: pointer;" onclick="showEventDetail(' + event.id + ')">' +
                	    '<div style="display: flex; justify-content: space-between; align-items: center;">' +
                    	'<div>' +
                    	'<h4 style="margin: 0;">' + getEventIcon(event.type) + ' ' + dateStr + '</h4>' +
                    	'<p style="margin: 5px 0;"><strong>' + event.course + '</strong></p>' +
                    	'<small>Organis√© par: ' + event.organizerName + '</small>' +
                    	'</div>' +
                    	'<div style="text-align: right;">' +
                    	'<strong>' + event.teeTimes.length + ' d√©part(s)</strong><br>' +
                    	'<small>Premier: ' + (event.teeTimes[0] ? event.teeTimes[0].time : 'N/A') + '</small>' +
                    	'</div>' +
                    	'</div>';
            
            	if (event.comments) {
                	html += '<div style="margin-top: 10px; padding: 10px; background: #f8f9fa; border-radius: 5px;">' +
                    	    '<small>' + event.comments + '</small>' +
                        	'</div>';
            	}
            
            	html += '</div>';
        	}
        
        	html += '</div>';
    	}
    
    	if (listView) {
        	listView.innerHTML = html;
    	}
	}

	// Afficher les d√©tails d'un √©v√©nement
	function showEventDetail(eventId) {
    	var event = calendarEvents.find(function(e) { return e.id === eventId; });
    	if (!event) return;
    
    	var html = '<div class="event-detail-overlay" onclick="closeEventDetail()"></div>' +
        	       '<div class="event-detail-popup">' +
            	   '<h3>' + getEventIcon(event.type) + ' ' + new Date(event.date).toLocaleDateString('fr-FR') + '</h3>' +
            	   '<p><strong>Terrain:</strong> ' + event.course + '</p>' +
            	   '<p><strong>Organisateur:</strong> ' + event.organizerName + '</p>';
    
    	if (event.comments) {
        	html += '<div style="background: #f8f9fa; padding: 10px; border-radius: 5px; margin: 15px 0;">' +
            	    '<strong>Notes:</strong><br>' + event.comments +
                	'</div>';
    	}
    
    	html += '<h4>‚è∞ Heures de D√©part</h4>';
    
    	for (var i = 0; i < event.teeTimes.length; i++) {
        	var teeTime = event.teeTimes[i];
        	html += '<div style="margin: 10px 0; padding: 10px; background: #e8f5e8; border-radius: 5px;">' +
            	    '<strong>üïí ' + teeTime.time + '</strong>' +
                	'<div style="display: grid; grid-template-columns: repeat(2, 1fr); gap: 10px; margin-top: 10px;">';
        
        	for (var j = 0; j < teeTime.players.length; j++) {
            	var player = players.find(function(p) { return p.id === teeTime.players[j]; });
            	var playerName = player ? (player.name || (player.firstName + ' ' + player.lastName)) : 'Joueur #' + teeTime.players[j];
            	html += '<div style="background: white; padding: 5px 10px; border-radius: 3px;">' +
                	    (j + 1) + '. ' + playerName +
                    	'</div>';
        	}
        
        	html += '</div></div>';
    	}
    
    	html += '<div style="text-align: center; margin-top: 20px;">' +
        	    '<button class="btn" onclick="editEvent(' + eventId + ')">‚úèÔ∏è Modifier</button>' +
            	'<button class="btn-danger" onclick="deleteEvent(' + eventId + ')">üóëÔ∏è Supprimer</button>' +
            	'<button class="btn-secondary" onclick="closeEventDetail()">‚ùå Fermer</button>' +
            	'</div>' +
            	'</div>';
    
    	// Ajouter √† la page
    	var detailDiv = document.createElement('div');
    	detailDiv.id = 'eventDetailPopup';
    	detailDiv.innerHTML = html;
    	document.body.appendChild(detailDiv);
	}

	// Fermer les d√©tails
	function closeEventDetail() {
    	var popup = document.getElementById('eventDetailPopup');
    	if (popup) {
    	    popup.remove();
    	}
	}

	// Fonctions utilitaires
	function getEventIcon(type) {
    	switch(type) {
        	case 'gpr': return 'üéØ';
        	case 'diablo': return 'üèÜ';
        	case 'felton': return 'üèÜ';
        	case 'doubled': return 'üéØ';
        	default: return '‚õ≥';
    	}
	}

	function getPlayerName(playerId) {
    	var player = players.find(function(p) { return p.id === playerId; });
    	return player ? (player.name || (player.firstName + ' ' + player.lastName)) : 'Inconnu';
	}

	function cancelAddEvent() {
    	showAddEvent();
	}

	function refreshCalendarView() {
    	// Rafra√Æchir la vue actuelle
    	if (document.querySelector('.calendar-grid')) {
        	showMonthView();
    	} else {
        	showListView();
    	}
	}

	// Ajouter √† hideAllSections
	function hideAllSections() {
    	var sections = ['overview', 'playerScores', 'courses', 'diablo', 'gpr', 'felton', 'doubled', 'progress', 'details', 'handicapEvolution', 'playerManagement', 'addRound', 'calendar'];
    	for (var i = 0; i < sections.length; i++) {
        	var element = document.getElementById(sections[i]);
        	if (element) {
            	element.style.display = 'none';
        	}
    	}
	}

    // Initialisation au chargement
    window.onload = function() {
        // Charger les donn√©es depuis Firebase
        loadDataFromFirebase();
	}
	
</script>
</body>
</html>